<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>土川的自留地</title>
  
  <subtitle>via fennecs.huang@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://htchz.cc/"/>
  <updated>2020-05-29T09:51:50.329Z</updated>
  <id>https://htchz.cc/</id>
  
  <author>
    <name>土川</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Mysql]漫游bin log</title>
    <link href="https://htchz.cc/2414692924.html"/>
    <id>https://htchz.cc/2414692924.html</id>
    <published>2020-05-26T01:51:00.000Z</published>
    <updated>2020-05-29T09:51:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>binlog是server层的日志，对于innodb来说，只有binlog写完后，才能提交redo log。binlog记录逻辑语句，只会记录写类似于sql的日志。binlog主要的作用</p><ol><li>崩溃恢复</li><li>主从复制</li></ol><h1 id="组织结构">1. 组织结构</h1><h2 id="文件">1.1. 文件</h2><p>binlog的相关配置可以执行<code>show variables like &#39;%bin%&#39;;</code>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%bin%';</span><br><span class="line">+<span class="comment">--------------------------------------------+---------------------------------+</span></span><br><span class="line">| Variable_name                              | Value                           |</span><br><span class="line">+<span class="comment">--------------------------------------------+---------------------------------+</span></span><br><span class="line">| bind_address                               | *                               |</span><br><span class="line">| binlog_cache_size                          | 32768                           |</span><br><span class="line">| binlog_checksum                            | CRC32                           |</span><br><span class="line">| binlog_direct_non_transactional_updates    | OFF                             |</span><br><span class="line">| binlog_error_action                        | ABORT_SERVER                    |</span><br><span class="line">| binlog_format                              | ROW                             |</span><br><span class="line">| binlog_group_commit_sync_delay             | 0                               |</span><br><span class="line">| binlog_group_commit_sync_no_delay_count    | 0                               |</span><br><span class="line">| binlog_gtid_simple_recovery                | ON                              |</span><br><span class="line">| binlog_max_flush_queue_time                | 0                               |</span><br><span class="line">| binlog_order_commits                       | ON                              |</span><br><span class="line">| binlog_row_image                           | FULL                            |</span><br><span class="line">| binlog_rows_query_log_events               | OFF                             |</span><br><span class="line">| binlog_stmt_cache_size                     | 32768                           |</span><br><span class="line">| binlog_transaction_dependency_history_size | 25000                           |</span><br><span class="line">| binlog_transaction_dependency_tracking     | COMMIT_ORDER                    |</span><br><span class="line">| innodb_api_enable_binlog                   | OFF                             |</span><br><span class="line">| innodb_locks_unsafe_for_binlog             | OFF                             |</span><br><span class="line">| log_bin                                    | ON                              |</span><br><span class="line">| log_bin_basename                           | /data/mysql3306/mysql-bin       |</span><br><span class="line">| log_bin_index                              | /data/mysql3306/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators            | ON                              |</span><br><span class="line">| log_bin_use_v1_row_events                  | OFF                             |</span><br><span class="line">| log_statements_unsafe_for_binlog           | ON                              |</span><br><span class="line">| max_binlog_cache_size                      | 18446744073709547520            |</span><br><span class="line">| max_binlog_size                            | 536870912                       |</span><br><span class="line">| max_binlog_stmt_cache_size                 | 18446744073709547520            |</span><br><span class="line">| sql_log_bin                                | ON                              |</span><br><span class="line">| sync_binlog                                | 1                               |</span><br><span class="line">+<span class="comment">--------------------------------------------+---------------------------------+</span></span><br></pre></td></tr></table></figure><p>执行<code>show master status;</code>可以看到当前写入的二进制文件的名字和位置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000930 | 178613715 |              | mysql,test       |                   |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.10</span> sec)</span><br></pre></td></tr></table></figure><p>binlog主要有两种文件：</p><ul><li>二进制日志索引文件（文件名后缀为.index）用于记录所有有效的的二进制文件。</li><li>二进制日志文件（文件名后缀为.****）记录数据库所有的DDL和DML语句事件</li></ul><p>如上输出，二进制日志文件存放的<code>basename</code>是”/data/mysql3306/mysql-bin.****”，二进制日志索引文件路径是”/data/mysql3306/mysql-bin.index”,</p><p>具体如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@dev_test63 mysql3306]# ls -l mysql-bin*</span><br><span class="line">-rw-r----- 1 mysql mysql 538582976 5月  22 01:17 mysql-bin.000919</span><br><span class="line">-rw-r----- 1 mysql mysql 536879010 5月  22 12:03 mysql-bin.000920</span><br><span class="line">-rw-r----- 1 mysql mysql 536885288 5月  22 20:03 mysql-bin.000921</span><br><span class="line">-rw-r----- 1 mysql mysql 536871917 5月  23 05:05 mysql-bin.000922</span><br><span class="line">-rw-r----- 1 mysql mysql 536871391 5月  23 21:40 mysql-bin.000923</span><br><span class="line">-rw-r----- 1 mysql mysql 536895385 5月  24 07:03 mysql-bin.000924</span><br><span class="line">-rw-r----- 1 mysql mysql 536945072 5月  25 00:03 mysql-bin.000925</span><br><span class="line">-rw-r----- 1 mysql mysql 536904757 5月  25 09:03 mysql-bin.000926</span><br><span class="line">-rw-r----- 1 mysql mysql 536871742 5月  25 19:28 mysql-bin.000927</span><br><span class="line">-rw-r----- 1 mysql mysql 536870960 5月  26 04:34 mysql-bin.000928</span><br><span class="line">-rw-r----- 1 mysql mysql 536871255 5月  26 19:33 mysql-bin.000929</span><br><span class="line">-rw-r----- 1 mysql mysql 153202413 5月  27 00:22 mysql-bin.000930</span><br><span class="line">-rw-r----- 1 mysql mysql       228 5月  26 19:33 mysql-bin.index</span><br></pre></td></tr></table></figure><p><code>sync_binlog</code>是用来表示同步刷binlog，如果数据库繁忙可能会造成磁盘io压力大</p><p><code>sql_log_bin</code>表示开启binlog，开关都需要重启mysql</p><p><strong>mysql-bin.index</strong>这个文件很简单，只是记录了当前的binlog列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@dev_test63 mysql3306]# cat mysql-bin.index</span><br><span class="line">./mysql-bin.000919</span><br><span class="line">./mysql-bin.000920</span><br><span class="line">./mysql-bin.000921</span><br><span class="line">./mysql-bin.000922</span><br><span class="line">./mysql-bin.000923</span><br><span class="line">./mysql-bin.000924</span><br><span class="line">./mysql-bin.000925</span><br><span class="line">./mysql-bin.000926</span><br><span class="line">./mysql-bin.000927</span><br><span class="line">./mysql-bin.000928</span><br><span class="line">./mysql-bin.000929</span><br><span class="line">./mysql-bin.000930</span><br></pre></td></tr></table></figure><p>而binlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数<code>0xfe62696e</code>开头（后3字节其实就是”bin”）</p><p>接着是一组Events，Event由header组成，header记录了创建时间、服务器标识等，data是数据。一个binlog文件里，第一个event描述binlog的格式，最后一个binlog描述下一个binlog文件的信息。</p><h2 id="rotation">1.2. rotation</h2><p>当下面三种情况发生时，binlog会rotate新文件：</p><ul><li>实例停止或重启时</li><li>flush logs 命令；</li><li>当前binlog &gt; <code>max_binlog_size</code>(像上面的配置是512M)</li></ul><blockquote><p>如果有一个大事务执行时，很可能会发生一个binlog文件稍大于<code>max_binlog_size</code></p></blockquote><h1 id="模式">2. 模式</h1><p>binlog有三种记录模式，分别是<strong>statement</strong>，<strong>row</strong>，<strong>mixed</strong>，通过<code>binlog_format</code>来指定，可以在运行时指定。</p><!--TODO mysql binlog设置--><h2 id="statement">2.1. statement</h2><p><strong>statement</strong>记录的是原语句，你执行什么语句就会记录什么语句。这在主从复制的时候就会出现一些问题：</p><p>这里提一个问题：<strong>为什么大多数数据库的默认隔离级别是RC，而innodb是RR呢</strong>：</p><p>这是一个历史遗留问题，网上也可以找到很多解释，大体就是：在mysql5.1.5之前只有<strong>statement</strong>模式，如果事务用RC隔离级别，就会可能出现主从不一致的情况。</p><!--TODO 验证--><p>现在已经不能在<strong>statement</strong>模式下执行RC事务了，会报下面的错误：</p><blockquote><p>Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.</p></blockquote><p>假设RC允许，那么假设student表有score字段，</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td>begin;</td></tr><tr><td>delete from student where score &lt; 6;</td><td>/</td></tr><tr><td>/</td><td>insert into student(score) values(1);</td></tr><tr><td>/</td><td>commit;</td></tr><tr><td>commit;</td><td>/</td></tr></tbody></table><p>在RR级别下，事务B的语句会阻塞，因为事务A会给满足条件的列加上X锁，给间隙加上gap锁，所以事务B是会被阻塞的。<br>在RC级别下，事务B的语句是不会阻塞的，因此先于事务A提交，提交完成写入binlog，接着A提交写入binlog，</p><p>所以在binlog里是这样的（只是举个🌰）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(age) <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> age &lt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这样binlog被从库消费之后就主从就不一致。</p><h2 id="row">2.2. row</h2><p><strong>row</strong>是记录到每一行的逻辑语句，比如执行<code>update student set name = &#39;土川&#39; where age &lt; 10</code>的sql，就会生成n条记录。</p><p>这样可以避免<strong>statement</strong>产生的问题，<strong>缺点</strong>就是日志量太大，可能会产生io压力。</p><h2 id="mixed">2.3. mixed</h2><p><strong>mixed</strong>模式是由mysql自行判断使用哪种模式。转换条件<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log-mixed.html" target="_blank" rel="noopener">传送门</a></p><blockquote><p>新版本的MySQL对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更；因此，现在一般使用row level即可。</p></blockquote><h1 id="binlog内容">3. binlog内容</h1><h2 id="mysqlbinlog">3.1. mysqlbinlog</h2><p>mysqlbinlog是mysql提供的一个查看binlog的工具，通过该工具可以将二进制文件解析为文本供我们进行阅读，还可以查看远程服务器上的binlog，可以指定时间或偏移量作为start、stop来作为查询条件。如果指定的偏移量不是一个event的起始偏移量，则会报错。</p><p>当前msyql是row模式，执行<code>mysqlbinlog -v --start-datetime=&quot;2020-05-25 09:59:59&quot; --stop-datetime=&quot;2020-05-25 10:00:00&quot; mysql-bin.000927 --base64-output=decode-rows</code>，<code>--base64-output=decode-rows</code>为了解码<code>row</code>格式，<code>-v</code>详细输出语句。截取一部分如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># at 26237733</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26237798 CRC32 0xbcd552f0 GTID [commit=no]</span></span><br><span class="line"><span class="keyword">SET</span> @@SESSION.GTID_NEXT= <span class="string">'ANONYMOUS'</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment"># at 26237798</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26237883 CRC32 0x5558cbbe Querythread_id=43976966exec_time=0error_code=0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">TIMESTAMP</span>=<span class="number">1590371999</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment"># at 26237883</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26237968 CRC32 0x8f9f400f Table_map: `superq_db`.`superq_trigger_registry` mapped to number 96550</span></span><br><span class="line"><span class="comment"># at 26237968</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26238162 CRC32 0x560afdaa Update_rows: table id 96550 flags: STMT_END_F</span></span><br><span class="line"><span class="comment">### UPDATE `superq_db`.`superq_trigger_registry`</span></span><br><span class="line"><span class="comment">### WHERE</span></span><br><span class="line"><span class="comment">###   @1=15093</span></span><br><span class="line"><span class="comment">###   @2='EXECUTOR'</span></span><br><span class="line"><span class="comment">###   @3='job-executor-saber'</span></span><br><span class="line"><span class="comment">###   @4='172.88.2.128:19012'</span></span><br><span class="line"><span class="comment">###   @5='172.88.2.128:10099'</span></span><br><span class="line"><span class="comment">###   @6=1590371989</span></span><br><span class="line"><span class="comment">### SET</span></span><br><span class="line"><span class="comment">###   @1=15093</span></span><br><span class="line"><span class="comment">###   @2='EXECUTOR'</span></span><br><span class="line"><span class="comment">###   @3='job-executor-saber'</span></span><br><span class="line"><span class="comment">###   @4='172.88.2.128:19012'</span></span><br><span class="line"><span class="comment">###   @5='172.88.2.128:10099'</span></span><br><span class="line"><span class="comment">###   @6=1590371999</span></span><br><span class="line"><span class="comment"># at 26238162</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26238193 CRC32 0x1e662746 Xid = 3290666026</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure><ul><li><code># at xxxx</code>：一个event的开头，</li><li><code>#200525  9:59:59</code>：时间，20年5月25日，9时59分59秒</li><li><code>server id 3306</code>：server编号</li><li><code>end_log_pos 26237798</code>：下一个事件开始的位置（即当前事件的结束位置+1）</li><li><code>CRC32 0xbcd552f0</code>：CRC32是校验和的算法，在上面配置清单里<code>binlog_checksum</code>可以看到，后面跟着的是32位校验和。</li><li><code>Query</code>：event type，具体可以翻阅<a href="https://dev.mysql.com/doc/internals/en/event-classes-and-types.html" target="_blank" rel="noopener">Event Classes and Types</a></li><li><code>thread_id=43976966</code>：线程id</li><li><code>exec_time=0</code>：执行时间</li><li><code>error_code=0</code>：错误码，0表示无错误</li><li><code>Xid = 3290666026</code>：表示redo log和binlog做XA的Xid</li></ul><h3 id="结构体">3.1.1. 结构体</h3><p>前面说到，event分为header和data，事实上，binlog 事件的结构主要有3个版本：</p><ul><li>v1: Used in MySQL 3.23</li><li>v3: Used in MySQL 4.0.2 though 4.1</li><li>v4: Used in MySQL 5.0 and up</li></ul><p>现在基本用的是v4版本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| event  | timestamp         0 : 4    |</span><br><span class="line">| header +<span class="comment">----------------------------+</span></span><br><span class="line">|        | type_code         4 : 1    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | server_id         5 : 4    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | event_length      9 : 4    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | next_position    13 : 4    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | flags            17 : 2    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | extra_headers    19 : x-19 |</span><br><span class="line">+=====================================+</span><br><span class="line">| event  | fixed part        x : y    |</span><br><span class="line">| data   +<span class="comment">----------------------------+</span></span><br><span class="line">|        | variable part              |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure><p>上面用<code>offset : length</code>描述了各个属性的位置，如果事件头的长度是 x 字节，那么事件体的长度为 (event_length - x) 字节；设事件体中 fixed part 的长度为 y 字节，那么 variable part 的长度为 (event_length - (x + y)) 字节</p><h3 id="binlog-checksum">3.1.2. binlog-checksum</h3><p>校验和功能是为了防止传输过程中发生差错，主从不一致。</p><p>关于binlog-checksum有三个参数，分别是</p><ul><li><code>binlog_checksum</code>：默认值是CRC32，可以设置为<code>NONE</code></li><li><code>master_verify_checksum</code>：主库校验event校验和，默认为0，在master thread进行dump的时候校验，在<code>SHOW BINLOG EVENTS</code>校验</li><li><code>slave_sql_verify_checksum</code>：从库校验event校验和，默认为1，当IO thread把event写入到relay log（从库读取到的binlog生成relay log）的时候校验。</li></ul><p>mysqlbinlog可以加上<code>--verify-binlog-checksum</code>参数，打印有问题的sql。</p><p>如果校验失败会报错，可以用<code>pt-table-checksum</code>工具进行修正，关于更多，另行了解。</p><h2 id="SHOW-BINLOG-EVENTS">3.2. SHOW BINLOG EVENTS</h2><p>这个是mysql命令，也是用来阅读binlog。使用方式是<code>SHOW BINLOG EVENTS [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count]</code>，中括号都是可选项。</p><h2 id="GTID">3.3. GTID</h2><p>可以在日志里看到<code>GTID</code>的字眼，GTID即Global Transaction ID，全局事务id，由<code>server_uuid:transaction_id</code>组成，是在mysql5.6引进的一个特性。</p><p>组复制插件<strong>MGR</strong>mysql官方的一个高可用插件，使用了PAXOS协议。在这种一致性协议中需要有一个全局增长的command index，GTID就承担了这个角色。</p><p>执行<code>show variables like &#39;%gtid%&#39;;</code>，输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----------------------------------+-----------+</span></span><br><span class="line">| Variable_name                    | Value     |</span><br><span class="line">+<span class="comment">----------------------------------+-----------+</span></span><br><span class="line">| binlog_gtid_simple_recovery      | ON        |</span><br><span class="line">| enforce_gtid_consistency         | OFF       |</span><br><span class="line">| gtid_executed_compression_period | 1000      |</span><br><span class="line">| gtid_mode                        | OFF       |</span><br><span class="line">| gtid_next                        | AUTOMATIC |</span><br><span class="line">| gtid_owned                       |           |</span><br><span class="line">| gtid_purged                      |           |</span><br><span class="line">| session_track_gtids              | OFF       |</span><br><span class="line">+<span class="comment">----------------------------------+-----------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p><code>gtid_mode</code>其实是<code>OFF</code>状态。</p><p>关于更多，另行了解。</p><h1 id="主从复制">4. 主从复制</h1><p>主从复制有基于binlog和基于GTID两种方式。基于binlog的复制模式的基本流程是：</p><ol><li>master事务提交，将记录变更写入binlog</li><li>slave的io进程连接master，从指定位置或从0开始请求日志</li><li>master返回日志给slave，并带上binlog名称和下一个binlog消费位置</li><li>slave接收到日志，将日志追加到relay log末端，并记录binlog名称和binlog消费位置，下次请求使带上。</li><li>slave的sql进程不断读relay log，执行sql。</li><li>如果slave开启了binlog，又会将执行的sql变更记入binlog；如果slave又是其他slave的master，就会执行一样的逻辑。</li></ol><p>在slave上执行，<code>show slave status\G</code>，部分输出如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 11.198.116.79</span><br><span class="line">                  Master_User: replicator</span><br><span class="line">                  Master_Port: 3018</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000831</span><br><span class="line">          Read_Master_Log_Pos: 1151797</span><br><span class="line">               Relay_Log_File: slave-relay.002490</span><br><span class="line">                Relay_Log_Pos: 313</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000831</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 1151797</span><br><span class="line">              Relay_Log_Space: 769</span><br></pre></td></tr></table></figure><p>如果<code>Read_Master_Log_Pos</code>和<code>Exec_Master_Log_Pos</code>一致，表示从库已经追赶上主库。</p><p>在主库执行<code>show master status\G</code>，可以看到主库当前正在写入的binlog和位置。</p><h1 id="参考">5. 参考</h1><ol><li><a href="https://dev.mysql.com/doc/internals/en/event-structure.html" target="_blank" rel="noopener">Event Structure</a></li><li><a href="https://dominicpoi.com/2019/06/16/MySQL-1/" target="_blank" rel="noopener">MySQL为什么默认隔离级别为可重复读？</a></li><li><a href="https://zhuanlan.zhihu.com/p/33504555" target="_blank" rel="noopener">10分钟学会Mysql之Binlog</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;binlog是server层的日志，对于innodb来说，只有binlog写完后，才能提交redo log。binlog记录逻辑语句，只会记录写类似于sql的日志。binlog主要的作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;崩溃恢复&lt;/li&gt;
&lt;li&gt;主从复制&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>[Mysql]漫游redo log</title>
    <link href="https://htchz.cc/1559835943.html"/>
    <id>https://htchz.cc/1559835943.html</id>
    <published>2020-05-19T14:00:05.000Z</published>
    <updated>2020-05-30T11:43:33.883Z</updated>
    
    <content type="html"><![CDATA[<p>redo log负责记录物理数据页，所以无论执行多少次都是幂等的；而binlog是记录逻辑数据，执行多次就可能重复数据。</p><p>数据结构是一个<strong>环形数组</strong>，innodb将未写入磁盘的页叫做<strong>脏页</strong>，redo log的作用就是记录脏页的数据。</p><p>在宕机恢复时，一个事务是否持久化是根据redo log刷盘情况决定的。如果一个事务的redo log已经全部刷入磁盘，那么这个事务是有效的，反之需要根据undo log回滚。</p><p>redo log在硬盘中是分成多块来存储的，以<code>ib_logfile[number]</code>命名。</p><p>执行<code>SHOW GLOBAL VARIABLES LIKE &quot;innodb_log%&quot;;</code>，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----------------------------+-----------+</span></span><br><span class="line">| Variable_name               | Value     |</span><br><span class="line">+<span class="comment">-----------------------------+-----------+</span></span><br><span class="line">| innodb_log_buffer_size      | 67108864  |</span><br><span class="line">| innodb_log_checksums        | ON        |</span><br><span class="line">| innodb_log_compressed_pages | ON        |</span><br><span class="line">| innodb_log_file_size        | 536870912 |</span><br><span class="line">| innodb_log_files_in_group   | 4         |</span><br><span class="line">| innodb_log_group_home_dir   | ./        |</span><br><span class="line">| innodb_log_write_ahead_size | 8192      |</span><br><span class="line">+<span class="comment">-----------------------------+-----------+</span></span><br></pre></td></tr></table></figure><p><code>innodb_log_files_in_group</code>指定了redo log文件被分为几部分，每一部分的文件大小都是一样的，当写入ib_logfile3后，又继续写入ib_logfile0，如此循环。</p><p>这是在磁盘里的文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@dev_test63 mysql3306]#  ll ib*</span><br><span class="line">-rw-r----- 1 mysql mysql 683671552 5月  20 01:25 ibdata1</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  20 01:24 ib_logfile0</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  19 11:10 ib_logfile1</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  20 01:24 ib_logfile2</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  20 01:25 ib_logfile3</span><br><span class="line">-rw-r----- 1 mysql mysql  79691776 5月  20 01:01 ibtmp1</span><br></pre></td></tr></table></figure><ul><li>ibtmp1是临时表空间，ibdata1是共享表空间。</li></ul><h1 id="为什么要有redo-log">1. 为什么要有redo log:</h1><ul><li>redo log是顺序写入的，而数据页落盘是随机存储。</li><li>延迟刷脏页可以起到合并多次修改的作用，mysql的最小存储单位是页，一个页有多行，如果每次修改一行就要更新整个页，并不是那么能接收。</li></ul><p>有了redo log之后，对于一行数据，首先更新<strong>buffer pool</strong>（在这之前还有undo log），然后再写入log buffer。</p><h1 id="组织结构">2. 组织结构</h1><p>由于redo记录的是物理变更，比如在“第100表空间第100页偏移量1024写入4个字节balabala”，而不是描述第几行改成什么样，一行记录变更涉及的物理页可能有很多，所以可能产生一条redo log，也有可能是多条redo log，这个和undo log不同。 </p><h2 id="redo-log">2.1. redo log</h2><p>这是一条redo log的通用结构<br><img src="../images/20200525182526.png" alt></p><ul><li>type：redo log的类型，可能是基础类型，也可能是复杂类型</li><li>Space ID：表空间id</li><li>page number：页号</li><li>data：redo log内容</li></ul><p>具体type的类型有很多，参考底部链接，其中包括undo log对应的redo log<code>MLOG_UNDO_INSERT</code>。一个操作产生的redo log可能是一个，也可能是一组redo log。</p><h2 id="log-block">2.2. log block</h2><p>组织redo log的是log block，一个log block是存储redo log的基本单位，和页有点类似。<br><img src="../images/20200526000820.png" alt></p><ul><li>log block header：存放block信息</li><li>log block body：存放多条redo log</li><li>log block trailer：存放block的校验值，用于正确性校验</li></ul><p>log buffer和log file都是以log block为基本操作单位，redo log在log block里顺序写入。<br><img src="../images/20200526001104.png" alt></p><h2 id="mtr">2.3. mtr</h2><p>Mini-Transaction，即mtr，</p><p>前面说到一个操作可能产生一组redo log，那么这组redo log是需要保证事务性的，innodb使用mtr这种比transaction更小粒度的事务，来保证一组redo的事务性。</p><p>mtr开启后，会定位到要修改的page的位置，对索引加锁；之后执行一系列写操作，期间产生的redo log会暂存在mtr对象中；mtr提交时，需要把暂存的redo log组放入log buffer中，然后把修改的脏页放入flush list，之后释放page的锁。</p><h1 id="刷盘策略">3. 刷盘策略</h1><p>这里有几个概念</p><ul><li>buffer pool：指在内存中的数据页，innodb需要把物流数据页读到内存中进行修改。</li><li>log buffer：指redo log的buffer，属于进程。</li><li>redo log file：指内存中的redo log文件，属于操作系统，待fsync到磁盘中。</li></ul><p>redo log刷盘时机如下：</p><ul><li>有事务提交时，根据<a href="#事务提交时的刷盘策略">事务提交时的刷盘策略</a>决定是否刷盘</li><li><code>innodb_flush_log_at_timeout</code>默认值为1，也就是1s内如果没发生刷盘，需要进行刷盘</li><li>当log buffer中已经使用的内存超过一半时</li><li>当到达checkpoint时</li></ul><h2 id="事务提交时的刷盘策略">3.1. 事务提交时的刷盘策略</h2><p><code>innodb_flush_log_at_trx_commit</code>指定了redo log的事务提交刷盘策略，分别三个值<br>0：每次提交事务，不会将log buffer写入redo log file，而是由master thread每秒将log buffer写入redo log file，并调用fsync落盘<br>1：每次提交事务，将log buffer写入redo log file，<strong>同时</strong>调用fsync落盘，是<strong>最严格</strong>也是性能<strong>最差</strong>的策略<br>2: 每次提交事务，将log buffer写入redo log file，<strong>每秒</strong>调用fsync落盘</p><p>0和2看起来有点相似。区别在于，前者没有将log buffer同步写入redo log file，要知道redo log file是文件，所以0没同步写入文件，性能会比2高，但mysql崩溃时，会丢失日志；而2同步写入文件，已经将日志提交到操作系统了，只有操作系统宕机了才会丢失日志。</p><p>我们线上数据库<code>innodb_flush_log_at_trx_commit</code>的值是1，有一次同事清理数据时做了个全表更新，redo log疯狂刷盘，从而导致数据库缓慢，于是运维关闭了双1（<code>innodb_flush_log_at_trx_commit</code>和<code>sync_binlog</code>），暂停了清理脚本，才得以恢复。</p><h1 id="LSN">4. LSN</h1><p>Log sequence number是一个8字节的不断增长的数字，表示日志编号，起到一个类似版本的作用，很多地方都有这个LSN，最终需要这n个地方的LSN达到一致。</p><p>通过LSN可以获得：</p><ol><li>数据页的版本信息。</li><li>写入的日志总量，通过LSN开始号码和结束号码可以计算出写入的日志量。</li><li>可知道检查点的位置。</li></ol><p>执行<code>SHOW ENGINE INNODB STATUS;</code>可以看到和LSN有关的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">LOG</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">Log sequence number 1509428892</span><br><span class="line">Log flushed up to   1509428892</span><br><span class="line">Pages flushed up to 1509300590</span><br><span class="line">Last checkpoint at  1509300581</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">3554874 log i/o's done, 0.00 log i/o's/second</span><br></pre></td></tr></table></figure><p><strong>Log sequence number</strong>是redo log buffer的LSN<br><strong>log flushed up to</strong>是刷到redo log file在硬盘中的LSN；<br><strong>pages flushed up to</strong>是已经刷到磁盘数据页上的LSN<br><strong>last checkpoint at</strong>是上一次检查点所在位置的LSN</p><p>可以看到LSN不是完全一致，测试环境db是空闲的，<strong>Log sequence number</strong>和<strong>log flushed up to</strong>是相同的，<strong>pages flushed up to</strong>落后，这是因为脏页很少的话可以暂时不刷到磁盘。</p><p>一般来说，log sequence number &gt; log flushed up to 和 pages flushed up to &gt; last checkpoint at</p><p>可能会出现数据页刷盘快于redo log刷盘的情况，这时checkpoint是有机制保护数据慢于日志，所以会暂停数据页刷盘，等待日志刷盘进度超过数据刷盘。</p><p>由于记录物理数据页，如果在一个事务里把a更新成b，又把b更新为a，会不会保存到redo log里的？</p><p>试验过后，执行<code>SHOW ENGINE INNODB STATUS\G</code>，可以看到<code>Log sequence number</code>有增加；</p><h1 id="checkpoint">5. checkpoint</h1><p>由于redo log相当于给数据页做了个备份，所以事务提交时并不一定要把数据页落盘。但是：1：buffer pool是有限的，2：redo log buffer是有限的。<br>所以需要一个时机，将buffer pool里的数据落盘，同时清除redo log buffer里已经落盘的数据页，这个时机就是checkpoint。数据库重启后的恢复，只需要从checkpoint lsn算起，checkpoint lsn之前的数据都是认为已经持久化的。</p><p>checkpoint的目的很简单，即把数据页落盘，但是什么时候、刷多少页到磁盘、从哪里取脏页都有些不同。</p><p><strong>checkpoint_lsn</strong>是指checkpoint发生刷盘之后，记录此次checkpoint的lsn到redo log file的第一个文件头可以理解为管理数据页缓冲的数据结构，需要保证<br>FLUSH列表：LRU的<br>有两种Checkpoint，分别为：Sharp Checkpoint、Fuzzy Checkpoint。</p><p><strong>Sharp Checkpoint</strong>是全部刷盘，发生在切换redo log文件或者数据库关闭的时候，需要把buffer pool的数据页全刷盘。</p><blockquote><p>MySQL停止时是否将脏数据和脏日志刷入磁盘，由变量<code>innodb_fast_shutdown={ 0|1|2 }</code>控制，默认值为1，即停止时忽略所有flush操作，在下次启动的时候再flush，实现fast shutdown。</p></blockquote><p><strong>Fuzzy Checkpoint</strong>是部分刷盘，分为四种。</p><h2 id="master-thread-checkpoint">5.1. master thread checkpoint</h2><p>由master线程控制，每1秒，每10秒刷入一定比例的脏页到磁盘，异步。</p><h2 id="flush-lru-list-checkpoint">5.2. flush_lru_list checkpoint</h2><p>从MySQL5.6开始可通过<code>innodb_page_cleaners</code>变量指定专门负责脏页刷盘的<strong>page cleaner</strong>线程的个数，该线程的目的是为了保证lru_list表有可用的空闲页。</p><h2 id="async-sync-flush-checkpoint：">5.3. async/sync flush checkpoint：</h2><p>同步刷盘/异步刷盘。例如还有非常多的脏页没刷到磁盘(非常多是多少，有比例控制)，这时候会选择同步刷到磁盘，但这很少出现；如果脏页不是很多，可以选择异步刷到磁盘，如果脏页很少，可以暂时不刷脏页到磁盘。</p><p>这里有四个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_files_in_group=4</span><br><span class="line">innodb_log_file_size=4G</span><br><span class="line">总文件大小: 17179869184</span><br><span class="line"></span><br><span class="line">log_sys-&gt;max_modified_age_async = 12175607164 (71%)</span><br><span class="line">log_sys-&gt;max_modified_age_sync = 13045293390 (76%)</span><br><span class="line">log_sys-&gt;max_checkpoint_age_async = 13480136503 (78%)</span><br><span class="line">log_sys-&gt;max_checkpoint_age = 13914979615 (81%)</span><br></pre></td></tr></table></figure><p>设，checkpoint_age = log_lsn - last_checkpoint_lsn，max_modified_age = log_lsn - 脏页最小lsn</p><p>当max_modified_age &gt; max_modified_age_asyncs，需要flush_list取出脏页，异步刷盘<br>当max_modified_age &gt; max_modified_age_sync，需要flush_list取出脏页，同步刷盘</p><p>当checkpoint_age &gt; max_checkpoint_age_async，可以无需等待checkpoint完成<br>当checkpoint_age &gt; max_checkpoint_age，需要同步等待checkpoint完成</p><h2 id="dirty-page-too-much-checkpoint">5.4. dirty page too much checkpoint</h2><p>脏页太多时强制触发检查点，目的是为了保证缓存有足够的空闲空间。脏页比例由变量 innodb_max_dirty_pages_pct 控制，MySQL 5.6默认的值为75，即当脏页占缓冲池的75%后，就强制刷一部分脏页到磁盘。</p><p>关于上面提到的列表：</p><p>lru_list：是一个使用了最近最少使用算法的列表，可以理解为管理数据页缓冲的数据结构。<br>flush_list：lru的的脏页会放进这个列表，但是不会从lru移除，所以脏页会存在两个地方。flush_list里的脏页会根据lsn最为排序依据，保证lsn小的先落盘。<br>free_list：free_list如果没有空闲页可以分配，就会从lru_list批量淘汰数据页以供使用。</p><h1 id="redo-log太大和太小">6. redo log太大和太小</h1><p>可以看到，<strong>async/sync flush checkpoint</strong>这种类型的checkpoint其实是和log_file的大小有关的。如果log_file小了，会使checkpoint变多，影响innodb性能；如果log_file大了，两次checkpoint跨度大，在恢复的时候<strong>可能</strong>就会等待太久（挂了跑路吧😄）。</p><p>具体多大应该结合实际测试。</p><h1 id="两阶段提交-崩溃恢复">7. 两阶段提交 崩溃恢复</h1><p>另外讲。</p><h1 id="参考">8. 参考</h1><ol><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a></li><li><a href="https://www.cnblogs.com/gomysql/p/3721478.html" target="_blank" rel="noopener">InnoDB log file 设置多大合适？</a></li><li><a href="http://www.yunweipai.com/archives/15563.html" target="_blank" rel="noopener">《MySQL运维内参》节选 | InnoDB日志管理机制（五）</a></li><li><a href="https://www.jianshu.com/p/fdae2e30b9fa" target="_blank" rel="noopener">Redo Log——第一篇</a></li><li><a href="http://mysql.taobao.org/monthly/2015/05/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB redo log漫游</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redo log负责记录物理数据页，所以无论执行多少次都是幂等的；而binlog是记录逻辑数据，执行多次就可能重复数据。&lt;/p&gt;
&lt;p&gt;数据结构是一个&lt;strong&gt;环形数组&lt;/strong&gt;，innodb将未写入磁盘的页叫做&lt;strong&gt;脏页&lt;/strong&gt;，redo
      
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>[Mysql]漫游undo log</title>
    <link href="https://htchz.cc/1791523990.html"/>
    <id>https://htchz.cc/1791523990.html</id>
    <published>2020-05-10T01:51:00.000Z</published>
    <updated>2020-05-29T09:39:47.769Z</updated>
    
    <content type="html"><![CDATA[<p>Innodb学会是不可能学会的，这辈子都学不会的。</p><a id="more"></a><p>innodb是一个<strong>日志先行</strong>（Write-ahead logging）的存储引擎，这也是大部分关系型数据库的特点。而像redis这样的nosql就是数据为先，再进行落盘。</p><p>undo log和redo log和binlog，这三个log是mysql及innodb的关键。这三种日志都会刷盘，其中：</p><ul><li>undo log: 事务原子性和多版本控制MVCC（事务隔离）</li><li>redo log: 事务持久性，宕机恢复</li><li>binlog: 宕机恢复，主从同步</li></ul><p>可以看出三个日志在对应功能上需要相互协作。undo log和redo log是事务日志；redo log要等binlog写入成功才能commit；undo Log保证事务的原子性，redo log保证事务的持久性。</p><p>网上大多都是讲undo log能做什么，但没几篇讲清楚undo log组织结构。innodb最小存储粒度是页<code>page</code>，而页就分为<code>FIL_PAGE_INDEX</code>索引页（索引即数据）和<code>FIL_PAGE_UNDO_LOG</code>undo页。</p><p>部分概念是关于MVCC的，需要配合<a href="./3647734067.html#undo-log">[Mysql]Innodb的快照读实现</a>食用，本文不做讨论。</p><p>undo log就是个历史版本，落盘后不和redo log存在一起。</p><h1 id="表空间">1. 表空间</h1><p>InnoDB存储引擎提供二种数据库表的存储方式</p><ol><li>系统表空间：所有数据上放在一起，物理文件可以拆成多个文件。</li><li>独占表空间：每个表有自己的物理文件，性能更好。</li></ol><p>关于更多不在讨论范围。</p><h1 id="结构层次">2. 结构层次</h1><p>Rollback Segment（rseg）称为回滚段。Mysql5.6之前undo默认记录到系统表空间（ibdata），如果开启了 innodb_file_per_table ，将放在每个表的.ibd文件中。5.6之后还可以创建独立的undo表空间，8之后更是默认打开独立undo表空间，最低数量为2，这样才能保证至少一个undo表空间进行truncate，一个undo表空间继续使用。独立undo表空间的文件格式是undo001，undo002……</p><p>每个rollback Segment中默认有1024个undo log segment，mysql5.5后<strong>1个</strong>undo表空间支持<strong>128个</strong>rollback Segment。0号rollback Segment默认在系统表空间ibdata中，1-32rollback Segment在临时表空间，33～128在独立undo表空间中（没有打开则在系统表空间ibdata中，这样系统表空间会太大），所以<strong>1个</strong>表空间<strong>最多</strong>支持<strong>96*1024</strong>个事务，超了就报错啦。</p><p>一个undo log segment称为undo log或undo slot或undo；一个undo log对象对应多个undo log record，也就是记录的历史版本。</p><p>一个undo log segment有一个page链表，undo log record就是放在page中的，当一个page不足以放下新的undo log record时，会分配新的page，放到链表尾部。</p><p>一个undo log segment其实是一个页叫<code>undo log header page</code>，有INSERT/UPDATE两个类型。这个页有一项内容<code>TRX_UNDO_PAGE_LIST</code>是一个链表，即undo page链表。</p><p><img src="../images/20200510231756.png" alt></p><p>简单来说，结构是这样的：</p><ul><li>rollback segments(128)<ul><li>undo log segments(1024)<ul><li>undo page(N）<ul><li>undo record</li><li>undo record</li><li>…</li></ul></li></ul></li></ul></li></ul><blockquote><p>A collection of undo logs. Undo log segments exists within rollback segments. An undo log segment might contain undo logs from multiple transactions. An undo log segment can only be used by one transaction at a time but can be reused after it is released at transaction commit or rollback——<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log_segment" target="_blank" rel="noopener">mysql#undo_log_segment</a> </p></blockquote><p>一个rollback Segment可以被多个事务使用。而一个undo log segment只能被一个事务占有。由于undo log segment区分插入和更新，又区分临时表和普通表，所以一个事务至多占有<strong>四</strong>个undo log segment。</p><h2 id="头">2.1. 头</h2><p><img src="../images/20200510231756.png" alt><br>这张图里，</p><ul><li>Undo Log Segment Header：是undo log的第一页，不存放record</li><li>undo log header：图里<code>Undo Log Segment Header</code>的<code>TRX_UNDO_LAST_LOG</code>属性指向了一个undo page，每一个undo page都有undo log header描述这个undo page的信息。</li><li>undo page header：图里没有，这个header类似于数据页的page header。</li></ul><h1 id="写undo-log过程">3. 写undo log过程</h1><h2 id="分配回滚段">3.1. 分配回滚段</h2><p>当读写事务开启或只读事务转化为读写事务时，会为一个事务分配事务id和一个回滚段（只读事务的id是0）。</p><p>分配逻辑：</p><ol><li>轮询（环形缓冲，同redo log）选取一个可用的回滚段；</li><li>选取的回滚段引用计数+1（多对一），防止被回收（truncate）。</li><li>临时表使用临时表回滚段，特点是不用写redo log，普通表使用的普通回滚段需要写redo log。</li></ol><h2 id="使用回滚段">3.2. 使用回滚段</h2><p>数据变更时，insert和update分别写相似但不同的undo log。</p><ol><li>临时表不用写redo log</li><li>操作时未分配undo log statement，则对变更类型分配对应的undo log statement</li><li>分配undo log statement时，如果缓存列表有可用的undo log statement，取出来使用。</li></ol><p>redo log有许多种类型，这里是一种type为<code>MLOG_UNDO_INSERT</code>的日志，保证undo log是有效的。</p><h2 id="写入undo-log">3.3. 写入undo log</h2><p>insert的undo record长这样<br><img src="../images/20200510183601.png" alt></p><ul><li>type_cmpl：undo log类型，purge时用</li><li>undo no：事务编号</li><li>table id：表id</li></ul><p>update的undo record长这样<br><img src="../images/20200510185016.png" alt></p><ul><li>DATA_ROLL_PTR：该行对应的前一个历史版本的指针，从而构建一个历史版本的链表</li><li>type_cmpl：undo log类型，辅助purge线程清理</li><li>(posN,lenN,u_old_colN)[]：字段旧值，只需要记录被更新的字段</li><li>(pos,len,colN)[]：被更新的二级索引，回滚的时候需要</li><li>undo no：事务编号</li><li>table id：表id</li></ul><p>事务no和事务id还是有些不同的，事务编号是用来排序的，在事务提交之前通过全局计数器生成，目的是为了放入histroy list有序，方便purge清理。</p><p>不同类型的undo record下有些属性没有，例如索引没变化的情况下，<code>(pos,len,colN)[]</code>就没记录。</p><p>(其实我不知道记unique key干嘛的)</p><h2 id="undo-log类型">3.4. undo log类型</h2><p>purge线程在对待undo log时，会根据undo log的类型做不同的动作，下面分为三类，括号里是动作</p><ul><li>插入：<ul><li>TRX_UNDO_INSERT_REC：表示新增记录（主键记入日志）</li><li>TRX_UNDO_UPD_DEL_REC：当表中有一条被标记为删除的记录和要插入的数据主键相同时，实际是更新这条被标记删除的记录。（主键记入日志）</li></ul></li><li>更新：<ul><li>TRX_UNDO_UPD_EXIST_REC：（将主键和被更新了的字段内容记入日志）</li></ul></li><li>删除：<ul><li>TRX_UNDO_DEL_MARK_REC：（主键记入日志）标记删除</li></ul></li></ul><h2 id="插入">3.5. 插入</h2><p>插入时构建的undo log，包括undo类型，undo no，table id，主键各列信息。</p><p>insert undo log在事务提交后就会被删除。</p><h2 id="更新">3.6. 更新</h2><p>更新时构建的undo log，包括undo类型，undo no，table id，主键各列信息，data_trx_id、data_roll_pointer，被更新的二级索引，n_updated，字段旧值。</p><p>MVCC那篇讲过，每行记录都有三个隐藏字段，所以记录的<code>old_trx_id</code>、<code>old_roll_pointer</code>会被记入undo log，old trx_id表示修改的事务id，old_roll_pointer指向前一个undo record。</p><p>如果要更新一行记录的主键，需要删除记录（delete_mark置1，不能同步删除，为了MVCC），再插入新记录，所以会有<code>TRX_UNDO_DEL_MARK_REC</code>和<code>TRX_UNDO_INSERT_REC</code>两条日志。</p><p>对于二级索引的更新都是删除+插入。</p><p>如果更新一行前后的存储空间不一样大，也需要删除（同步删除）再插入。</p><h2 id="删除">3.7. 删除</h2><p>删除一条记录，其实分两个阶段，</p><ol><li>prepare阶段：将delete标志位置1，构造undo log</li><li>purge阶段：这个发生在事务提交后，将记录移动到垃圾链表，等待复用。</li></ol><p>垃圾链表是指数据页上的一个属性<code>PAGE_FREE</code>，指向一个链表的头节点，可以参阅文章底部的链接。</p><p>删除属于更新，所以他们的undo log是同一个数据结构，不过删除类型的undo log少了n_updated和字段旧值，以及被更新的二级索引。</p><h2 id="事务prepare">3.8. 事务prepare</h2><p>事务开始的阶段，需要将undo log header page的事务状态<code>TRX_UNDO_STATE</code>设置为<code>TRX_UNDO_PREPARED</code><br><img src="../images/20200512183520.png" alt></p><h2 id="事务提交">3.9. 事务提交</h2><p>先说一下history list，<code>show engine innodb status</code>执行这个命令我们可以看到history list</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">TRANSACTIONS</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">Trx id counter 2915975770</span><br><span class="line"><span class="keyword">Purge</span> done <span class="keyword">for</span> trx<span class="string">'s n:o &lt; 2915975770 undo n:o &lt; 0 state: running but idle</span></span><br><span class="line"><span class="string">History list length 47</span></span><br><span class="line"><span class="string">LIST OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="string">---TRANSACTION 421366361910208, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421366361903824, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br></pre></td></tr></table></figure><p>这个值表示还有多少undo log没被清理，这个值太大的话，说明有undo log由于有大事务存在而无法被清理。</p><p><code>Undo Log Segment Header</code>有个<code>TRX_UNDO_STATE</code>，事务提交时，<code>TRX_UNDO_STATE</code>有三种值，</p><ul><li>如果当前的undo log只占一个page，且占用大小使用不足其3/4时(TRX_UNDO_PAGE_REUSE_LIMIT)，则状态设置为<code>TRX_UNDO_CACHED</code>，该undo对象会随后加入到undo cache list上；</li><li>如果事务类型是<code>TRX_UNDO_INSERT_REC</code>，则状态设置为<code>TRX_UNDO_TO_FREE</code></li><li>如果不满足上面的，就需要purge线程去清理，状态设置为<code>TRX_UNDO_TO_PURGE</code></li></ul><p>对于<strong>update undo</strong>对象需要放入<strong>history list</strong>上，具体是将当前undo加入到回滚段header的TRX_RSEG_HISTORY链表上。</p><p>如果<strong>update undo</strong>只有普通表，则给<strong>History list length</strong>+1，如果还有临时表，则+2，然后唤醒purge线程。</p><p>如果<strong>update undo</strong>需要缓存，则放入回滚段的update_undo_cached链表上；否则释放undo对象内存。</p><p>对于<strong>insert undo</strong>在事务释放锁、从读写事务链表清除、关闭read view后才进行，也就是等所有后事都办完才清理。</p><p>如果<strong>insert undo</strong>需要缓存，则放入回滚段的insert_undo_cached链表上；否则释放undo对象内存。和<strong>update undo</strong>不同的是，<strong>insert undo</strong>不需要放入hisotry list。</p><p>事务提交后，回滚段的引用计数-1。</p><p>tip1：由于cache的原因，即使db空闲中，history list的长度一般都不会是0。<br>tip2：insert undo的重用是直接reset，而update undo的重用是会和上一个事务的undo page共存的，具体是undo page上的undo log header有<code>TRX_UNDO_NEXT_LOG</code> 和<code>TRX_UNDO_PREV_LOG</code>来表示事务在页面中的偏移量的</p><h2 id="清理-purge">3.10. 清理 purge</h2><p>purge发生在事务commit时。update undo会被放入history list中，当没有活跃的事务作用于undo log时，会被purge线程清理。如何判断有没有活跃的事务作用于undo log?innodb会快克隆一个活跃的最老的read view，所有在这个read view之前的undo log都是可以清理的。</p><p>purge线程从history list批量取到undo log后，对于in-place更新，需要看需不需要清理二级索引；对于删除操作，需要将删除记录放入数据页垃圾链表<code>PAGE_FREE</code>中。</p><h2 id="回滚">3.11. 回滚</h2><p>事务回滚只需要拿到undo log的进行逆向操作就可以了。</p><p>对于标记删除的记录清理delete_mark；对于更新，将数据回滚到最老版本，回滚索引；对于插入操作，直接删除聚集索引（后）和二级索引（先）。</p><h2 id="持久化">3.12. 持久化</h2><p>todo</p><h2 id="崩溃恢复">3.13. 崩溃恢复</h2><h1 id="后记">4. 后记</h1><p>由于insert和update的种种区别，以至于undo log segment需要分成两种。</p><h1 id="参考">5. 参考</h1><ol><li><a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB undo log 漫游</a></li><li><a href="https://www.kancloud.cn/digest/innodb-zerok/195091" target="_blank" rel="noopener">innodb源码分析之page结构解析</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html" target="_blank" rel="noopener">MySQL 5.7 Reference Manual 14.6.7 Undo Logs</a></li><li><a href="https://jimmy2angel.github.io/2019/05/07/InnoDB-undo-log/" target="_blank" rel="noopener">InnoDB undo log</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Innodb学会是不可能学会的，这辈子都学不会的。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>[网络]利用iptables转发流量</title>
    <link href="https://htchz.cc/2735588161.html"/>
    <id>https://htchz.cc/2735588161.html</id>
    <published>2020-05-01T15:53:39.000Z</published>
    <updated>2020-05-31T08:41:55.802Z</updated>
    
    <content type="html"><![CDATA[<p>之前买的GGC家的HK vps，从去年开始电信访问一直丢包，丢包率一上去，带宽再大速度也是提不上去（<a href="./3284953854.html">[网络]TCP拥塞控制那些事</a>）。</p><p>于是想到买个nat机中转一下流量。</p><p><img src="../images/20200502003159.png" alt><br>(2核384内存，适合用来中转流量)</p><p><img src="../images/20200502000957.png" alt></p><p>nat到手后，机器镜像用的是centos7，我不熟悉firewalld转发，先把iptables装上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 firewalld</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld --now</span><br><span class="line"><span class="comment"># 装iptables</span></span><br><span class="line">yum install iptables-services</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service --now</span><br></pre></td></tr></table></figure><p>接着开启ipv4转发，默认iptables是关闭ipv4转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时开启 ipv4 转发</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="comment"># 永久开启 ipv4 转发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'net.ipv4.ip_forward = 1'</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>接着是加iptables规则，需要在nat表加入一条DNAT和一条SNAT，DNAT是修改目的地址，转发流量到HK vps；SNAT是修改源地址，保证流量回到这台机上（只有这台机知道怎么回到我家）。</p><p>假设NAT机监听<code>10086</code>端口，HK vps的ip是<code>104.104.104.104</code>，ss服务端口是<code>10010</code>，NAT机内网地址是<code>192.168.1.10</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DNAT</span></span><br><span class="line">iptables -t nat -A PREROUTING -p  tcp -m tcp --dport 10086 -j DNAT --to-destination 104.104.104.104:10010</span><br><span class="line"><span class="comment"># SNAT，--to-source ip[:port] port可以不指定，会是随机的</span></span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -m tcp -d 104.104.104.104 --dport 10010  -j SNAT --to-source 192.168.1.10</span><br><span class="line"><span class="comment"># 应用iptables</span></span><br><span class="line">service iptables save</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="comment"># 看下nat表</span></span><br><span class="line">iptables -nL -t nat</span><br></pre></td></tr></table></figure><p>此外，nat机要开放<strong>10086</strong>端口。</p><p>最后一步，在nat控制面板的<strong>NAT转发策略</strong>创建策略，创建一个映射到该机器10086的策略，就能拿到公网ip和端口了。<br><img src="../images/20200502002852.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前买的GGC家的HK vps，从去年开始电信访问一直丢包，丢包率一上去，带宽再大速度也是提不上去（&lt;a href=&quot;./3284953854.html&quot;&gt;[网络]TCP拥塞控制那些事&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;于是想到买个nat机中转一下流量。&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="https://htchz.cc/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]JVM中三色标记法</title>
    <link href="https://htchz.cc/2394647798.html"/>
    <id>https://htchz.cc/2394647798.html</id>
    <published>2020-03-17T14:53:15.000Z</published>
    <updated>2020-04-02T08:07:09.175Z</updated>
    
    <content type="html"><![CDATA[<p>三色标记算法是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。对象分成三种类型:</p><ul><li>黑色:根对象，或者该对象与它的子对象都被扫描</li><li>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><p>根对象被置为黑色，子对象被置为灰色。<br><img src="/images/pasted-115.png" alt="upload successful"><br>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p><p><img src="/images/pasted-116.png" alt="upload successful"><br>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。<br><img src="/images/pasted-117.png" alt="upload successful"><br>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p><p>我们看下面一种情况，当垃圾收集器扫描到下面情况时：<br><img src="/images/pasted-118.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.c=C</span><br><span class="line">B.c=null</span><br></pre></td></tr></table></figure><p>这样，对象的状态图变成如下情形：<br><img src="/images/pasted-119.png" alt="upload successful"><br>这时候垃圾收集器再标记扫描的时候就会下图成这样：<br><img src="/images/pasted-120.png" alt="upload successful"></p><p>显然，C是白色的，也就是漏标了，会被当成垃圾回收掉，这对程序来说是不可以接受的。</p><p>漏标的情况只会发生在白色对象中，且满足以下任意一个条件：</p><ol><li>并发标记时，应用线程给一个黑色对象的引用类型字段赋值了该白色对象</li><li>并发标记时，应用线程删除所有灰色对象到该白色对象的引用</li></ol><p>事实上，方法1是CMS的实现关键，方法2是G1的实现关键，有关实现就移步<a href="./4242301031.html">[JVM]CMS</a>和<a href="./2687941502.html">[JVM]G1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三色标记算法是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。对象分成三种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑色:根对象，或者该对象与它的子对象都被扫描&lt;/li&gt;
&lt;li&gt;灰色:对象本身被扫描,但还没扫描完该对象中的子对象&lt;/li&gt;
&lt;li&gt;白色:未被扫描对
      
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="https://htchz.cc/tags/JVM/"/>
    
      <category term="GC" scheme="https://htchz.cc/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]内存模型</title>
    <link href="https://htchz.cc/93872510.html"/>
    <id>https://htchz.cc/93872510.html</id>
    <published>2020-03-17T06:28:45.000Z</published>
    <updated>2020-03-17T09:18:39.189Z</updated>
    
    <content type="html"><![CDATA[<p>补个内存模型笔记。</p><a id="more"></a><p>JVM 内存共分为虚拟机栈、堆、方法区、PC寄存器（程序计数器）、本地方法栈五个部分。<br><img src="../images/20200317143112.png" alt></p><h1 id="虚拟机栈">1. 虚拟机栈</h1><p>线程私有。一个线程一个虚拟机栈</p><p>一个栈里有多个帧，栈帧包含局部变量表、操作数栈、动态链接、方法出口等。线程调用方法时会创建栈帧入栈，结束方法时会出栈。</p><p>栈深度超过限制会<code>StackOverflowError</code>，栈帧申请时内存不足会报<code>OutOfMemoryError</code>。</p><h2 id="局部变量表">1.1. 局部变量表</h2><p>用于存放局部变量和方法参数的引用，使用<strong>索引</strong>进行访问。</p><p>这个表的组成单位是slot，32位的jvm会使用32位的slot，这也就是为什么<strong>long</strong>/<strong>double</strong>在32jvm不是线程安全的。</p><blockquote><p>被虚拟机栈引用的对象，属于GCROOT，不会回收。如果一个方法很长，但是一个大对象不再被使用，可以设置为将大对象的变量赋值为null来帮助gc。（长方法你就该优化一下了）</p></blockquote><h2 id="操作数栈">1.2. 操作数栈</h2><p>也是存放基本数据类型或引用的，只能进行<strong>出栈/压栈</strong>，使用场景如发起方法调用的时候放参数，算术运算的中间值</p><h2 id="动态链接">1.3. 动态链接</h2><p>一个引用，指向方法区的方法，由于java多态特性，编译后大多数不能确定哪个方法的调用，只能在运行时才能将符号引用转换为直接引用。</p><h2 id="方法返回值">1.4. 方法返回值</h2><p>如果方法是正常退出（没有异常）且有返回值，调用方需要从这里取到返回值，并在栈帧的操作数栈进行压栈。</p><h1 id="PC寄存器（程序计数器）">2. PC寄存器（程序计数器）</h1><p>线程私有。一个线程一个PC寄存器，也叫程序计数器。</p><p>PC寄存器存放了线程当前执行的指令的地址，用于上下文切换后恢复线程上下文。</p><p>如果当前执行的是<strong>native</strong>方法，那么PC寄存器为空。</p><h1 id="本地方法栈">3. 本地方法栈</h1><p>线程私有。一个线程一个本地方法栈。</p><p>类似于<strong>虚拟机栈</strong>，只不过表示的是<strong>native</strong>方法。</p><p>栈深度超过限制会<code>StackOverflowError</code>，栈帧申请时内存不足会报<code>OutOfMemoryError</code>。</p><h1 id="堆">4. 堆</h1><p>线程共享。GC区域。</p><h1 id="方法区">5. 方法区</h1><p>线程共享。逻辑上属于堆内存。主要用于存储类的信息、常量池、静态变量、及时编译器编译后的代码等数据。</p><h2 id="方法区，元空间与永久代">5.1. 方法区，元空间与永久代</h2><p><strong>方法区</strong>是jvm规范，Hotspot以前用<strong>永久代</strong>实现，放在了堆内存里。jdk8完全废除了<strong>永久代</strong>，将这些数据放到了<strong>本地内存</strong>。</p><p>主要原因是:</p><ol><li>常量存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。比如jsp生成动态类，这是比较难预测的。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低，毕竟这些东西是一直不变的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补个内存模型笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="https://htchz.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[k8s]istio自动注入失败</title>
    <link href="https://htchz.cc/855478903.html"/>
    <id>https://htchz.cc/855478903.html</id>
    <published>2020-02-26T16:05:20.000Z</published>
    <updated>2020-02-26T17:25:53.347Z</updated>
    
    <content type="html"><![CDATA[<p>查了我一天喵的</p><a id="more"></a><h1 id="过程">1. 过程</h1><p>istio两种注入模式，一种是执行<code>istioctl kube-inject</code>将目标<code>deployment</code>的yaml先修改，也就是手动注入<code>sidecar</code>和<code>initContainer</code>，另一种就是在<code>pod</code>被部署的时候，利用k8s的<code>webhook</code>机制，进行自动注入。</p><p>在自动注入前，要在部署容器的<code>namespace</code>打上<code>istio-injection: enabled</code>标签，这样才会自动注入，同时，还可以指定<code>template</code>的注解:<code>sidecar.istio.io/inject: true</code>来做更小粒度的控制。</p><p>在使用<code>bookinfo</code>的demo过程中，自动注入并没有生效，甚至连<code>pod</code>都没有<code>create</code>。</p><p>执行<code>kubectl describe deployment productpage</code>查看其中一个<code>deployment</code>，发现只有一个事件， <code>Scaled up replica set productpage-v1-596598f447 to 1</code>，然后就没有然后了。</p><p>执行<code>kubectl describe replicaset productpage-v1-596598f447</code>，显示<strong>failed calling webhook “sidecar-injector.istio.io”: Post <a href="https://istio-sidecar-injector.istio-system.svc:443/inject?timeout=30s" target="_blank" rel="noopener">https://istio-sidecar-injector.istio-system.svc:443/inject?timeout=30s</a>: context deadline exceeded`</strong>，</p><p>查看<code>apiserver</code>的日志，一直提示</p><pre><code>&quot;sidecar-injector.istio.io&quot;: Post https://istio-sidecar-injector.istio-system.svc:443/inject?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</code></pre><p>查看<code>controller-manager</code>的日志，一直提示</p><pre><code>Event(v1.ObjectReference{Kind:&quot;HorizontalPodAutoscaler&quot;, Namespace:&quot;istio-system&quot;, Name:&quot;istio-telemetry&quot;, UID:&quot;da322eac-127a-4c78-89e6-db614d697949&quot;, APIVersion:&quot;autoscaling/v2beta2&quot;, ResourceVersion:&quot;10847941&quot;, FieldPath:&quot;&quot;}): type: &apos;Warning&apos; reason: &apos;FailedComputeMetricsReplicas&apos; invalid metrics (1 invalid out of 1), first error is: failed to get cpu utilization: unable to get metrics for resource cpu: no metrics returned from resource metrics API</code></pre><p>看起来是在说找不到<strong>metrics api</strong>？</p><p>上官网，<a href="https://istio.io/docs/ops/common-problems/injection/" target="_blank" rel="noopener">Istio / Sidecar Injection Problems</a>没有一个描述是符合的。github issue也没有提到要安装<code>metrics-server</code>。</p><p>最后找到一篇<a href="https://www.yp14.cn/2019/12/12/Istio%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5sidecar%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">博客</a>，里面提到</p><p><img src="../images/20200227005407.png" alt><br>于是乖乖安装<code>metrics-server</code>，然后注入<code>sidecar</code>的<code>pod</code>就成功创建了 = = 其实一早就看到关于<strong>metrics api</strong>的报错，但是我认为那是收集监控数据的，于是没鸟他，还是图样了。</p><h1 id="demo">2. demo</h1><p><img src="../images/20200227012503.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查了我一天喵的&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://htchz.cc/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://htchz.cc/tags/k8s/"/>
    
      <category term="istio" scheme="https://htchz.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>[Java代理]Spring的cglib与final方法的坑</title>
    <link href="https://htchz.cc/4249712641.html"/>
    <id>https://htchz.cc/4249712641.html</id>
    <published>2020-01-12T05:51:39.000Z</published>
    <updated>2020-02-18T13:48:06.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>cglib是采用生成目标类subclass方式来代理目标类的，所以如果目标类的方法是<code>final</code>的话，就会直接调用目标类的方法。Spring的cglib代理实现有点坑，就是生成的代理对象是没有调用构造函数的，这个代理对象的成员变量不会初始化。</p><h1 id="null">2. null</h1><p>Spring的aop是基于代理的，而采用cglib的实现下，对于一个bean，假设只代理一次的情况下（增强一次），内存实际是有两个对象，一个代理对象，一个目标对象。当我们调用代理对象的非fianl方法，代理对象调用完切面逻辑，不是调用自己父类方法，而是调用目标对象的目标方法；如果调用代理对象的final方法，代理对象会直接调用目标方法。</p><p>看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRunner</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm &#123;&#125;"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">·</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        objects[<span class="number">0</span>] = <span class="string">"hijacked!"</span>;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxy</span><span class="params">(Class klass)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(klass);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    DefaultRunner runner = (DefaultRunner) cglibProxy.newProxy(DefaultRunner.class);</span><br><span class="line">    runner.run(<span class="string">"proxy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们调用代理对象的<code>runner.run(&quot;Tony&quot;)</code>，日志输出的将会是“I’m Tony”而不是“I’m hijacked!”。</p><p>而Spring使用<code>org.springframework.aop.framework.CglibAopProxy</code>对目标对象进行代理，我的程序在调用一个fianl方法的时候，报了一个NPE异常，debug进去一看，成员变量<code>logger</code>居然是<code>null</code>。<br><img src="../images/20200112142005.png" alt><br>事实上，Spring的<code>CglibAopProxy</code>生成的代理对象的成员变量都是null，因为从Spring设计上，代理类只负责增强逻辑，然后再调用目标对象的方法，所以并没有初始化成员变量的必要。<br><img src="../images/20200112142143.png" alt></p><p>实际上我也不需要这个对象被代理。。手动new一个对象就正常了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;cglib是采用生成目标类subclass方式来代理目标类的，所以如果目标类的方法是&lt;code&gt;final&lt;/code&gt;的话，就会直接调用目标类的方法。Spring的cglib代理实现有点坑，就是生成的代理对象是没有调用构造函数的
      
    
    </summary>
    
      <category term="Proxy" scheme="https://htchz.cc/categories/Proxy/"/>
    
    
      <category term="AOP" scheme="https://htchz.cc/tags/AOP/"/>
    
      <category term="BUG" scheme="https://htchz.cc/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>[Mysql]Innodb的快照读实现</title>
    <link href="https://htchz.cc/3647734067.html"/>
    <id>https://htchz.cc/3647734067.html</id>
    <published>2019-12-11T14:08:30.000Z</published>
    <updated>2020-05-25T09:28:34.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>有一次面试，面试官问我：mysql事务隔离级别有哪些？<br>我：balabala……<br>面试官问：那可重复读是怎么实现的？<br>我：emm。。第一次读会有快照。。<br>面试官：嗯。。<br>我：。。。</p><p>然后呢，然后就不知道啦。</p><p>事实上，Innodb的RC和RR隔离级别下，读有<strong>快照读（snapshot read）</strong>和<strong>当前读（current read）</strong>之分，<strong>当前读</strong>就是<code>SELECT ... LOCK IN SHARE MODE</code>和<code>SELECT ... FOR UPDATE</code>，快照读就是普通的<code>SELECT</code>操作。</p><p><strong>快照读</strong>的实现，利用了<strong>undo log</strong>和<strong>read view</strong>。</p><p><strong>快照读不是在读的时候生成快照，而是在写的时候保留了快照。</strong></p><p><strong>快照读</strong>实现了<strong>Multi-Version Concurrent Control（多版本并发控制）</strong>，简称<strong>MVCC</strong>，指对于同一个记录，不同的事务会有不同的版本，不同版本互不影响，最后事务提交时根据版本先后确定能否提交。</p><p>但是，<strong>Innodb</strong>的读写事务会加排他锁，不同版本其实是<strong>串行</strong>的，所以首先要指出的是，<strong>Innodb事务快照读不是严格的MVCC实现</strong>。</p><h1 id="实现">2. 实现</h1><h2 id="隐藏字段">2.1. 隐藏字段</h2><p>Innodb每一行都有三个隐藏字段，分别是<code>DB_ROW_ID</code>、<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>。</p><p><code>DB_ROW_ID</code>：如果表没有设置主键，用来作为记录的主键，因为<strong>Innodb</strong>使用聚簇索引的方式存储，记录必须有主键。<br><code>DB_TRX_ID</code>：记录修改这行记录事务的id。<br><code>DB_ROLL_PTR</code>：指向这行记录的前一个版本。</p><h2 id="undo-log">2.2. undo log</h2><p>多版本其实是用<strong>undo log</strong>来实现的，<strong>undo log</strong>听起来是做回滚使用的，没错，但是事务提交后<strong>undo log</strong>可不会立刻清除，它作为历史版本存在着。只有当前没有事务依赖在这行记录上时，mysql的清理线程才会清理掉无用的<strong>undo log</strong>。</p><p><code>insert</code>操作的<strong>undo log</strong>在事务回滚或提交后就会删除，因为只有回滚会用到。<br><code>update</code>、<code>delete</code>的<strong>undo log</strong>需要保留（可见<code>delete</code>只是逻辑删除，其实也是个<code>update</code>操作，逻辑删除后由后台线程清理）。</p><p>下面假设有一条记录如下，<strong>column_1</strong>、<strong>column_2</strong>初始值为1和2。<br><img src="../images/20191212171021.png" alt><br>假设这时有个三个事务ABC，A,C事务开始，对这条记录的查询结果如下：</p><table><thead><tr><th align="center">column_1</th><th align="center">column_2</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>接着A事务执行更新<strong>column_1</strong>为11；<br>具体过程是：给记录加X锁，复制记录为<strong>undo_log_1</strong>，然后再将记录的<strong>column_1</strong>改为11，<code>DB_TRX_ID</code>为A，<code>DB_ROLL_PTR</code>指向前一个版本。</p><blockquote><p>虽然数据行和<strong>undo log</strong>画的一样，但实际<strong>undo log</strong>有自己的数据结构。</p></blockquote><p><img src="../images/20191212171048.png" alt><br>A事务提交，释放X锁。</p><p>接着B开启事务，执行更新<strong>column_2</strong>为22；<br>具体过程是：给记录加X锁，复制A事务更新完的记录为<strong>undo_log_2</strong>，然后再将记录的<strong>column_2</strong>改为22，<code>DB_TRX_ID</code>为B，<code>DB_ROLL_PTR</code>指向前一个版本。<br><img src="../images/20191212171106.png" alt><br>然后B事务提交。</p><p>注意！！如果A事务没有提交，X锁是不会释放的，那么B事务对这行记录执行update为了获取X锁会阻塞住的，而<strong>MVCC</strong>标准各个版本应该是不会相互影响的，所以说<strong>Innodb事务快照读不是严格的MVCC实现</strong>。</p><p>那么问题来了，C事务这时执行第二次查询，查询结果会是什么呢。</p><h2 id="read-view">2.3. read view</h2><p>光有多版本还不够，需要一个机制对<strong>undo log</strong>进行可见性判断，决定当前事务读到的是哪个版本，这个机制就是通过<strong>read view</strong>完成，</p><p><strong>read view</strong>是对当前系统中活跃的所有事务列表的封装，注意是所有事务，而不是作用于目标行的事务。</p><p><strong>read view</strong>最早的事务id记为<code>up_limit_id</code>，最迟的事务id记为<code>low_limit_id</code>（<code>low_limit_id</code> = 未开启的事务id = 当前最大事务id+1），活跃事务id列表记为<code>descriptors</code>。</p><p>RC和RR的区别就是，RR在第一次查询会创建新的<strong>read view</strong>，RC是每次查询都创建<strong>read view</strong>。</p><blockquote><p>如果记录上的<code>trx_id</code>小于<code>read_view_t-&gt;up_limit_id</code>，则说明这条记录的最后修改在readview创建之前，因此这条记录可以被看见。</p><p>如果记录上的<code>trx_id</code>大于等于<code>read_view_t-&gt;low_limit_id</code>，则说明这条记录的最后修改在readview创建之后，因此这条记录肯定不可以被看见。</p><p>如果记录上的<code>trx_id</code>在<code>up_limit_id</code>和<code>low_limit_id</code>之间，且<code>trx_id</code>在<code>read_view_t-&gt;descriptors</code>之中，则表示这条记录的最后修改是在readview创建之后，被另外一个活跃事务所修改，所以这条记录也不可以被看见。如果<code>trx_id</code>不在<code>read_view_t-&gt;descriptors</code>之中，则表示这条记录的最后修改在readview创建之前，所以可以看到。</p><p>基于上述判断，如果记录不可见，则尝试使用undo去构建老的版本(row_vers_build_for_consistent_read)，直到找到可以被看见的记录或者解析完所有的undo。</p></blockquote><p>上一节里，假设事务隔离级别是<strong>RR</strong>，事务id大小顺序是：X &lt; C &lt; A &lt; B &lt; D(D是未开启的事务Id)，事务都是读写事务（只读事务不会加入<strong>read view</strong>）</p><p>那么C事务第一次查询创建一个<strong>read view</strong>，<code>up_limit_id</code>为C，<code>low_limit_id</code>为B，<code>descriptors</code>为{C，A}，这时记录的<code>DB_TRX_ID</code>是X，A &gt; X，说明记录可见。</p><p>当A事务更新完毕B事务更新完毕后，C事务执行第二次查询，<strong>read view</strong>还是最开始的那个，此时记录的<code>DB_TRX_ID</code>是B，&gt;= <code>low_limit_id</code>， 因此这条记录肯定不可以被看见，需要沿着历史版本找。</p><p>记录的前一个版本的<code>DB_TRX_ID</code>是A，在<code>up_limit_id</code>和<code>low_limit_id</code>之间, 且在<code>descriptors</code>之间，所以此版本还是不可以被看见，继续往历史版本找。</p><p>前一个版本的<code>DB_TRX_ID</code>是X，&lt; <code>up_limit_id</code>, 所以该版本可见，所以C事务第二次查询结果依旧是：</p><table><thead><tr><th align="center">column_1</th><th align="center">column_2</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>这就做到了可重复读。</p><p><strong>如果是RC呢？</strong></p><p>C事务执行第二次查询，创建新的<strong>read view</strong>，<code>up_limit_id</code>为C，<code>low_limit_id</code>为D，<code>descriptors</code>为{C}，此时记录的<code>DB_TRX_ID</code>是B，在<code>up_limit_id</code>和<code>low_limit_id</code>之间，但是不在在<code>descriptors</code>之中，所以记录是可见的，也就是说C事务可以读到B事务提交的结果，这就是RC快照读的实现。</p><h2 id="幻读">2.4. 幻读</h2><p>RR级别下，在一个事务里，如果全程只进行<strong>快照读</strong>操作，那么是不会发生幻读的，也不会加锁；如果事务进行快照读又进行了写操作，那么就会发生幻读。</p><p>也就是说：RR的幻读只发生在写操作中</p><p>可以用当前读解决幻读。</p><h2 id="聚簇索引">2.5. 聚簇索引</h2><p>聚簇索引在更新主键的时候，会删掉旧记录，插入带有新主键的记录。</p><h2 id="二级索引">2.6. 二级索引</h2><p>二级索引是没有隐藏字段的，所以<strong>没有undo log</strong>，只有一个标志位。</p><p>如果一个update语句更新到了二级索引，旧二级索引<code>delete_mark</code>置1，插入新二级索引。查询的时候，要判断可见性怎么办？根据二级索引找到聚簇索引（无视delete_mark），再从聚簇索引开始可见性判断，找到可见记录，如果可见记录和二级索引维护的结果一致（索引值和主键值一样），就返回记录，否则返回空。</p><p>这样效率比较低，比如student表里age是二级索引，查询条件是age=10，满足这个条件的age-&gt;student_id的二级索引会有多个，事务事务需要遍历所有age=10的索引进行可见性判断才能拿到旧值。</p><p>于是innodb给二级索引加了个<code>MAX_TRX_ID</code>记录最后更新二级索引的事务，如果当前事务read_view的 up_limit_id &gt; MAX_TRX_ID，说明在创建read_view时最后一次更新二级索引的事务已经结束，就可以无视<code>delete_mark=1</code>的二级索引。如果<code>MAX_TRX_ID</code>失效，依旧要遍历所有age=10的二级索引。</p><h2 id="题外话">2.7. 题外话</h2><p>在InnoDB里面有两种事务模式，一种是读写事务，就是会对数据进行修改的事务，另外一种是只读事务，仅仅对数据进行读取。开启一个读写事务要做的事比开启一个只读事务多许多，需要分配回滚段来记录undo log，需要把读写事务加入到全局读写事务链表，把事务id加入活跃读写事务数组中，所以你的事务没有写操作的话，声明为只读事务是个不错的优化。</p><p>5.6 如果要开始只读事务，需要显式指明事务模式为只读；</p><p>5.7如果不指明事务模式，mysql会初始化为只读事务，如果发生写操作，再将事务提升为读写事务，分配回滚段，分配事务id（只读事务也有id啦），加入读写事务链表。<br>5.7如果一次<strong>read view</strong>使用完后，没有新的读写事务创建，那么可以给下一个事务复用。</p><p>还有<strong>性能</strong>，由于读是不加锁的，RR似乎比RC开销小，那是不是RR的性能比RC好？事实是不一定的，在写的时候，RR为了防止幻读，加入了gap和next-key锁，这通常是RR会造成死锁，导致RR比RC差的原因。</p><h1 id="后记">3. 后记</h1><p>在这之前，不明白为什么事务可以临时指定隔离级别，临时指定不需要其他事务配合么，现在应该懂了😎，不过事务还有好多不懂😎</p><h1 id="参考">4. 参考</h1><ol><li><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 事务系统</a></li><li><a href="https://www.cnblogs.com/stevenczp/p/8018986.html" target="_blank" rel="noopener">MySQL InnoDB MVCC深度分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;有一次面试，面试官问我：mysql事务隔离级别有哪些？&lt;br&gt;我：balabala……&lt;br&gt;面试官问：那可重复读是怎么实现的？&lt;br&gt;我：emm。。第一次读会有快照。。&lt;br&gt;面试官：嗯。。&lt;br&gt;我：。。。&lt;/p&gt;
&lt;p&gt;然后
      
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
      <category term="事务" scheme="https://htchz.cc/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]《Redis设计与实现》</title>
    <link href="https://htchz.cc/1473130276.html"/>
    <id>https://htchz.cc/1473130276.html</id>
    <published>2019-12-03T01:01:33.000Z</published>
    <updated>2019-12-11T03:07:48.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>《Redis设计与实现》第二版基于redis3.0，现在6.0都快出了。现在redis和书里有些内容已经不一致了，不过用来探索redis是挺好的。</p><h1 id="碎碎念">2. 碎碎念</h1><h2 id="编码">2.1. 编码</h2><p>现在的redis已经增加了quicklist、stream编码。</p><p>quicklist是ziplist和linkedlist的整合，作为list的唯一编码，其思想就是将ziplist分段，ziplist内存碎片少但每次操作都要申请内存，将ziplist分段，并用操作性能比较好的双向链表把段串起来，这算是时间与空间的折中。</p><p>stream编码用于消息队列，没有去了解。</p><h2 id="字典">2.2. 字典</h2><p>字典expand/resize是redis的一个大话题。</p><p>字典执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时负载因子必须达到5才能进行扩容，执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时不能进行缩容。</p><p>之所以，是因为<code>BGSAVE</code>或<code>BGREWRITEAOF</code>使用了<code>copy-on-write</code>，也就是写时复制。执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时redis会fork子进程，这时候如果进行一个内存的拷贝（保证数据一致性），那么内存的浪费是很大的。使用写时复制，会将父进程的内存设置为只读，将内存和子进程共享，由于内存是分页机制，当某一页内存要发生写操作时，会发生中断，操作系统会把这一页内存复制出来进行修改。</p><p>因此，为了减少写操作导致内存页复制，redis才有了在上面的策略。</p><h2 id="下个2的幂">2.3. 下个2的幂</h2><p>redis在expand/resize都将新数组的长度设置为2的幂，这是因为把数组长度设置为2的幂，就可以把取模运算转化为位运算，java里也是这么做。</p><p>redis作者使用了这么一个算法来求给定一个数的下个2的幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的循环，不过有人给他提出可以用位运算：<a href="https://github.com/antirez/redis/pull/3833" target="_blank" rel="noopener">传送门</a>，java里用的也是这个算法，<a href="./2353864749.html">HashMap的tableSizeFor()</a>。</p><p>作者说不错，但是没必要，这种位运算的魔法对现实来说都是假的，只会把代码搞复杂。</p><h2 id="EMBSTR">2.4. EMBSTR</h2><p>书里的<code>REDIS_ENCODING_EMBSTR</code>支持最大长度39字节，而现在最大支持44字节，原因是3.2版本之后sdshdr变了。<code>REDIS_ENCODING_EMBSTR</code>使用<code>sdshdr8</code>来表示，原来的sdshdr需要8字节，现在使用<code>sdshdr8</code>只需要三字节，那么：44 + 1（<code>&#39;\0&#39;</code>）+ 3 + 16(robj) = 64，刚好是64字节，可以达到64字节内存对齐。</p><p>作者一度用着44的限制，写着39的注释，让我一度迷惑。</p><h2 id="多线程">2.5. 多线程</h2><p>redis6.0加入了多线程，不知道和阿里云的多线程redis有什么区别，看起来都是在io线程并行，工作线程串行。</p><h2 id="raft">2.6. raft</h2><p>redis 领头sentinel选举和主节点选举都是采用raft协议的选举方式：同一个term里，一人一票；当得到majority的票时选举成功，当票被瓜分选举失败开始新一轮。</p><h2 id="LFU">2.7. LFU</h2><p>redis4.0新增了lfu策略来淘汰key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>通过redis.conf的设置，<code>unsigned lru:LRU_BITS</code>的有不同的表示。当表示lfu时，这个字段用8位来当作计数器，用16位当时间戳，16位长度只有两个字节，所以存的时间是以秒位单位。</p><p>在redis里lfu策略下，如果一个key被访问，那么计数器会增加，不过这种增加是需要乘上一个概率的，计数器越大，计数增加的几率越小；而同时key还要根据时间戳判断要不要衰减计数器，以此调整计数。</p><p>在这种策略下，redis会为key初始化一个5的计数器，防止key刚被初始化就被淘汰。</p><h2 id="BITSET">2.8. BITSET</h2><p>位图用来统计是很不错的一个数据类型，在redis里位图也是一个<code>sdshdr</code>，redis将一个字符用作8位，并把位图从低位往高位存储（sdshdr用buf数组存储字符串，当sdshdr表示位图时，buf数组从左往右是从低位到高位），这样当位图需要扩大的时候，只需要在buf数组尾部增加字符就可以了。</p><p>位图的统计的是一个有趣的问题，也就是统计一个二进制数的1有多少个。</p><p>暴力法不考虑，要说的是两个方法，<strong>查表法</strong>还有<strong>variable-precision SWAR算法</strong></p><h3 id="查表法">2.8.1. 查表法</h3><p>查表法就是预先给出各个数的二进制的1的数量，对于比较小的数字，这是一个速度最快的方法。</p><h3 id="variable-precision-SWAR算法">2.8.2. variable-precision SWAR算法</h3><p>这个方法采用位运算，而且还不占额外内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swar</span><span class="params">(<span class="keyword">uint32_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算每两位二进制数中1的个数</span></span><br><span class="line">    i = ( i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    <span class="comment">//计算每四位二进制数中1的个数</span></span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    <span class="comment">//计算每八位二进制数中1的个数</span></span><br><span class="line">    i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    <span class="comment">//将每八位二进制数中1的个数和相加，并移至最低位八位</span></span><br><span class="line">    i = (i * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个32位的数，通过位运算归并1的数量到4个字节中，最后用一个乘法汇总4个字节的1的数量到高8位，这个乘法过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">  x                             00000001 00000001 00000001 00000001</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                                00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">                       00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">              00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">     00000001 00000010 00000011 00000100</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                               |00001010|·······no sense bit·······</span><br></pre></td></tr></table></figure><p>最后右移24位得到这8位的值。</p><h3 id="redis-bitcount">2.8.3. redis bitcount</h3><p>redis采用查法和variable-precision SWAR算法结合的方法来实现bitcount。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> redisPopcount(<span class="keyword">void</span> *s, <span class="keyword">long</span> count) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p4;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> bitsinbyte[<span class="number">256</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">        bits += bitsinbyte[*p++];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count bits 28 bytes at a time */</span></span><br><span class="line">    p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;=<span class="number">28</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4, aux5, aux6, aux7;</span><br><span class="line"></span><br><span class="line">        aux1 = *p4++;</span><br><span class="line">        aux2 = *p4++;</span><br><span class="line">        aux3 = *p4++;</span><br><span class="line">        aux4 = *p4++;</span><br><span class="line">        aux5 = *p4++;</span><br><span class="line">        aux6 = *p4++;</span><br><span class="line">        aux7 = *p4++;</span><br><span class="line">        count -= <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">        aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux2 = aux2 - ((aux2 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux2 = (aux2 &amp; <span class="number">0x33333333</span>) + ((aux2 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux3 = aux3 - ((aux3 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux3 = (aux3 &amp; <span class="number">0x33333333</span>) + ((aux3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux4 = aux4 - ((aux4 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux4 = (aux4 &amp; <span class="number">0x33333333</span>) + ((aux4 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux5 = aux5 - ((aux5 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux5 = (aux5 &amp; <span class="number">0x33333333</span>) + ((aux5 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux6 = aux6 - ((aux6 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux6 = (aux6 &amp; <span class="number">0x33333333</span>) + ((aux6 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux7 = aux7 - ((aux7 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux7 = (aux7 &amp; <span class="number">0x33333333</span>) + ((aux7 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux2 + (aux2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux3 + (aux3 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux4 + (aux4 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux5 + (aux5 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux6 + (aux6 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux7 + (aux7 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>))* <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Count the remaining bytes. */</span></span><br><span class="line">    p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)p4;</span><br><span class="line">    <span class="keyword">while</span>(count--) bits += bitsinbyte[*p++];</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对于位图需要4字节对齐，因为redis里的SWAR算法一次操作4个字节，保证字节对齐可以提高内存读取速度，然后源码里有这么一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">    bits += bitsinbyte[*p++];</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段我看了半天看不懂，最后在stackoverflow<a href="https://stackoverflow.com/questions/19190502/how-do-i-check-a-memory-address-is-32-bit-aligned-in-c" target="_blank" rel="noopener">How Do I check a Memory address is 32 bit aligned in C</a>找到答案，大概意思就是地址结尾是100的倍数，也就是<code>&amp; 11b = 0</code>，那么这个地址就是可以4字节对齐的。所以如果<code>(unsigned long)p &amp; 3</code>为true，说明地址不对齐，就要指针前进一个字节，并通过查表法计算这个字节的1的数量。</p><p>接着同时计算连续的28个字节，每4字节使用一次SWAR算法，再把7次结果汇总。</p><p>最后余下不足28字节的再用查表法计算。整个bitcount的过程就是这样。</p><blockquote><p>统计一个位数组中非0位的数量，数学上称作：”Hanmming Weight“(汉明重量)。</p></blockquote><h2 id="AOF">2.9. AOF</h2><p>即使开启<strong>appendfsync always</strong>配置，redis还是可能丢数据。</p><p>AOF主要靠<code>aof_buf</code>和AOF文件。</p><p>都说redis是基于事件循环的。在一次事件循环里，每个写事件redis都会追加到<code>aof_buf</code>中；每次事件循环后，redis都会把<code>aof_buf</code>的内容写进AOF文件里。但是AOF文件是不会实时刷入硬盘的，而<strong>appendfsync</strong>配置具体就是刷盘时机。开启<strong>appendfsync always</strong>配置后，每个事件循环都会进行刷盘，在这个模式下redis宕机，也会至多丢失一个事件循环的命令。</p><p>题外话，innodb日志系统也有<strong>log buffer</strong>和<strong>log file</strong>，类似于<code>aof_buf</code>和AOF文件，而<strong>innodb_flush_log_at_trx_commit</strong>这个配置控制的也是<strong>log file</strong>刷盘策略，不过innodb可以做到不丢数据，而redis不行。</p><h1 id="参考">3. 参考</h1><ol><li><a href="https://segmentfault.com/a/1190000015481454" target="_blank" rel="noopener">【Redis学习笔记】bitcount分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;《Redis设计与实现》第二版基于redis3.0，现在6.0都快出了。现在redis和书里有些内容已经不一致了，不过用来探索redis是挺好的。&lt;/p&gt;
&lt;h1 id=&quot;碎碎念&quot;&gt;2. 碎碎念&lt;/h1&gt;&lt;h2 id=&quot;编码&quot;&gt;2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[分布式]手撕raft</title>
    <link href="https://htchz.cc/1823228532.html"/>
    <id>https://htchz.cc/1823228532.html</id>
    <published>2019-10-03T08:27:57.000Z</published>
    <updated>2020-02-23T04:26:12.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>Raft作为一个简单的一致性算法，实现一下还是挺好玩的。代码基于<strong>6.824</strong> <a href="http://nil.csail.mit.edu/6.824/2018/labs/lab-raft.html" target="_blank" rel="noopener">lab-raft</a>，<strong>6.824</strong>是麻省理工的分布式课程的一个编号，里面有4个lab，第二个就是raft协议的实现，第三个是基于raft协议的kv存储设计，有待实现（oh我居然在做麻省理工的课程设计）。该lab要求使用go实现算法，并提供了一个<a href="http://oserror.com/distributed/golang-rpc-with-failure-simulation/" target="_blank" rel="noopener">具有故障模拟功能的RPC</a>，即通过模拟网络，在单台机器我们就可以运行raft算法。</p><blockquote><p>做实验前，你应该熟读raft论文，这里是<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">中文版</a></p></blockquote><h1 id="实现">2. 实现</h1><p>参照raft论文和lab提示，整体利用channel作为事件驱动、mutex保证线程安全，写出一个raft算法骨架还是比较容易的。不过在跑test的时候，小小的细节不对就会导致<code>test failed</code>。<br><img src="../images/20191004005135.png" alt><br><strong>raft-lab</strong>提供了17个test，检验了各种情况下的一致性，模拟了各种奇葩网络变化（网络变成这样还是跑路吧），要求4分钟内pass。</p><h2 id="数据结构">2.1. 数据结构</h2><p>参照论文，定义几个数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower = <span class="literal">iota</span></span><br><span class="line">Candidate</span><br><span class="line">Leader</span><br><span class="line"></span><br><span class="line">HeartbeatInterval = <span class="number">100</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">CommandValid <span class="keyword">bool</span></span><br><span class="line">Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">CommandIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="keyword">int</span></span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">LeaderId     <span class="keyword">int</span></span><br><span class="line">PrevLogIndex <span class="keyword">int</span></span><br><span class="line">PrevLogTerm  <span class="keyword">int</span></span><br><span class="line">Entries      []LogEntry</span><br><span class="line">LeaderCommit <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term      <span class="keyword">int</span></span><br><span class="line">Success   <span class="keyword">bool</span></span><br><span class="line">NextIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">currentTerm     <span class="keyword">int</span></span><br><span class="line">mu              sync.Mutex          <span class="comment">// Lock to protect shared access to this peer's state</span></span><br><span class="line">peers           []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister       *Persister          <span class="comment">// Object to hold this peer's persisted state</span></span><br><span class="line">me              <span class="keyword">int</span>                 <span class="comment">// this peer's index into peers[]</span></span><br><span class="line">state           <span class="keyword">int</span>                 <span class="comment">// 0:Follower 1:Candidate 2:Leader</span></span><br><span class="line">votedFor        <span class="keyword">int</span>                 <span class="comment">// 这个实验用index来代替节点</span></span><br><span class="line">voteCount       <span class="keyword">int</span></span><br><span class="line">commitIndex     <span class="keyword">int</span></span><br><span class="line">lastApplied     <span class="keyword">int</span></span><br><span class="line">currentLeaderId <span class="keyword">int</span></span><br><span class="line">log             []LogEntry</span><br><span class="line">nextIndex       []<span class="keyword">int</span></span><br><span class="line">matchIndex      []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">heartbeatCh <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">leaderCh    <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">commitCh    <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">CandidateId  <span class="keyword">int</span> <span class="comment">// 这个实验用index来代替节点</span></span><br><span class="line">LastLogIndex <span class="keyword">int</span></span><br><span class="line">LastLogTerm  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">VoteGranted <span class="keyword">bool</span> <span class="comment">// 是否支持</span></span><br><span class="line">Term        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小声bb，<code>AppendEntriesReply</code>论文是没有返回<code>nextIndex</code>的，而是由leader自己去<strong>减一重试</strong>，这其实是比较慢的，在设置了网络故障<strong>unreliable</strong>的test中，单纯的<strong>减一重试</strong>会导致raft集群在一定时间内不能达到一致。让follower过滤掉同一个term的index，并返回应该尝试的<code>nextIndex</code>，虽然会导致一次复制的日志变多，不过提高了集群达到一致的速度。</p><h2 id="一些封装">2.2. 一些封装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁/释放锁的封装，可以在利用`runtime.Caller`打印获取锁的调用点，虽然性能损失比较大。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字如其名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">getLastLogTerm</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">getLastLogIndex</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="raft实例初始化">2.3. raft实例初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span> *<span class="title">Raft</span></span> &#123;</span><br><span class="line">rf := &amp;Raft&#123;&#125;</span><br><span class="line">rf.peers = peers</span><br><span class="line">rf.persister = persister</span><br><span class="line">rf.me = me</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your initialization code here (2A, 2B, 2C).</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = <span class="number">0</span></span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.currentLeaderId = <span class="number">-1</span></span><br><span class="line"><span class="comment">// 初始化空白日志</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;Term: <span class="number">0</span>&#125;)</span><br><span class="line">rf.applyCh = applyCh</span><br><span class="line"></span><br><span class="line">rf.heartbeatCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">rf.leaderCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">rf.commitCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化随机数资源库</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> rf.state &#123;</span><br><span class="line"><span class="keyword">case</span> Follower:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-rf.heartbeatCh:</span><br><span class="line"><span class="comment">// 这是lab要求心跳</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Int63()%<span class="number">333</span>+<span class="number">550</span>) * time.Millisecond):</span><br><span class="line">rf.state = Candidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Leader:</span><br><span class="line">rf.broadcastAppendEntries()</span><br><span class="line">time.Sleep(HeartbeatInterval)</span><br><span class="line"><span class="keyword">case</span> Candidate:</span><br><span class="line"><span class="keyword">go</span> rf.broadcastVote()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Int63()%<span class="number">300</span>+<span class="number">500</span>) * time.Millisecond): <span class="comment">//随机投票超时是必须的，为了防止票被瓜分完。</span></span><br><span class="line"><span class="keyword">case</span> &lt;-rf.heartbeatCh:</span><br><span class="line">rf.state = Follower</span><br><span class="line"><span class="keyword">case</span> &lt;-rf.leaderCh: </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&lt;-rf.commitCh</span><br><span class="line">rf.applyMsg(applyCh)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回一个raft实例，读取持久化数据，起了两个goroutine。</p><ul><li><p>goroutine1是raft三种状态的转化，这里的超时时间不宜设的太短（太短指论文里的时间），在lab文档里有指出为了配合test，选举超时时间应该<strong>larger than the paper’s 150 to 300 milliseconds</strong></p></li><li><p>goroutine2应用已提交日志。</p></li></ul><p>在初始化channel的时候应该设置缓冲大于1。多余的事件并不会导致系统不一致，但是若由于channel缓冲不够而导致阻塞，就会使raft节点死锁。</p><h2 id="votedFor清空时机">2.4. votedFor清空时机</h2><p>一次rpc，无论是发起端还是接收端，只要收到更大的term，就要调整自己的状态，发生下面变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = remoteTerm</span><br></pre></td></tr></table></figure><p>可以看到<code>state</code>会变成<code>Follower</code>。</p><p>假设一种情景，ABC三个节点下，A为leader，此时C发生分区，那么C一定会不断循环进行超时选举，C的term会一直增大，当C网络恢复重新加入集群后会继续发投票请求rpc。由于C的投票请求rpc中的<code>term</code>较大，集群就会调整<code>currentTerm</code>以及<code>state</code>，已有leader会废掉。而问题是，C的请求投票是无意义的，却使集群进行了一次选举。针对这个问题有个<strong>preVote</strong>方案，就是在投票前调研一下自己是否有投票必要，如果没必要，就不发起投票。这篇文章暂无涉及<strong>preVote</strong>。</p><h2 id="投票发起与接收">2.5. 投票发起与接收</h2><h3 id="broadcastVote-发起投票">2.5.1. broadcastVote() 发起投票</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">broadcastVote</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line">rf.currentTerm++</span><br><span class="line">rf.voteCount = <span class="number">1</span></span><br><span class="line">rf.votedFor = rf.me</span><br><span class="line">vote := &amp;RequestVoteArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">CandidateId:  rf.me,</span><br><span class="line">LastLogIndex: rf.getLastLogIndex(),</span><br><span class="line">LastLogTerm:  rf.getLastLogTerm(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.persist()</span><br><span class="line">rf.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.state != Candidate &#123; <span class="comment">// 发送</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> vote.CandidateId == i &#123; <span class="comment">// 自己的票已经给自己了</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply RequestVoteReply</span><br><span class="line">ok := rf.sendRequestVote(server, vote, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般来说，reply.Term &gt; rf.currentTerm 的情况下 reply.VoteGranted 不会为true</span></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">rf.voteCount++</span><br><span class="line"><span class="keyword">if</span> rf.state == Candidate &amp;&amp; rf.voteCount &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">rf.becomeLeader()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendRequestVote</span><span class="params">(server <span class="keyword">int</span>, args *RequestVoteArgs, reply *RequestVoteReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">"Raft.RequestVote"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接收到投票reply后，查看票根是否过半，如果过半转化为leader。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有加锁，外部调用已经加锁了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.state = Leader</span><br><span class="line">rf.nextIndex = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">rf.matchIndex = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"><span class="comment">// 初始化为0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">rf.leaderCh &lt;- <span class="literal">true</span> <span class="comment">// 结束选举阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestVote-接收投票">2.5.2. RequestVote 接收投票</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args *RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过期的投票请求</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果发起方的term比接收方大</span></span><br><span class="line"><span class="comment">// adjust current term</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &lt; args.Term &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upToDate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm &gt; rf.getLastLogTerm() &#123;</span><br><span class="line">upToDate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm == rf.getLastLogTerm() &amp;&amp; args.LastLogIndex &gt;= rf.getLastLogIndex() &#123;</span><br><span class="line">upToDate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId) &amp;&amp; <span class="comment">// 保证有票</span></span><br><span class="line">upToDate &#123;</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = args.CandidateId</span><br><span class="line">rf.heartbeatCh &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1，进行投票后要发送心跳<code>rf.heartbeatCh &lt;- true</code>，不然节点会由<code>Follower</code>超时，从而使集群选举循环下去。<br>2，判断日志是否较新要满足其中一个条件：一，term较大，二，term一样，但日志index比较大</p><h2 id="日志复制与接收">2.6. 日志复制与接收</h2><h3 id="broadcastAppendEntries-广播日志-心跳">2.6.1. broadcastAppendEntries 广播日志/心跳</h3><p>日志复制lab文档要求一秒不能超过10次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">broadcastAppendEntries</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"></span><br><span class="line">N := rf.commitIndex</span><br><span class="line"><span class="keyword">for</span> i := rf.commitIndex + <span class="number">1</span>; i &lt;= rf.getLastLogIndex(); i++ &#123;</span><br><span class="line"><span class="comment">// 1 是leader本身</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line"><span class="comment">// 只能提交本term的，一旦提交了本term的，旧term也算提交了</span></span><br><span class="line"><span class="keyword">if</span> rf.me != j &amp;&amp; rf.matchIndex[j] &gt;= i &amp;&amp; rf.log[i].Term == rf.currentTerm &#123;</span><br><span class="line">num++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">N = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> N != rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = N</span><br><span class="line">rf.commitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.state != Leader &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123; <span class="comment">// 不用给自己心跳</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args AppendEntriesArgs</span><br><span class="line">args.Term = rf.currentTerm</span><br><span class="line">args.LeaderCommit = rf.commitIndex</span><br><span class="line">args.LeaderId = rf.me</span><br><span class="line">args.PrevLogIndex = rf.nextIndex[i] - <span class="number">1</span></span><br><span class="line">args.PrevLogTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">args.Entries = <span class="built_in">make</span>([]LogEntry, <span class="built_in">len</span>(rf.log[args.PrevLogIndex+<span class="number">1</span>:]))</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="built_in">copy</span>(args.Entries, rf.log[args.PrevLogIndex+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, args AppendEntriesArgs)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line">ok := rf.sendAppendEntries(i, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rf.handleAppendEntriesReply(&amp;args, &amp;reply, i)</span><br><span class="line">&#125;(i, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendAppendEntries</span><span class="params">(server <span class="keyword">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">"Raft.AppendEntries"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次发送日志前，leader从<code>matchIndex[]</code>里统计出应该commit的index，如果index前进，发送commit事件。统计时要判断<code>rf.log[i].Term == rf.currentTerm</code>，也就是说只能提交自己term的log，一旦提交了自己term的log，之前term未被提交的log也算提交了。这个在论文有提到。</p><p>下面是复制日志的响应代码，也很直白。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reply 为 false， 如果不是任期问题，就是日志不匹配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">handleAppendEntriesReply</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.Unlock()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> rf.state != Leader &#123; <span class="comment">// 获取锁后校验自己的状态</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.Term != rf.currentTerm &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.persist()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">        <span class="comment">// len(args.Entries)  == 0 就是心跳了，不用处理</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) &gt; <span class="number">0</span> &#123;</span><br><span class="line">rf.matchIndex[i] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">rf.nextIndex[i] = rf.matchIndex[i] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[i] = reply.NextIndex <span class="comment">// 直接采用follower的建议</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppendEntries-接收日志">2.6.2. AppendEntries 接收日志</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">AppendEntries</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉老term的节点该更新啦</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 心跳</span></span><br><span class="line">rf.heartbeatCh &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust current term</span></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这坨是在日志不匹配的情况下，对leader的NextIndex建议</span></span><br><span class="line"><span class="keyword">if</span> rf.getLastLogIndex() &lt; args.PrevLogIndex &#123;</span><br><span class="line">reply.NextIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">term := rf.log[args.PrevLogIndex].Term</span><br><span class="line"><span class="keyword">if</span> args.PrevLogTerm != term &#123;</span><br><span class="line"><span class="keyword">for</span> i := args.PrevLogIndex - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> rf.log[i].Term != term &#123;</span><br><span class="line">reply.NextIndex = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">reply.NextIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line"><span class="comment">// 删除已存在日志</span></span><br><span class="line">rf.log = rf.log[:args.PrevLogIndex+<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 附加新日志</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = Min(args.LeaderCommit, rf.getLastLogIndex())</span><br><span class="line">rf.commitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这理主要是<code>NextIndex</code>建议值的计算。</p><h2 id="将提交的日志应用至状态机">2.7. 将提交的日志应用至状态机</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">applyMsg</span><span class="params">(applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">msg := ApplyMsg&#123;</span><br><span class="line"><span class="literal">true</span>,</span><br><span class="line">rf.log[i].Command,</span><br><span class="line">i,</span><br><span class="line">&#125;</span><br><span class="line">applyCh &lt;- msg</span><br><span class="line">rf.lastApplied = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用过程其实是由test去管理的，我们只要负责把需要应用的日志放入<code>chan ApplyMsg</code>。</p><h2 id="持久化">2.8. 持久化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">persist</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := gob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">readPersist</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := gob.NewDecoder(r)</span><br><span class="line">d.Decode(&amp;rf.currentTerm)</span><br><span class="line">d.Decode(&amp;rf.votedFor)</span><br><span class="line">d.Decode(&amp;rf.log)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个持久化函数，持久化了<code>currentTerm</code>当前term,<code>votedFor</code>得票者,<code>log</code>日志数组，当这三个属性变化时，都执行一次<code>rf.persist()</code>就没错啦。</p><h1 id="后记">3. 后记</h1><p>表面是在贴代码，实际就是在贴代码。</p><p>由于实验是并发过程，一旦<code>test failed</code>是不容易按线性的过程来分析的。我的方法是多打日志，以及利用<code>net/http/pprof</code>包对程序的goroutine、mutex状态进行分析。</p><p>实现完以后我感觉又变强了（并没有）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;Raft作为一个简单的一致性算法，实现一下还是挺好玩的。代码基于&lt;strong&gt;6.824&lt;/strong&gt; &lt;a href=&quot;http://nil.csail.mit.edu/6.824/2018/labs/lab-raft.h
      
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="raft" scheme="https://htchz.cc/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>[k8s]k8s部署踩坑</title>
    <link href="https://htchz.cc/2102019255.html"/>
    <id>https://htchz.cc/2102019255.html</id>
    <published>2019-08-25T06:06:02.000Z</published>
    <updated>2020-02-26T16:06:20.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>自己搭个k8s集群，踩了一些坑</p><h1 id="镜像">2. 镜像</h1><p><code>kubeadm init</code>命令会去<code>k8s.gcr.io</code>拉镜像，这个地址是得挂代理才能上的（可以指定地址忽略代理），可以用<code>kubeadm config images pull</code>尝试一下，十有八九是不行。不想挂代理的话，用下面这个方法。</p><p>先执行<code>kubeadm config images list</code>列出镜像，输出信息中有两行<code>WARN</code>是获取版本timeout可以不理会。</p><p>接着把列出来的信息放到下面的bash脚本中，运行脚本就把镜像下载好啦(其实就是从阿里云下镜像改tag)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">images=(  <span class="comment"># 下面的镜像应该去除"k8s.gcr.io"的前缀，版本换成上面获取到的版本</span></span><br><span class="line">kube-apiserver:v1.15.3</span><br><span class="line">kube-controller-manager:v1.15.3</span><br><span class="line">kube-scheduler:v1.15.3</span><br><span class="line">kube-proxy:v1.15.3</span><br><span class="line">pause:3.1</span><br><span class="line">etcd:3.3.10</span><br><span class="line">coredns:1.3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="token和ca-cert-hash">3. token和ca-cert-hash</h1><p>在master进行<code>kubeadm init</code>后会输出<code>token</code>和<code>ca-cert-hash</code>，这个要记住，如果忘记了虽然可以执行<code>kubeadm token list</code>获取<code>token</code>，但是<code>ca-cert-hash</code>是不会输出的，忘记<code>ca-cert-hash</code>只能重新执行<code>kubeadm token create</code>从输出中拿到。</p><h1 id="ip转发">4. ip转发</h1><p>在node主机执行<code>kubeadm join</code>的时候，报</p><pre><code>[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1`</code></pre><p>意思是没有开启ipv4转发，设置一下就好了：<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p><h1 id="时间同步">5. 时间同步</h1><p>在node主机执行<code>kubeadm join</code>的时候，一直卡住，加上<code>--v=2</code>可以输出详细信息，输出了一个信息</p><pre><code>I0824 21:58:46.950161   16866 token.go:146] [discovery] Failed to request cluster info, will try again: [Get https://192.168.0.113:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: x509: certificate has expired or is not yet valid]`</code></pre><p>但是我的证书没过期呀，在一个issue里一位老哥说是不是几台机器时间没同步，我在node主机上执行<code>date</code>，果然时间和master差了好久，用于是ntp命令同步了一下时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntpdate</span><br><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><h1 id="hostname">6. hostname</h1><p>在node主机执行<code>kubeadm join</code>的时候，要用<code>--node-name</code>指定节点名字，如果不指定，会用hostname，如果你和我一样主机是用vmware克隆出来的，几台机器的hostname都是一样的，就会执行<code>kubeadm join</code>成功，<code>kubectl get nodes</code>只有一台master(三台机hostname都是master)，<code>kubectl get pods --namespace kube-system</code>的pod也都只有一份。</p><h1 id="网桥地址重复">7. 网桥地址重复</h1><p><code>failed to set bridge addr: &quot;cni0&quot; already has an IP address different from 10.244.1.1/24</code>，执行<code>ip link delete cin0</code>删除<strong>cni0</strong>网桥。</p><h1 id="dashboard-404错误">8. dashboard 404错误</h1><p>输入token后显示的是404，执行<code>kubectl logs</code>发现找不到某些<code>Resource</code>，查看iusse，dashboard v1.X和新版的k8s不兼容，升到v2.x就好了。不过v2.x还没有正式版。</p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;自己搭个k8s集群，踩了一些坑&lt;/p&gt;
&lt;h1 id=&quot;镜像&quot;&gt;2. 镜像&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kubeadm init&lt;/code&gt;命令会去&lt;code&gt;k8s.gcr.io&lt;/code&gt;拉镜像，这个地址是得挂代理才能上的（
      
    
    </summary>
    
      <category term="容器" scheme="https://htchz.cc/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://htchz.cc/tags/k8s/"/>
    
      <category term="deploy" scheme="https://htchz.cc/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>[网络]在浏览器输入一个url到页面展现发生了什么</title>
    <link href="https://htchz.cc/334107480.html"/>
    <id>https://htchz.cc/334107480.html</id>
    <published>2019-08-20T17:01:46.000Z</published>
    <updated>2019-12-03T01:04:31.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>被问起的时候总是两三句话就结束了。这一次想好好总结，描述我所知道的流程。</p><h1 id="过程">2. 过程</h1><h2 id="DNS">2.1. DNS</h2><p>向DNS发起请求，通常是udp协议，获得域名对应的ip地址。</p><p>查找顺序是：浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; ISP的DNS缓存 -&gt; 根服务器</p><h2 id="ARP">2.2. ARP</h2><p>如果不是同一网络的地址，按照路由表找下一跳的ip，通过广播ARP请求获得下一跳mac地址，将报文发往此地址。</p><p>目标网络的网关接收到此报文后，同样发起ARP广播请求，寻找目标ip对应的mac地址，将报文发往此地址。</p><h2 id="TCP三次握手">2.3. TCP三次握手</h2><p>发送端随机选择一个端口和接收端端口之间发起三次握手，之后建立起TCP连接。</p><blockquote><p>Linux执行<code>sysctl -a|grep ip_local_port_range</code>可以看到随机端口选择范围</p></blockquote><h2 id="MSS协商与TCP分段">2.4. MSS协商与TCP分段</h2><p>MSS，Maximum Segment Size，TCP报文数据不能大于这个值，MSS = MTU - IP首部长度，20 - TCP首部长度，20</p><p>为了得出路径最小MSS，TCP一端设置IP报文DF标志（Don’t Fragment flag）告诉IP层不要分片，这样IP必须分片的时候，就会传回一个ICMP差错报文。</p><p>高级的ICMP差错报文会返回发生差错的MTU大小，如果ICMP差错报文没有带回MTU大小，需要发送端不断减少MSS并重发报文，得出合适的MSS。注意，一段时间后TCP会重新协商路径最小MSS，调整路径最小MSS。</p><p>将一个数据分组根据MSS拆成多个TCP报文，这就是<strong>TCP分段</strong>。</p><h2 id="HTTP">2.5. HTTP</h2><p>建立起连接之后，发送HTTP报文。HTTP由<strong>请求行</strong>、<strong>请求头</strong>、<strong>请求主体</strong>组成。</p><ul><li>请求行只有一行，由<strong>方法</strong>，<strong>path</strong>，<strong>协议版本</strong>，以一个<code>\r\n</code>结束。</li><li>请求头由多对<code>key-value</code>组织而成，以一个<code>\r\n</code>换行，以两个<code>\r\n</code>结束。</li><li>请求主体，包含请求的数据/响应数据。</li></ul><p>http1.1版本加入了<code>Connection:Keep-Alive</code>,使得一个TCP连接可以复用多次，而不是一个请求建立起一次连接。<br>http2版本加入TCP多路复用。虽然http1.1版本可以复用TCP连接，但是一次只能发一个HTTP请求报文，想要并行发起多个请求，追能多建立TCP连接，而浏览器一般会限制并发6～8个连接，其余请求只能排队。加入TCP多路复用之后，减少了连接；此外http2采用了二进制传输，头部压缩大幅提高了性能。虽然二进制传输在调试过程不是很方便，但是调试工具都会帮我们转成明文格式展示。</p><blockquote><p>更多信息http2可参见<a href="https://juejin.im/post/5c4e6d11e51d4534dc477f05" target="_blank" rel="noopener">再谈HTTP2性能提升之背后原理—HTTP2历史解剖</a>。本站也有启用http2。</p></blockquote><h2 id="HTTPS">2.6. HTTPS</h2><p>如果启用用HTTPS，客户端会校验服务端的证书，根据证书和服务器协商一个对称加密算法和一个密钥，这一部分是RSA非堆成加密，之后客户端和服务端会使用这个算法和密钥进行数据加密传输。HTTPS的原理出门左转<a href="https://zhuanlan.zhihu.com/p/26684050" target="_blank" rel="noopener">TLS完全指南（一）：TLS和安全通信</a>，这文章讲了HTTPS的部分内容，主要内容是证书方面的内容；还有一部分内容看<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a>，主要补充了用DH算法代替RSA进行密钥交换，避免了密钥在网络中传输。</p><h2 id="TCP拥塞控制">2.7. TCP拥塞控制</h2><p>TCP需要拥塞控制逻辑使用网络不好的情况，详见<a href="./3284953854.html">TCP拥塞控制那些事</a>。</p><h2 id="应用">2.8. 应用</h2><p>关于应用层面的就不说了。</p><h2 id="TCP四次挥手">2.9. TCP四次挥手</h2><p>发送端和接收端之间进行四次挥手断开连接，接着主动断开的端口进入<code>FIN_WAIT_1</code>，收到<strong>ACK报文</strong>后进入<code>FIN_WAIT_2</code>,收到接收端的<strong>FIN报文</strong>后最终会进入<code>TIME_WAIT</code>状态， 默认保持<code>2MSL</code>的不可用时间，防止<strong>相同五元组</strong>的连接建立后，收到上一代连接的重复报文，而产生混乱。被动断开的端口先进入<code>CLOSE_WAIT</code>，由服务器执行断开后发送<strong>FIN报文</strong>进入<code>LAST_ACK</code>状态，收到客户端<strong>ACK报文</strong>进入<code>CLOSED</code>状态。</p><h1 id="后记">3. 后记</h1><p>这个问题能反映出对计算机的网络的了解，其实算是一个能扯很久的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;被问起的时候总是两三句话就结束了。这一次想好好总结，描述我所知道的流程。&lt;/p&gt;
&lt;h1 id=&quot;过程&quot;&gt;2. 过程&lt;/h1&gt;&lt;h2 id=&quot;DNS&quot;&gt;2.1. DNS&lt;/h2&gt;&lt;p&gt;向DNS发起请求，通常是udp协议，获得域名对
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://htchz.cc/tags/TCP/"/>
    
      <category term="HTTP" scheme="https://htchz.cc/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>[分布式]Raft和ZAB的异同</title>
    <link href="https://htchz.cc/3841980432.html"/>
    <id>https://htchz.cc/3841980432.html</id>
    <published>2019-08-18T11:28:38.000Z</published>
    <updated>2019-10-03T08:30:45.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>为了学习<code>etcd</code>,先学习了解一下Raft协议，想总结一下Raft和zookeeper的ZAB协议协议的异同。</p><p>ZAB是对PAXOS算法的改进（没看过PASXOS，好像没有leader概念，我直接看的ZAB），增加了leader、follower、learner的角色。</p><p>Raft自称是比PAXOS更容易理解的一致性算法，和ZAB一样有leader、follower，而且一个强leader的算法。</p><h1 id="时间">2. 时间</h1><p>Raft：使用任期<code>term</code>表示一个选举轮次。  </p><p>ZAB：使用<code>electionEpoch</code>表示一个选举轮次。</p><h1 id="选举">3. 选举</h1><h2 id="投票">3.1. 投票</h2><p>Raft：忽略上一轮投票。选举过程只能进行一次投票，如果投过票了，收到投票请求就会无视。这样越早发起投票的人越有可能当leader；同时，也可能出现每个节点都没有收到majority的投票，出现投票被瓜分的情况。Raft采用设置随机的<strong>选举超时时间</strong>来解决投票被瓜分。  </p><p>ZAB：忽略上一轮投票。每次收到投票请求都会进行判定，然后若自己的投票有变，会重新通知所有节点。这样不会出现投票被瓜分，但是时间会比Raft多很多，导致<strong>服务可用性降低</strong>。</p><h2 id="投票pk">3.2. 投票pk</h2><p>Raft：term大的胜出，相同时<code>index</code>大的胜出</p><p>ZAB：<code>electionEpoch</code>大的胜出，相同时<code>zxid</code>大的胜出</p><h2 id="投票结果">3.3. 投票结果</h2><p>Raft：每个节点都只有自己的投票结果，如果发现自己投票过半，要通知所有节点，并发送心跳，<strong>心跳间隔</strong> &lt; <strong>选举超时时间</strong>.  </p><p>ZAB：每个节点保存所有节点的票根信息，每个节点收到投票请求后都会检查是否有过半的票根，如果有，会和leader建立起一个连接，leader会发送心跳。</p><h2 id="选举结束">3.4. 选举结束</h2><p>Raft：选举完可以立刻提供服务，对于节点不一致的问题，Raft靠接下来附加条目RPC来逐渐修复。按论文说的5台节点的集群，重新选举完成的时间平均是35ms，最长是150ms（选举超时时间配置为12-24ms）。  </p><p>ZAB：选举完得完成<strong>日志同步</strong>才能对外提供服务，而且ZAB的选举可能长达秒级的时间，导致<strong>服务可用性降低</strong>。</p><h1 id="分区容错性">4. 分区容错性</h1><p>当 可用节点 &gt; N/2，Raft和ZAB的集群都是可用的。</p><h1 id="客户端请求">5. 客户端请求</h1><h2 id="读（针对读请求落到follower的情况）">5.1. 读（针对读请求落到follower的情况）</h2><p>Raft：Raft的读其实有几个方案</p><ol><li><strong>强一致读</strong>：转发给leader；leader插入一个空日志获得readIndex；心跳广播(确认自己是leader，才能拥有最新日志)；等待状态机applyIndex经过readIndex（同步最新日志条目）；返回给follower；返回给客户端；</li><li><strong>在follower读</strong>：从leader获得readIndex；等待applyIndex经过readIndex；查询自身状态机；（从leader获得readIndex时，leader也要进行心跳广播）</li><li><strong>折中方案</strong>：leader在接受到majority心跳响应后一段时间内不广播，这是论文作者不推荐的，因为“响应后一段时间内”这个时间可能是不准确的。</li></ol><p>ZAB：follower直接返回，如果一个follower和leader未同步完成，follower返回的是脏数据，如果要保证数据最新，需要客户端调用<code>sync()</code>方法同步数据，正常情况下ZAB只保证最终一致性。</p><h2 id="写">5.2. 写</h2><h3 id="主要流程">5.2.1. 主要流程</h3><p>Raft:</p><ol><li>转发给leader;</li><li>leader将请求封装为entries，写入日志，得到在日志中的index，连同entries发送给followers，注意这可以是<strong>批量</strong>的</li><li>follower执行<strong>接收逻辑</strong>，如果成功写入文件，返回true</li><li>leader收到过半成功回复就更新<code>committIndex</code>，把entries应用到状态机中，回复客户端</li><li>leader下次心跳会带上<code>committIndex</code>的值用<code>leaderCommit</code>表示，followers发现<code>leaderCommit</code>大于自己维护的<code>committIndex</code>，就令 <code>commitIndex</code> 等于 <code>leaderCommit</code> 和 新日志条目索引值中较小的一个  </li></ol><p>ZAB：典型的两阶段提交</p><ol><li>转发给leader</li><li>leader封装为<strong>一个</strong><code>proposal</code>，写入日志，发送给followers</li><li>follower执行<strong>接收逻辑</strong>，如果成功写入文件，返回true</li><li>leader收到过半成功回复就提交<code>proposal</code>，同时广播一个<code>commit</code>消息，通知followers提交提议</li></ol><h3 id="接收逻辑">5.2.2. 接收逻辑</h3><p>Raft：如果<code>prevLogIndex</code>和<code>prevLogTerm</code>不匹配，返回false，由leader调整，从而达到在写请求再同步数据的目的  </p><p>ZAB：没有什么特别的，接收到<code>proposal</code>写入文件，接收到<code>commit</code>提交日志</p><h1 id="旧leader数据">6. 旧leader数据</h1><p>这个是指旧leader崩溃后，新leader对旧数据的处理</p><p>Raft：保守，过半或未过半日志都是未提交。只能提交当前term的日志，如果提交了当前日志，那么旧term的日志也会被一波提交（旧term的日志只能被间接提交）。允许出现未提交的数据被覆盖。</p><p>ZAB：激进，过半或未过半日志都被提交，由zookeeper选举完成后的数据同步完成。</p><h1 id="leader假死">7. leader假死</h1><p>Raft：leader和follower是没有连接的。旧leader假死后，新leader诞生，旧leader复活后发送带有<strong>旧term</strong>的RPCs，follower收到之后返回<strong>新term</strong>给旧leader，旧leader更新<code>term</code>，加入follower大军。 </p><p>ZAB：leader和follower存在连接。旧leader假死后，连接断开，旧leader进入LOOKING状态，从集群中学习投票结果/重新选举，最终找到leader建立起连接。</p><h1 id="请求异常">8. 请求异常</h1><p>Raft：重试，Raft要保证RPCs是幂等的。</p><p>ZAB：follower和leader断开连接，重新加入集群</p><h1 id="挂了的机器加入一个选举完成的集群（不是新加机器）">9. 挂了的机器加入一个选举完成的集群（不是新加机器）</h1><p>Raft：leader会对follower进行RPCs重试，所以恢复的follower会收到leader的心跳请求。</p><p>ZAB：恢复的follower会学习集群中的投票结果，可以识别到leader</p><h1 id="日志复制的顺序">10. 日志复制的顺序</h1><p>Raft：由leader维护log顺序。如果follower重启，不会阻塞leader写入请求，会按照leader顺序追赶日志；如果leader挂了，新leader也可以将旧term、新term日志按顺序提交。</p><p>ZAB：由leader维护log顺序。如果follower重启，会获取leader读锁，leader<strong>阻塞</strong>写入请求，接着追赶差异，获取leader已提交<code>proposal</code>和未提交<code>proposal</code>，然后再释放leader读锁；如果leader重启，新leader选举后会进行数据同步</p><h1 id="集群成员变更">11. 集群成员变更</h1><p>集群配置不能一下子全切换，否则同一个时期可能会出现两个leader。<br>Raft：使用两阶段变更。旧配置为<code>C-old</code>，新配置为<code>C-new</code>，<code>C-old-new</code>表示中间配置。配置变更命令由客户端发起，leader以log传播<code>C-old-new</code>，等<code>C-old-new</code>提交之后，再广播<code>C-new</code>配置，这时不在<code>C-new</code>里的机器就要自觉退出。Raft论文参与者后来还提出一个一阶段变更，提出限制<strong>一次变更只能添加或删除一个成员</strong>来简化问题，如果要变更多个成员，需要执行多次成员变更。</p><p>ZAB：3.5版本以前是停机的，但停机变更也有问题，3.5开始使用了动态变更成员，出门左转<a href="https://zhuanlan.zhihu.com/p/57128195" target="_blank" rel="noopener">Zab协议中的动态成员变更</a>，比Raft难理解😐，反正我是看不下去😐。</p><h1 id="总结">12. 总结</h1><p>Raft是在想解决PAXOS过于复杂的缺点的背景下提出来的一个一致性算法，之前也看过ZAB协议，感觉Raft可用性比ZAB高很多。</p><p>不过有个问题让我迷惑是，在两阶段成员变更方案里，如果提交了<code>C-old-new</code>后，还有旧的Server1，Server2没有复制到，Server1，Server2的配置还是<code>C-old</code><br><img src="../images/20190822194828.png" alt><br>这时候Server1，Server2发生了网络分区，那么这两台服务器还是可以产生基于<code>C-old</code>的leader，而Server3，Server4，Server5形成另一个<strong>majority</strong>，也可以产生一个leader，不一样还会出现双leader问题么？若使用一阶段成员变更，就可以阻止多个majority产生，杜绝这种情况吧。</p><p>很有兴趣实现一个Raft算法。</p><h1 id="参考">13. 参考</h1><ol><li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a>Raft论文汉化</li><li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm(Extended Version)</a>Raft论文原版</li><li><a href="https://mp.weixin.qq.com/s/8HkeYupmqeMjVlXGJDdlLg" target="_blank" rel="noopener">Raft对比ZAB协议</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;为了学习&lt;code&gt;etcd&lt;/code&gt;,先学习了解一下Raft协议，想总结一下Raft和zookeeper的ZAB协议协议的异同。&lt;/p&gt;
&lt;p&gt;ZAB是对PAXOS算法的改进（没看过PASXOS，好像没有leader概念，我
      
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="一致性算法" scheme="https://htchz.cc/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="raft" scheme="https://htchz.cc/tags/raft/"/>
    
      <category term="ZAB" scheme="https://htchz.cc/tags/ZAB/"/>
    
  </entry>
  
  <entry>
    <title>[网络]TCP拥塞控制那些事</title>
    <link href="https://htchz.cc/3284953854.html"/>
    <id>https://htchz.cc/3284953854.html</id>
    <published>2019-08-15T02:05:00.000Z</published>
    <updated>2019-08-22T06:21:52.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>看完了《TCP/IP详解 卷一》，对TCP/IP协议簇的认知多了一些。总结一下TCP窗口有关的慢启动、拥塞避免、快速重传、快速恢复的概念。</p><h1 id="TCP滑动窗口">2. TCP滑动窗口</h1><p>窗口有两种，通告窗口(Receiver Window,rwnd)和拥塞窗口(Congestion Window,cwnd)。  </p><ul><li>通告窗口：通告窗口表明了接收端当前的接受能力。TCP在发送端和接收端都是有缓冲区的，通告窗口声明了当前接收端的缓冲区还能接收的字节大小。这个数值会在TCP报文里携带。</li><li>拥塞窗口：拥塞窗口不被TCP报文传输，是发送端基于拥塞避免算法算出来的一个窗口。这个窗口限制了发送方的发送速率避免网络拥塞。</li></ul><p>两个窗口共同组成了一个滑动窗口。简单来说，通告窗口是强制限制，拥塞窗口是自发限制。</p><p>有一点要注意的是，窗口的单位用字节表示，但是拥塞窗口的调整总是以一个MSS的倍数来调整。</p><p>这里用书上的图描述滑动窗口，<br><img src="/images/pasted-178.png" alt="upload successful"><br>当一个TCP发送方发送数据的时候就会查看可用窗口能否发送（如果启用了Nagle算法，可用窗口必须大于等于一个MSS，发送方才发送数据）</p><p><img src="/images/pasted-177.png" alt="upload successful"><br>上面是抓包得到的一个报文，Win=2027是一个通告窗口，表示服务器的缓冲区还能接受2027字节的数据。</p><h1 id="拥塞控制">3. 拥塞控制</h1><p><img src="/images/pasted-183.png" alt="upload successful"><br>上图是一个tcp刚开始传输数据时的速率变化走向。</p><p>拥塞避免、慢启动、快速重传、快速恢复这四个词其实并不能单独分开讲。当一个连接的网络情况不好的时候，就会<strong>丢包</strong>或<strong>超时</strong>，这时就要降低发送方的发送速率防止恶化，这种就是拥塞控制。</p><p>这种机制涉及到cwnd和ssthresh两个指标，ssthresh是一个区分慢启动和拥塞避免的阈值，当拥塞发生时，分两种情况<br>超时：ssthresh = cwnd / 2（最小为2MSS），cwnd = 1MSS，进入慢启动<br>丢包：ssthresh = cwnd / 2（最小为2MSS），cwnd = ssthresh + 3MSS，进入快速重传</p><h1 id="慢启动">4. 慢启动</h1><p>慢启动其实是发送速率重新计算，cwnd 初始值为一个数据报大小，ssthresh初始值为65535，是一个然后在到达阈值之前，每接收到一个新的ACK，cwnd就会增加一个报文段的大小，这样子慢启动其实是以指数增加网络传</p><h1 id="拥塞控制-1">5. 拥塞控制</h1><p><img src="/images/pasted-185.png" alt="upload successful"><br>上图是一个tcp刚开始传输数据时的速率变化走向。</p><p>拥塞避免、慢启动、快速重传、快速恢复这四个词其实并不能单独分开讲。当一个连接的网络情况不好的时候，就会<strong>丢包</strong>或<strong>超时</strong>，这时就要降低发送方的发送速率防止恶化，这种就是拥塞控制。</p><p>这种机制涉及到cwnd和ssthresh两个指标，ssthresh是一个区分慢启动和拥塞避免的阈值，当拥塞发生时，分两种情况<br>超时：ssthresh = cwnd / 2（最小为2MSS），cwnd = 1MSS，进入慢启动<br>丢包：进入快速重传</p><h2 id="慢启动-1">5.1. 慢启动</h2><p>慢启动其实是发送速率重新计算，cwnd 初始值为一个数据报大小，ssthresh初始值为65535，是一个然后在到达阈值之前，每接收到一个新的ACK，cwnd就会增加一个报文段的大小，这样子慢启动其实是以指数增加网速到一个比较平衡的水平。</p><h2 id="拥塞避免">5.2. 拥塞避免</h2><p>当cwnd大于等于ssthresh时进入拥塞避免状态，在一个RTT内无论收到多少ACK都只将cwnd增加一个报文大小，从时间上来看网速线性增加。</p><h2 id="快速重传和快速恢复">5.3. 快速重传和快速恢复</h2><p>快速重传指，当收到重复的3个ACK报文时（duplicate ack），设置<code>ssthresh = cwnd / 2（最小为2MSS），cwnd = ssthresh + 3MSS</code>，然后进入快速恢复阶段。</p><p>暂停发送新的报文，重传丢失报文。</p><p>接下来每收到重复的ACK时，将cwnd增加一个报文大小。如果cwnd大于未确认报文大小（报文丢失后我们还在发新的报文，未确认报文指丢失报文到最后一个报文之间报文总大小），可以发送新报文。</p><p>接下来如果收到新的ACK报文，将cwnd设置为ssthresh，也就是网速降为一半，并进入拥塞避免阶段。</p><p>总的来说，网速一直处于一个动态调整的过程，一个连接上cwnd随时间的变化如图所示</p><p><img src="/images/pasted-182.png" alt="upload successful"></p><p>还有一点，上面关于cwnd的比较其实还要考虑rwnd的值，如果rwnd&gt;cwnd，应取rwnd去比较，毕竟两者决定了可用窗口大小。</p><h1 id="后记">6. 后记</h1><p>TCP拥塞控制其实还有很多改进未去了解。比如当收到重复的3个ACK报文时，其实不一定只丢了一个报文，所以网速可能指数下降，不能达到快速恢复的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;看完了《TCP/IP详解 卷一》，对TCP/IP协议簇的认知多了一些。总结一下TCP窗口有关的慢启动、拥塞避免、快速重传、快速恢复的概念。&lt;/p&gt;
&lt;h1 id=&quot;TCP滑动窗口&quot;&gt;2. TCP滑动窗口&lt;/h1&gt;&lt;p&gt;窗口有两种，
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://htchz.cc/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]给机器加个监控</title>
    <link href="https://htchz.cc/3663317463.html"/>
    <id>https://htchz.cc/3663317463.html</id>
    <published>2019-07-20T05:49:00.000Z</published>
    <updated>2019-07-20T12:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>明明只有一台破机器，却要装成用不起的样子</p><p><img src="/images/pasted-176.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;明明只有一台破机器，却要装成用不起的样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-176.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="碎碎念" scheme="https://htchz.cc/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>[FCM]用FCM做一个跨设备消息同步工具</title>
    <link href="https://htchz.cc/2379284348.html"/>
    <id>https://htchz.cc/2379284348.html</id>
    <published>2019-05-18T03:00:00.000Z</published>
    <updated>2019-05-20T07:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Fcm真是个好东西，希望你也有。</p><a id="more"></a><h1 id="需求背景">1. 需求背景</h1><p>作为一个穷人，手持不了iPhone(滑稽)，当同时使用着macOS、windows、安卓三个平台时，我面临着几个问题：</p><ol><li>传文件。对于传文件，有许多方案，我偏向于用Feem或者共享文件夹，都是局域网传输，又快又不用经过第三方服务器。</li><li>复制文本。iPhone和mac之间有通用剪切板，win10和iPhone、安卓之间有微软小娜。</li><li>通知同步。主要是手机通知，上班工作时，听到手机推送的声音想知道时什么东西又懒得去看手机。</li><li>短信验证码。电脑上用短信验证码场景并不是很多，不过我们公司的线上服务器登录时需要短信验证码的二次验证，这时候去解锁手机、看验证码、一个一个输入终端。。。妈蛋很烦。</li></ol><p>于是找了一堆，AirDroid、Pushbullet等等，在到处讲隐私的今天，我觉得把自己的剪切板、短信、通知就这么发送给人家总是有点不安（不过用fcm也是把数据给号称‘不作恶’口号的谷歌）。偶然看到了剪纸云，是个收费软件，不过看了简介说是用FCM做的，找了下FCM的接入指北，自己做一个同步工具。</p><h1 id="整体流程">2. 整体流程</h1><p><img src="/images/pasted-174.png" alt="upload successful"></p><p>数据的流向如图，终端把要同步的数据发到自己的应用服务器，应用服务器载把数据发到FCM，交由FCM推送到设备组。</p><p>对于每一台设备，当应用与FCM建立起连接后可以得到一个fcm token，这个token就是这台设备这个应用的id了。</p><p>至于设备组id，我是用Firebase-Auth的userId作为设备组id的。</p><p>程序主要流程是：</p><ol><li>客户端启动时获取fcm token，持久化存储（这个fcm token除非把应用删了和我不知道的情况，否则万年不更新一次，当然fcm sdk提供了更新的回调，我们要实现这个方法。）</li><li>客户端登录，拉起谷歌的OAuth2.0授权（Chrome插件用的clientId模式），登录成功后获取到firebase-auth的userId，持久化存储</li><li>登录成功后把userId和fcm token发送到应用服务器保存，维护双向关系，完成注册。</li><li>客户端每次发送同步数据时，带上时间戳、同步类型、fcm token等内容。</li><li>客户端接受到fcm推送时，见机行事。</li></ol><p>同步数据的数据结构</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>短信、通知、剪切板</td></tr><tr><td>time</td><td>毫秒时间戳，也作为分片id（其实是偷懒）</td></tr><tr><td>text</td><td>文本内容</td></tr><tr><td>head</td><td>额外内容，主要是为了存通知的通知标题</td></tr><tr><td>fcm_token</td><td>设备id</td></tr><tr><td>mark</td><td>分片的标识，8位整数，高位起第一位表示是否分片，第二位表示是否还有分片，余下6位表示分片顺序</td></tr></tbody></table><h1 id="服务端">3. 服务端</h1><p>服务端用go写的，框架使用gin，数据库用redis。</p><p>主要维护两个关系。</p><ol><li>设备id到设备组id的关系</li><li>设备组id到所有设备id的关系</li></ol><p>第一个直接用redis的kv模型，第二个用redis的哈希模型。</p><p>当服务器接收到客户端的同步请求时，推送到fcm有两种方式。</p><ol><li>使用fcm的设备组管理，fcm设备组管理需要新建设备组，把fcm token添加到设备组，发送同步数据时，带上fcm设备组id，fcm就会把同步数据推送到所有组。对于已经失效的fcm token，fcm设备组管理会自己清理。</li><li>自己维护设备组，遍历设备组的设备，一个个带上fcm token推到fcm。如果接收到fcm token无效的响应，就从redis把fcm token的kv关系、哈希关系删除。</li></ol><p>使用fcm的设备组管理的好处是只需要维护设备id到设备组id的关系，对于一些无效的fcm token由fcm自己去管理，不足的是目前fcm设备组管理没有提供API获取设备组的设备组列表，而且一发就是发全部，客户端发消息出去，待会又收到自己的消息。此外，fcm设备组管理在go没有sdk。。。</p><p>所以我决定自己管理设备组。</p><p>这里有一个☝️剪切板的问题，当发送到fcm的payload大于4kb的时候，会返回</p><pre><code>400; reason: request contains an invalid argument; code: invalid-argument; details: Request contains an invalid argument.</code></pre><p>也就是说，我们要控制好数据大小。作为ctrl cv工程师，如果要从mac往windows复制1000行代码怎么办？答案是分片。</p><p>正如ip分片和tcp分段为了解决报文的大小限制，我们要在应用层进行分片重组。不过这个由于是应用层的分片要简单的多。</p><ol><li>应用服务器接收到同步数据后，如果text文本大于4kb，则进行分片，mark高位第一位置0，否则置1直接推到FCM。</li><li>第二步，由于json是个文本协议，我们分片的时候有两种方案，第一种转换为字节分片，第二种转换为rune分片（rune是go的数据类型，可以表示一个utf8字符），一个rune的大小是4个字节，为了防止达到限制，rune分片大小应为1000个rune，不过这样就可能会导致一次payload利用率不高，毕竟1000个汉字是1000个rune，至少占3000字节，1000个字母也是1000个rune，占1000个字节；好处是在客户端可以直接使用。如果使用字节分片，客户端接收到分片后需要转换为字节数组，组合字节数组，再将字节数组转换为字符串，炒鸡麻烦。</li><li>接下来在分片mark高位起低6位设置好分片顺序，只要简单的0，1，2..这样就好了（不同于ip分片，ip分片使用的是数据偏移量作为位置索引）。如果是最后一片分片，mark高位起第二位要置1表示没有更多分片。</li></ol><p>接下来利用sdk推送到fcm就好了。应用服务器的接入fcm有多种方式，文档真是傻瓜式教程。</p><h1 id="客户端">4. 客户端</h1><p>客户端写Chrome拓展和android。<br>主要流程是</p><ol><li>根据接收到的数据类型处理，<br>（1）通知直接显示，<br>（2）短信显示并且检验有没有验证码，有则将验证码提取放入剪切板，<br>（3）剪切板进行分片判断</li><li>如果不是分片，直接放入剪切板，否则进行重组。</li></ol><p>重组需要一个全局哈希表，key为时间戳，也是分片id（这里用时间戳是偷懒，毕竟一个人1毫秒内也不能复制两次叭）；value是维护分片的数据结构FragHold，如下</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>整型</td></tr><tr><td>length</td><td>整型</td></tr><tr><td>text</td><td>数组</td></tr></tbody></table><p>当第一个分片到来时，将分片time作为key，初始化一个FragHold。每次到达一个分片，FragHold.count加1，当最后一个分片到来，FragHold.length可以确定。如果FragHold的count == length，那么分片重组完成，直接对数组一个join操作得到一篇完整的千字文，又可以愉快地ctrl cv了。</p><p>此外起一个定时任务，不断将全局哈希表里过期的FragHold剔除，毕竟这个是没有超时重传的，一旦丢了就再复制一次呗。</p><h1 id="结语">5. 结语</h1><p>这里要说一下在设备组管理遇到的问题，一开始我也是用fcm的设备组管理，导致发送方会接收到自己发送的消息。这个本来无所谓，根据消息的fcm_token判断一下，如果等于自己的fcm_token，就不处理。但是js客户端是用service worker来处理，当service worker重新唤醒时，因为查询indexedDB和调用fcm接口都要在第二轮事件循环才能拿到自己的fcm_token, 而service worker被唤醒后的第一个事件循环就要处理消息了，所以第一次被唤醒时是不知道自己fcm_token的。</p><p>还有一点，fcm js要求你必须对收到的push弹窗，否则他会帮你弹窗，有知道怎么解决的告诉我一下。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fcm真是个好东西，希望你也有。&lt;/p&gt;
    
    </summary>
    
      <category term="Firebase" scheme="https://htchz.cc/categories/Firebase/"/>
    
    
      <category term="数据分片" scheme="https://htchz.cc/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>[Dubbo]Dubbo SPI 机制</title>
    <link href="https://htchz.cc/2436052280.html"/>
    <id>https://htchz.cc/2436052280.html</id>
    <published>2019-03-25T03:44:00.000Z</published>
    <updated>2019-03-25T09:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>之前一篇<a href="./754409717.html">[Java基础]Java的SPI机制</a>讲到Java spi的缺陷是在查找所需实现的时候，会实例化无关的实现，那么这篇看看Dubbo是怎么规避这个问题的。</p><h1 id="Dubbo-spi的特点">2. Dubbo spi的特点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * default extension name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于配置文件是以key-value配置的，这里可以为SPI接口指定一个默认实现的key</p><p><strong>Dubbo spi有以下特点</strong></p><ol><li>不需要遍历所有实例化所有实现类</li><li>增加了对扩展点IoC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。</li></ol><h1 id="Demo">3. Demo</h1><p>接口,需要加上<code>org.apache.dubbo.common.extension.SPI</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRunner</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm a DefaultRunner"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcitedRunner</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm a ExcitedRunner!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在资源目录<code>META-INF/dubbo</code>下创建文件<code>com.htc.learning.api.Runner</code></p><p><img src="/images/pasted-172.png" alt="upload successful"></p><p>内容是一行一行的键值对，value是实现类，我们只要通过key就能直接拿到所需类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>=com.htc.learning.api.impl.DefaultRunner</span><br><span class="line">excited=com.htc.learning.api.impl.ExcitedRunner</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dubboSpiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;Runner&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Runner.class);</span><br><span class="line">    Runner defaultRunner = extensionLoader.getExtension(<span class="string">"default"</span>);</span><br><span class="line">    defaultRunner.run(<span class="string">"htc"</span>);</span><br><span class="line">    Runner excitedRunner = extensionLoader.getExtension(<span class="string">"excited"</span>);</span><br><span class="line">    excitedRunner.run(<span class="string">"htc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><pre><code>2019-03-23 12:20:50.681  INFO   --- [           main] com.htc.learning.api.impl.DefaultRunner  : I&apos;m a DefaultRunner2019-03-23 12:20:50.681  INFO   --- [           main] com.htc.learning.api.impl.ExcitedRunner  : I&apos;m a ExcitedRunner!</code></pre><h1 id="原理">4. 原理</h1><h2 id="getExtensionLoader">4.1. getExtensionLoader</h2><p>Dubbo spi与java spi的<code>ServiceLoader</code>对应的，是<code>ExtensionLoader</code>。不同于<code>ServiceLoader</code>的<code>load</code>方法每次返回都要实例化一个对象，<code>ExtensionLoader</code>每次<code>getExtensionLoader</code>会进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type + <span class="string">") is not interface!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type +</span><br><span class="line">                <span class="string">") is not extension, because WITHOUT @"</span> + SPI.class.getSimpleName() + <span class="string">" Annotation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExtensionLoader</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>objectFactory</code>是一个接口,与IOC相关，该接口根据type和name找到一个bean，这个bean可以是Spring的bean，也可以是一个dubbo spi实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get extension.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这是也是一个SPI接口，接下来调用的<code>getExtensionLoader</code>逻辑就是通过他实现的。</p><h2 id="getExtension">4.2. getExtension</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Holder，顾名思义，用于持有目标对象</span></span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建拓展实例</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                <span class="comment">// 设置实例到 holder 中</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射创建实例</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环创建 Wrapper 实例</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span></span><br><span class="line">                <span class="comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span></span><br><span class="line">                instance = injectExtension(</span><br><span class="line">                    (T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里按逻辑可以拆分成四步</p><ol><li><code>getExtensionClasses()</code>获取接口的所有实现类。这个方法会在很多地方被调用，保证所有类被获取到。由于多次调用缓存也是必须的。</li><li>实例化目标类的对象。</li><li>IOC注入。注入其他SPI实现。</li><li>AOP实现。如果需要，把对象实例包裹在Wrapper中。</li></ol><h3 id="getExtensionClasses">4.2.1. getExtensionClasses</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取已加载的拓展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载拓展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的双重校验，这里的缓存key是实现类的key，值就是实现类了。如果缓存为<code>null</code>，调用<code>loadExtensionClasses</code>初始化缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized in getExtensionClasses</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了默认实现，就缓存以下这个默认实现的key</span></span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"more than 1 default extension name on extension "</span> + type.getName()</span><br><span class="line">                        + <span class="string">": "</span> + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">                cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java spi的配置只能放在一个目录<code>META-INF/services/</code>,dubbo spi的配置可以放在三个目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br></pre></td></tr></table></figure><p>这里的依赖我用的是apache-dubbo，相对于alibaba-dubbo三个目录，估计为了兼容，apache-dubbo版本的<code>loadDirectory</code>方法进行了一个包名的替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fileName = 文件夹路径 + type 全限定名 </span></span><br><span class="line">    String fileName = dir + type.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        <span class="comment">// 根据文件名加载所有的同名文件</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载资源</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来“真·读取配置文件”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, </span></span></span><br><span class="line"><span class="function"><span class="params">ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 定位 # 字符</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 截取 # 之前的字符串，# 之后的内容为注释，需要忽略</span></span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以等于号 = 为界，截取键与值</span></span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载类，并通过 loadClass 方法对类进行缓存</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, </span><br><span class="line">                                      Class.forName(line, <span class="keyword">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Exception when load extension class..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读完配置文件，下面不单是对类进行加载，而且还对<code>Adaptive</code>、<code>Wrapper</code>类进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只能有一个自适应实现类</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line">                com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class="line">                <span class="keyword">if</span> (oldActivate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cachedActivates.put(names[<span class="number">0</span>], oldActivate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                <span class="comment">// 实现类重复报错</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的几点：</p><ol><li><code>@Adaptive</code>注解是标明一个SPI实现类是属于自适应类，一个SPI接口只能有一个自适应实现，这从代码逻辑可以看出来，如果<code>!cachedAdaptiveClass.equals(clazz)</code>则报错。具体这个自适应类可以做什么，下面会说。</li><li><code>Wrapper</code>类是AOP类</li><li>这里还有一个<code>@Active</code>注解，标明实现类的激活条件，是一种条件机制。</li></ol><h3 id="IOC">4.2.2. IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo的IOC目前只对setter方法支持，如果set的方法参数只有一个，那么就拿参数类型<code>pt</code>和setProperty的<code>property</code>去<code>objectFactory</code>找。<code>objectFactory</code>是<code>ExtensionFactory</code>接口，有两个实现，</p><p>上面提到<code>ExtensionLoader</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>getAdaptiveExtension()</code>是什么？</p><h3 id="Adaptive">4.2.3. @Adaptive</h3><p><code>getAdaptiveExtension()</code>的实现如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo的Adaptive机制如下</p><ol><li>如果一个SPI接口实现类存在自适应实现，那么直接拿这个类；</li><li>否则动态创建自适应类(手动拼接代码字符，并转为字节码，加载到jvm中)，由于dubbo是以url为协议的，所以创建的自适应代码是根据url中的内容决定使用那种实现。</li></ol><p>下面是alibaba dubbo 的中文注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从&#123;<span class="doctag">@link</span> URL&#125;的Key名，对应的Value作为要Adapt成的Extension名。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果&#123;<span class="doctag">@link</span> URL&#125;这些Key都没有Value，使用 用 缺省的扩展（在接口的&#123;<span class="doctag">@link</span> SPI&#125;中设定的值）。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 比如，&lt;code&gt;String[] &#123;"key1", "key2"&#125;&lt;/code&gt;，表示</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;先在URL上找key1的Value作为要Adapt成的Extension名；</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;key1没有Value，则使用key2的Value作为要Adapt成的Extension名。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;key2没有Value，使用缺省的扩展。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;如果没有设定缺省扩展，则方法调用会抛出&#123;<span class="doctag">@link</span> IllegalStateException&#125;。</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果不设置则缺省使用Extension接口类名的点分隔小写字串。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 即对于Extension接口&#123;<span class="doctag">@code</span> com.alibaba.dubbo.xxx.YyyInvokerWrapper&#125;的缺省值为&lt;code&gt;String[] &#123;"yyy.invoker.wrapper"&#125;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> SPI#value()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果@Adaptive上的key从url获取不到，就以@SPI上的默认扩展值作为key去url找，如果@SPI都没默认值，就将接口类名用<code>.</code>分隔，作为接口缺省值（这么奇怪的key吗 =。=）</p><p>以下面代码为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>这里会返回一个<code>Protocol$Adaptive</code>类，因为<code>Protocol</code>没有一个自适应实现类，所以dubbo动态生成了一个自适应类，通过debug得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        <span class="comment">// 这里默认使用dubbo</span></span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        <span class="comment">// 这里默认使用dubbo</span></span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>Protocol$Adaptive</code>代码里，如果接口方法没有设置<code>@Adaptive</code>注解，以抛异常处理。</p><p>在生成的方法中，以<code>protocol</code>为key去url里查找这个key的值，如果url里没有设置，就以<code>Protocol</code>接口上的@SPI注解默认值——“dubbo”作为自适应类要找的扩展的name。</p><blockquote><p>创建code代码太长，不贴。</p></blockquote><p>拿<code>ExtensionFactory</code>来说，他有三个实现（有一个废弃的）</p><p><img src="/images/pasted-173.png" alt="upload successful"></p><p>一个自适应实现类，以<code>@Adaptive</code>标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用于获取dubbo Spi实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是用于获取Spring的bean，代码太长不贴</p><h3 id="Active">4.2.4. @Active</h3><p>@Active注解用于实现类上，表示一些激活条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Activate the current extension when one of the groups matches. The group passed into</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; will be used for matching.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> group names to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Activate the current extension when the specified keys appear in the URL's parameters.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * For example, given &lt;code&gt;<span class="doctag">@Activate</span>("cache, validation")&lt;/code&gt;, the current extension will be return only when</span></span><br><span class="line"><span class="comment">     * there's either &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;validation&lt;/code&gt; key appeared in the URL's parameters.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> URL parameter keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br><span class="line"><span class="comment">     * Deprecated since 2.7.0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put before the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br><span class="line"><span class="comment">     * Deprecated since 2.7.0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put after the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Absolute ordering info, optional</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> absolute ordering info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样由于dubbo是面向url的协议，所以这些激活条件需要通过url匹配。</p><p>在加载类的时候，有这么几行代码，以扩展名字为key，以扩展上的注解为值进行map缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.dubbo.common.extension.ExtensionLoader#loadClass</span></span><br><span class="line">Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line"><span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line">    com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class="line">    <span class="keyword">if</span> (oldActivate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedActivates.put(names[<span class="number">0</span>], oldActivate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取激活的的扩展可以通过以下方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getActivateExtension(url, key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is equivalent to &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     getActivateExtension(url, values, null);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url    url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values extension point names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> extension list which are activated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActivateExtension(com.alibaba.dubbo.common.URL, String[], String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getActivateExtension(url, values, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is equivalent to &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     getActivateExtension(url, url.getParameter(key).split(","), null);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url   url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key   url parameter key which used to get extension point names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> extension list which are activated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActivateExtension(com.alibaba.dubbo.common.URL, String[], String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key, String group)</span> </span>&#123;</span><br><span class="line">    String value = url.getParameter(key);</span><br><span class="line">    <span class="keyword">return</span> getActivateExtension(url, value == <span class="keyword">null</span> || value.length() == <span class="number">0</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(value), group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法的具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get activate extensions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url    url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values extension point names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group  group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> extension list which are activated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">    <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            Activate activate = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                <span class="keyword">if</span> (!names.contains(name)</span><br><span class="line">                        &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                        &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">                    exts.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// order 值越小越靠前</span></span><br><span class="line">        Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">        String name = names.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                    usrs.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                usrs.add(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        exts.addAll(usrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">(String[] keys, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keys.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两次for循环</span></span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : url.getParameters().entrySet()) &#123;</span><br><span class="line">            String k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">            <span class="comment">// 如果key存在且对应的value不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((k.equals(key) || k.endsWith(<span class="string">"."</span> + key))</span><br><span class="line">                    &amp;&amp; ConfigUtils.isNotEmpty(v)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配条件的逻辑是，先匹配组，再匹配键，键只要都存在值，那么即匹配成功。当注解上order值越小，这个实现类的排序越靠前。</p><p>关于排序，这里的一个具体例子是Dubbo服务的过滤器往往加上了@Active注解，这时候如果要设置过滤器的处理顺序，就可以通过该注解上的order属性设置。</p><h1 id="结束语">5. 结束语</h1><p>还差Wrapper机制没看。。关于下面那段话我也没看到具体的例子。</p><blockquote><p>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的ScriptEngine，通过getName();获取脚本类型的名称，但如果RubyScriptEngine因为所依赖的jruby.jar不存在，导致RubyScriptEngine类加载失败，这个失败原因被吃掉了，和ruby对应不起来，当用户执行ruby脚本时，会报不支持ruby，而不是真正失败的原因。</p></blockquote><h1 id="参考">6. 参考</h1><ol><li><a href="https://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">Apache Dubbo SPI</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;之前一篇&lt;a href=&quot;./754409717.html&quot;&gt;[Java基础]Java的SPI机制&lt;/a&gt;讲到Java spi的缺陷是在查找所需实现的时候，会实例化无关的实现，那么这篇看看Dubbo是怎么规避这个问题的。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Dubbo" scheme="https://htchz.cc/categories/Dubbo/"/>
    
    
      <category term="OOP" scheme="https://htchz.cc/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>[Java代理]Cglib代理</title>
    <link href="https://htchz.cc/3922793788.html"/>
    <id>https://htchz.cc/3922793788.html</id>
    <published>2019-03-10T06:03:00.000Z</published>
    <updated>2019-08-15T16:08:49.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cglib">1. Cglib</h1><blockquote><p>CGLIB是一个强大的高性能的代码生成包。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p></blockquote><h1 id="Demo">2. Demo</h1><p>直接上Demo～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 目标类</span><br><span class="line"> */</span><br><span class="line">public class RunnerDefault implements Runner &#123;</span><br><span class="line">    private Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String name) &#123;</span><br><span class="line">        log.info(&quot;run: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定Callback的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CglibCallbackFilter implements CallbackFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int accept(Method method) &#123;</span><br><span class="line">        if (&quot;toString&quot;.equals(method.getName())) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理逻辑及生成代理的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 拦截所有方法</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Enhancer enhancer = new Enhancer();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        objects[0] = &quot;cglib &quot; + objects[0];</span><br><span class="line">        return methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newProxy(Class klass) &#123;</span><br><span class="line">        enhancer.setSuperclass(klass);</span><br><span class="line">        enhancer.setCallbackFilter(new CglibCallbackFilter());</span><br><span class="line">        enhancer.setCallbacks(new Callback[]&#123;new CglibProxy(), new CglibStringProxy()&#125;);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了拦截toString方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibStringProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"toString hijacked"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成class文件</span></span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./"</span>);</span><br><span class="line">    CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    RunnerDefault runner = (RunnerDefault) cglibProxy.newProxy(RunnerDefault.class);</span><br><span class="line">    runner.run(<span class="string">"proxy"</span>);</span><br><span class="line">    runner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><pre><code>2019-03-07 16:48:44.248  INFO   --- [           main] RunnerDefault$$EnhancerByCGLIB$$5b557d48 : run: cglib proxy2019-03-07 16:48:44.254  INFO   --- [           main] com.htc.learning.proxy.CglibStringProxy  : toString hijacked</code></pre><blockquote><p>也可以不配置CallbackFilter，只能配一个Callback，Enhancer会把单个的Callback转为数组,并且把CallbackFilter设置为ALL_ZERO，固定返回0</p></blockquote><p>下面是上面test执行过程中生成的文件</p><p><img src="/images/pasted-169.png" alt="upload successful"></p><h1 id="NamingPolicy">3. NamingPolicy</h1><p>上面的<strong>RunnerDefault$$EnhancerByCGLIB$$16487fc</strong>是cglib命名而来的，默认实现类是<code>net.sf.cglib.core.DefaultNamingPolicy</code>命名规则如下：</p><pre><code>目标ClassName + &quot;$$&quot; + 使用cglib处理的ClassName + &quot;ByCGLIB&quot; + &quot;$$&quot; + key的hashcode</code></pre><h1 id="Key和缓存">4. Key和缓存</h1><h2 id="KeyFactory">4.1. KeyFactory</h2><p>先看<code>KeyFactory</code>，这个类可以生成一个代理类，这个代理类对于给定的参数，每次调用返回的对象的<code>equals</code>、<code>hashcode</code>方法都是返回相同的值。由于cglib的配置项比较多，所以使用这个类用于生成缓存key的。</p><blockquote><p>目标类需要提供一个<code>public Object newInstance(...)</code>的声明，参数数量类型随意。</p></blockquote><p>下面是cglib</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>[] b, String d)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 源码没有这一行，加上这一行，cglib的debug模式打开，就可以输出生成代理类的class文件了。</span></span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./"</span>);</span><br><span class="line">        </span><br><span class="line">        MyFactory f = (MyFactory)KeyFactory.create(MyFactory.class);</span><br><span class="line">        Object key1 = f.newInstance(<span class="number">20</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123; <span class="string">'a'</span>, <span class="string">'b'</span> &#125;, <span class="string">"hello"</span>);</span><br><span class="line">        Object key2 = f.newInstance(<span class="number">20</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123; <span class="string">'a'</span>, <span class="string">'b'</span> &#125;, <span class="string">"hello"</span>);</span><br><span class="line">        Object key3 = f.newInstance(<span class="number">20</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123; <span class="string">'a'</span>, <span class="string">'_'</span> &#125;, <span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(key1.equals(key2));<span class="comment">// true</span></span><br><span class="line">        System.out.println(key2.equals(key3));<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-168.png" alt="upload successful"><br>三次生成的是不同对象。<br>key1和key2是相等的，key2和key3是不等的。追踪代码可以看到<code>KeyFactory</code>重写了代理类的<code>equals</code>、<code>hashcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.sf.cglib.core.KeyFactory.Generator#generateClass</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// hash code</span></span><br><span class="line">e = ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">int</span> hc = (constant != <span class="number">0</span>) ? constant : PRIMES[(<span class="keyword">int</span>)(Math.abs(seed) % PRIMES.length)];</span><br><span class="line"><span class="keyword">int</span> hm = (multiplier != <span class="number">0</span>) ? multiplier : PRIMES[(<span class="keyword">int</span>)(Math.abs(seed * <span class="number">13</span>) % PRIMES.length)];</span><br><span class="line">e.push(hc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">    e.load_this();</span><br><span class="line">    e.getfield(getFieldName(i));</span><br><span class="line">    EmitUtils.hash_code(e, parameterTypes[i], hm, customizers);</span><br><span class="line">&#125;</span><br><span class="line">e.return_value();</span><br><span class="line">e.end_method();</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line">e = ce.begin_method(Constants.ACC_PUBLIC, EQUALS, <span class="keyword">null</span>);</span><br><span class="line">Label fail = e.make_label();</span><br><span class="line">e.load_arg(<span class="number">0</span>);</span><br><span class="line">e.instance_of_this();</span><br><span class="line">e.if_jump(e.EQ, fail);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">    e.load_this();</span><br><span class="line">    e.getfield(getFieldName(i));</span><br><span class="line">    e.load_arg(<span class="number">0</span>);</span><br><span class="line">    e.checkcast_this();</span><br><span class="line">    e.getfield(getFieldName(i));</span><br><span class="line">    EmitUtils.not_equals(e, parameterTypes[i], fail, customizers);</span><br><span class="line">&#125;</span><br><span class="line">e.push(<span class="number">1</span>);</span><br><span class="line">e.return_value();</span><br><span class="line">e.mark(fail);</span><br><span class="line">e.push(<span class="number">0</span>);</span><br><span class="line">e.return_value();</span><br><span class="line">e.end_method();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="代理缓存">4.2. 代理缓存</h2><p>所有cglib代理类的缓存都存在于<code>net.sf.cglib.core.AbstractClassGenerator</code>的<code>static</code>变量里，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;ClassLoader, ClassLoaderData&gt; CACHE = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_USE_CACHE =        Boolean.parseBoolean(System.getProperty(<span class="string">"cglib.useCache"</span>, <span class="string">"true"</span>));</span><br></pre></td></tr></table></figure><p>这个缓存是一个<code>WeakHashMap</code>，key和jdk代理一样，也是以<code>ClassLoader为</code>为key，至于<code>ClassLoaderData</code>是一个关于<code>interfaces</code>的封装，到最底层其实是一个<code>ConcurrentHashMap</code>。看<code>net.sf.cglib.core.AbstractClassGenerator#create</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        ClassLoaderData data = cache.get(loader);</span><br><span class="line">        <span class="comment">// 维护多线程</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = cache.get(loader);</span><br><span class="line">                <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    data = <span class="keyword">new</span> ClassLoaderData(loader);</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="comment">// 这里发生了二级缓存的put操作</span></span><br><span class="line">        Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>net.sf.cglib.core.AbstractClassGenerator.ClassLoaderData#get</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不使用缓存直接生成</span></span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 底层是去ConcurrentHashMap拿</span></span><br><span class="line">      Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">      <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说到二级缓存其实是<code>ConcurrentHashMap</code>,那么key，value分别是什么？key是<code>AbstractClassGenerator</code>子类决定的，比如<code>KeyFactory</code>使用的是目标类名；至于value又有jdk代理的味道——value值不是固定的，可能是生成的代理类，也可能是一个<code>FutureTask</code>，多个线程下多个<code>FutureTask</code>调用<code>get()</code>只会有一个在执行，避免了重复生成字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> V <span class="title">createEntry</span><span class="params">(<span class="keyword">final</span> K key, KK cacheKey, Object v)</span> </span>&#123;</span><br><span class="line">    FutureTask&lt;V&gt; task;</span><br><span class="line">    <span class="keyword">boolean</span> creator = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Another thread is already loading an instance</span></span><br><span class="line">        task = (FutureTask&lt;V&gt;) v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task = <span class="keyword">new</span> FutureTask&lt;V&gt;(<span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> loader.apply(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Object prevTask = map.putIfAbsent(cacheKey, task);</span><br><span class="line">        <span class="keyword">if</span> (prevTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// creator does the load</span></span><br><span class="line">            creator = <span class="keyword">true</span>;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevTask <span class="keyword">instanceof</span> FutureTask) &#123;</span><br><span class="line">            task = (FutureTask&lt;V&gt;) prevTask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) prevTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = task.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Interrupted while loading cache item"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ((RuntimeException) cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load cache item"</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (creator) &#123;</span><br><span class="line">        map.put(cacheKey, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Enhancer">5. Enhancer</h1><p><code>Enhancer</code>是CGLib中的一个字节码增强器，一般我们都用这个来进行生成cglib代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class[] interfaces;</span><br><span class="line"><span class="keyword">private</span> CallbackFilter filter;</span><br><span class="line"><span class="keyword">private</span> Callback[] callbacks;</span><br><span class="line"><span class="comment">// 回调逻辑的类型，包括 MethodInterceptor|NoOp|LazyLoader|Dispatcher|InvocationHandler|FixedValue</span></span><br><span class="line"><span class="keyword">private</span> Type[] callbackTypes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validateCallbackTypes;</span><br><span class="line"><span class="comment">// create()是否只生成代理类,而不是返回一个对象,如果只生成代理类，callback不能设置，会报错</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> classOnly;</span><br><span class="line"><span class="keyword">private</span> Class superclass;</span><br><span class="line"><span class="keyword">private</span> Class[] argumentTypes;</span><br><span class="line"><span class="keyword">private</span> Object[] arguments;</span><br><span class="line"><span class="comment">// 是否使用工厂类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useFactory = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> Long serialVersionUID;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> interceptDuringConstruction = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>下面是创建逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里进行一些配置校验，比如设置了多个Callback但是没有设置filter</span></span><br><span class="line">    preValidate();</span><br><span class="line">    <span class="comment">// 这里KEY_FACTORY是KeyFactory实例</span></span><br><span class="line">    Object key = KEY_FACTORY.newInstance((superclass != <span class="keyword">null</span>) ? superclass.getName() : <span class="keyword">null</span>,</span><br><span class="line">            ReflectUtils.getNames(interfaces),</span><br><span class="line">            filter == ALL_ZERO ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),</span><br><span class="line">            callbackTypes,</span><br><span class="line">            useFactory,</span><br><span class="line">            interceptDuringConstruction,</span><br><span class="line">            serialVersionUID);</span><br><span class="line">    <span class="keyword">this</span>.currentKey = key;</span><br><span class="line">    Object result = <span class="keyword">super</span>.create(key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object result = super.create(key);</code>又是跳到上面提到过的<code>net.sf.cglib.core.AbstractClassGenerator#create</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        ClassLoaderData data = cache.get(loader);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = cache.get(loader);</span><br><span class="line">                <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    data = <span class="keyword">new</span> ClassLoaderData(loader);</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上一小节提到，这里面是有缓存的。</p><h2 id="代理主流程">5.1. 代理主流程</h2><p><code>net.sf.cglib.proxy.Enhancer#generateClass</code>方法负责生成代理，主要是通过<code>CallbackFilter</code>为不同的<code>Method</code>提供不同的<code>Callback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateClass</span><span class="params">(ClassVisitor v)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class sc = (superclass == <span class="keyword">null</span>) ? Object.class : superclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot subclass final class "</span> + sc.getName());</span><br><span class="line">    List constructors = <span class="keyword">new</span> ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">    filterConstructors(sc, constructors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Order is very important: must add superclass, then</span></span><br><span class="line">    <span class="comment">// its superclass chain, then each interface and</span></span><br><span class="line">    <span class="comment">// its superinterfaces.</span></span><br><span class="line">    List actualMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List interfaceMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">final</span> Set forcePublic = <span class="keyword">new</span> HashSet();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看下面代码</span></span><br><span class="line">    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">    <span class="comment">// 这里把actualMethods中，非abstract,非native,非synchronized方法的修饰符全部变成final，将转化后的方法信息MethodInfo列表 记录在methods中</span></span><br><span class="line">    List methods = CollectionUtils.transform(actualMethods, <span class="keyword">new</span> Transformer() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            Method method = (Method)value;</span><br><span class="line">            <span class="keyword">int</span> modifiers = Constants.ACC_FINAL</span><br><span class="line">                | (method.getModifiers()</span><br><span class="line">                   &amp; ~Constants.ACC_ABSTRACT</span><br><span class="line">                   &amp; ~Constants.ACC_NATIVE</span><br><span class="line">                   &amp; ~Constants.ACC_SYNCHRONIZED);</span><br><span class="line">            <span class="keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ClassEmitter e = <span class="keyword">new</span> ClassEmitter(v);</span><br><span class="line">    <span class="comment">// 这个currentData不知道是干嘛的</span></span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.begin_class(Constants.V1_2,</span><br><span class="line">                  Constants.ACC_PUBLIC,</span><br><span class="line">                  getClassName(),</span><br><span class="line">                  Type.getType(sc),</span><br><span class="line">                  (useFactory ?</span><br><span class="line">                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :</span><br><span class="line">                   TypeUtils.getTypes(interfaces)),</span><br><span class="line">                  Constants.SOURCE_FILE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.begin_class(Constants.V1_2,</span><br><span class="line">                Constants.ACC_PUBLIC,</span><br><span class="line">                getClassName(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> Type[]&#123;FACTORY&#125;,</span><br><span class="line">                Constants.SOURCE_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line"></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!interceptDuringConstruction) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (serialVersionUID != <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据callbackTypes增加属性，名字为CGLIB$CALLBACK_xx(xx是序号)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbackTypes.length; i++) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is declared private to avoid "public field" pollution</span></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为目标方法配置Callback</span></span><br><span class="line">        emitMethods(e, methods, actualMethods);</span><br><span class="line">        emitConstructors(e, constructorInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        emitDefaultConstructor(e);</span><br><span class="line">    &#125;</span><br><span class="line">    emitSetThreadCallbacks(e);</span><br><span class="line">    emitSetStaticCallbacks(e);</span><br><span class="line">    emitBindCallbacks(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useFactory || currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] keys = getCallbackKeys();</span><br><span class="line">        emitNewInstanceCallbacks(e);</span><br><span class="line">        emitNewInstanceCallback(e);</span><br><span class="line">        emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">        emitGetCallback(e, keys);</span><br><span class="line">        emitSetCallback(e, keys);</span><br><span class="line">        emitGetCallbacks(e);</span><br><span class="line">        emitSetCallbacks(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.end_class();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取要代理的方法">5.2. 获取要代理的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一坨是把目标类的方法，接口方法的信息（类型是 MethodInfo）都加入到methods列表里</span></span><br><span class="line">    ReflectUtils.addAllMethods(superclass, methods);</span><br><span class="line">    List target = (interfaceMethods != <span class="keyword">null</span>) ? interfaceMethods : methods;</span><br><span class="line">    <span class="keyword">if</span> (interfaces != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interfaces[i] != Factory.class) &#123;</span><br><span class="line">                ReflectUtils.addAllMethods(interfaces[i], target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interfaceMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forcePublic != <span class="keyword">null</span>) &#123;</span><br><span class="line">            forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));</span><br><span class="line">        &#125;</span><br><span class="line">        methods.addAll(interfaceMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤static方法</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> RejectModifierPredicate(Constants.ACC_STATIC));</span><br><span class="line">    <span class="comment">// 根据布尔值决定是否过滤protected的方法，过滤private方法</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> VisibilityPredicate(superclass, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 过滤重复</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> DuplicatesPredicate(methods));</span><br><span class="line">    <span class="comment">// 过滤final方法</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> RejectModifierPredicate(Constants.ACC_FINAL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对demo的<code>RunnerDefault</code>，获取到的最终方法为</p><p><img src="/images/pasted-170.png" alt="upload successful"></p><h2 id="为目标方法配置Callback">5.3. 为目标方法配置Callback</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods的类型是MethodInfo，主要是改了原方法的modifiers</span></span><br><span class="line"><span class="comment">// actualMethods的类型Method</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitMethods</span><span class="params">(<span class="keyword">final</span> ClassEmitter ce, List methods, List actualMethods)</span> </span>&#123;</span><br><span class="line">    CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);</span><br><span class="line"></span><br><span class="line">    Map groups = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> Map indexes = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> Map originalModifiers = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> Map positions = CollectionUtils.getIndexMap(methods);</span><br><span class="line">    <span class="keyword">final</span> Map declToBridge = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    Iterator it1 = methods.iterator();</span><br><span class="line">    Iterator it2 = (actualMethods != <span class="keyword">null</span>) ? actualMethods.iterator() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it1.hasNext()) &#123;</span><br><span class="line">        MethodInfo method = (MethodInfo)it1.next();</span><br><span class="line">        Method actualMethod = (it2 != <span class="keyword">null</span>) ? (Method)it2.next() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取 index</span></span><br><span class="line">        <span class="keyword">int</span> index = filter.accept(actualMethod);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= callbackTypes.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callback filter returned an index that is too large: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        originalModifiers.put(method, <span class="keyword">new</span> Integer((actualMethod != <span class="keyword">null</span>) ? actualMethod.getModifiers() : method.getModifiers()));</span><br><span class="line">        <span class="comment">// 把index放入map</span></span><br><span class="line">        indexes.put(method, <span class="keyword">new</span> Integer(index));</span><br><span class="line">        List group = (List)groups.get(generators[index]);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            groups.put(generators[index], group = <span class="keyword">new</span> ArrayList(methods.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        group.add(method);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Optimization: build up a map of Class -&gt; bridge methods in class</span></span><br><span class="line">        <span class="comment">// so that we can look up all the bridge methods in one pass for a class.</span></span><br><span class="line">        <span class="keyword">if</span> (TypeUtils.isBridge(actualMethod.getModifiers())) &#123;</span><br><span class="line">        Set bridges = (Set)declToBridge.get(actualMethod.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (bridges == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bridges = <span class="keyword">new</span> HashSet();</span><br><span class="line">            declToBridge.put(actualMethod.getDeclaringClass(), bridges);</span><br><span class="line">        &#125;</span><br><span class="line">        bridges.add(method.getSignature());            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Map bridgeToTarget = <span class="keyword">new</span> BridgeMethodResolver(declToBridge, getClassLoader()).resolveAll();</span><br><span class="line"></span><br><span class="line">    Set seenGen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    CodeEmitter se = ce.getStaticHook();</span><br><span class="line">    se.new_instance(THREAD_LOCAL);</span><br><span class="line">    se.dup();</span><br><span class="line">    se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);</span><br><span class="line">    se.putfield(THREAD_CALLBACKS_FIELD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] state = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    CallbackGenerator.Context context = <span class="keyword">new</span> CallbackGenerator.Context() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Enhancer.<span class="keyword">this</span>.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOriginalModifiers</span><span class="params">(MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)originalModifiers.get(method)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)indexes.get(method)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据index获取对应的Callback（从DeclaredField获取）</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitCallback</span><span class="params">(CodeEmitter e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            emitCurrentCallback(e, index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Signature <span class="title">getImplSignature</span><span class="params">(MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rename(method.getSignature(), ((Integer)positions.get(method)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitLoadArgsAndInvoke</span><span class="params">(CodeEmitter e, MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// If this is a bridge and we know the target was called from invokespecial,</span></span><br><span class="line">            <span class="comment">// then we need to invoke_virtual w/ the bridge target instead of doing</span></span><br><span class="line">            <span class="comment">// a super, because super may itself be using super, which would bypass</span></span><br><span class="line">            <span class="comment">// any proxies on the target.</span></span><br><span class="line">            Signature bridgeTarget = (Signature)bridgeToTarget.get(method.getSignature());</span><br><span class="line">            <span class="keyword">if</span> (bridgeTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// checkcast each argument against the target's argument types</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bridgeTarget.getArgumentTypes().length; i++) &#123;</span><br><span class="line">                    e.load_arg(i);</span><br><span class="line">                    Type target = bridgeTarget.getArgumentTypes()[i];</span><br><span class="line">                    <span class="keyword">if</span> (!target.equals(method.getSignature().getArgumentTypes()[i])) &#123;</span><br><span class="line">                        e.checkcast(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                e.invoke_virtual_this(bridgeTarget);</span><br><span class="line">                </span><br><span class="line">                Type retType = method.getSignature().getReturnType();                    </span><br><span class="line">                <span class="comment">// Not necessary to cast if the target &amp; bridge have</span></span><br><span class="line">                <span class="comment">// the same return type. </span></span><br><span class="line">                <span class="comment">// (This conveniently includes void and primitive types,</span></span><br><span class="line">                <span class="comment">// which would fail if casted.  It's not possible to </span></span><br><span class="line">                <span class="comment">// covariant from boxed to unbox (or vice versa), so no having</span></span><br><span class="line">                <span class="comment">// to box/unbox for bridges).</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> It also isn't necessary to checkcast if the return is</span></span><br><span class="line">                <span class="comment">// assignable from the target.  (This would happen if a subclass</span></span><br><span class="line">                <span class="comment">// used covariant returns to narrow the return type within a bridge</span></span><br><span class="line">                <span class="comment">// method.)</span></span><br><span class="line">                <span class="keyword">if</span> (!retType.equals(bridgeTarget.getReturnType())) &#123;</span><br><span class="line">                    e.checkcast(retType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e.load_args();</span><br><span class="line">                e.super_invoke(method.getSignature());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> CodeEmitter <span class="title">beginMethod</span><span class="params">(ClassEmitter ce, MethodInfo method)</span> </span>&#123;</span><br><span class="line">            CodeEmitter e = EmitUtils.begin_method(ce, method);</span><br><span class="line">            <span class="keyword">if</span> (!interceptDuringConstruction &amp;&amp;</span><br><span class="line">                !TypeUtils.isAbstract(method.getModifiers())) &#123;</span><br><span class="line">                Label constructed = e.make_label();</span><br><span class="line">                e.load_this();</span><br><span class="line">                e.getfield(CONSTRUCTED_FIELD);</span><br><span class="line">                e.if_jump(e.NE, constructed);</span><br><span class="line">                e.load_this();</span><br><span class="line">                e.load_args();</span><br><span class="line">                e.super_invoke();</span><br><span class="line">                e.return_value();</span><br><span class="line">                e.mark(constructed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbackTypes.length; i++) &#123;</span><br><span class="line">        CallbackGenerator gen = generators[i];</span><br><span class="line">        <span class="keyword">if</span> (!seenGen.contains(gen)) &#123;</span><br><span class="line">            seenGen.add(gen);</span><br><span class="line">            <span class="keyword">final</span> List fmethods = (List)groups.get(gen);</span><br><span class="line">            <span class="keyword">if</span> (fmethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    gen.generate(ce, context, fmethods);</span><br><span class="line">                    gen.generateStatic(se, context, fmethods);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    se.return_value();</span><br><span class="line">    se.end_method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码没有看的很细，了解了大概。</p><blockquote><p>一个方法只会有一个<code>Callback</code>。</p></blockquote><p>这一节，最后看一下代理出来的类的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$run$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$run$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CGLIB$run$0$Method </span></span><br><span class="line">Method CGLIB$run$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"run"</span>, <span class="string">"(Ljava/lang/String;)V"</span>&#125;, (var1 = Class.forName(<span class="string">"com.htc.learning.api.impl.RunnerDefault"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// CGLIB$run$0$Proxy</span></span><br><span class="line">MethodProxy CGLIB$run$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"run"</span>, <span class="string">"CGLIB$run$0"</span>);</span><br></pre></td></tr></table></figure><p>所以逻辑是这样的，代理类将调用转发给一个<code>Callback</code>，在<code>Callback</code>里，如果要执行目标类的目标方法，即调用<code>net.sf.cglib.proxy.MethodProxy#invokeSuper</code></p><p>等等，<code>MethodProxy</code>是什么</p><p>此外从生成的类里，我们可以看除了Enhancer和KeyFactory的增强类之外，还生成了三个类</p><p><img src="/images/pasted-171.png" alt="upload successful"><br>第二个是我们的代理类，那么其余两个是干嘛的，<code>FastClass</code>又是什么?</p><h1 id="MethodProxy与Fastclass">6. MethodProxy与Fastclass</h1><h2 id="为什么要有MethodProxy、Fastclass">6.1. 为什么要有MethodProxy、Fastclass</h2><p>我们配置代理的时候，并没有传入一个目标类实例，而是传入目标类的class，这时我们要去调用目标方法的时候，如果每次都靠反射，那就没有直接调用一个对象来的快。</p><blockquote><p>没错每次都靠反射说的就是你jdk代理。</p></blockquote><h2 id="MethodProxy">6.2. MethodProxy</h2><p><code>MethodProxy</code>表明了一个方法到另一个方法的映射，我们看一下代理类run方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// CGLIB$run$0$Proxy 即是 MethodProxy</span></span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$run$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$run$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class var0 = Class.forName(<span class="string">"com.htc.learning.api.impl.RunnerDefault$$EnhancerByCGLIB$$5b557d48"</span>);  </span><br><span class="line">Class var1 = Class.forName(<span class="string">"com.htc.learning.api.impl.RunnerDefault"</span>)</span><br><span class="line">CGLIB$run$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"run"</span>, <span class="string">"CGLIB$run$0"</span>);</span><br></pre></td></tr></table></figure><p>再其中，<code>&quot;CGLIB$run$0&quot;</code>是Enhancer代理类里的一个已经生成的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> CGLIB$run$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="keyword">super</span>.run(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MethodProxy</code>的<code>create</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> </span>&#123;</span><br><span class="line">    MethodProxy proxy = <span class="keyword">new</span> MethodProxy();</span><br><span class="line">    proxy.sig1 = <span class="keyword">new</span> Signature(name1, desc);</span><br><span class="line">    proxy.sig2 = <span class="keyword">new</span> Signature(name2, desc);</span><br><span class="line">    proxy.createInfo = <span class="keyword">new</span> MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段就是说<code>c1</code>的方法<code>name1</code>,对应的代理方法是实现类<code>c2</code>的方法<code>name2</code>。再具体一点，<code>RunnerDefault</code>的<code>run</code>方法，对应的就是<code>com.htc.learning.api.impl.RunnerDefault$$EnhancerByCGLIB$$5b557d48</code>的<code>CGLIB$run$0</code>方法，这两个签名没有依赖，MethodProxy利用这两个签名，提供两种不同的目标方法调用，</p><h2 id="FastClass">6.3. FastClass</h2><p>上面只是创建了一个关联关系，接下来看<code>net.sf.cglib.proxy.MethodProxy#invokeSuper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">        <span class="comment">// f2是Enhancer代理类，i2是配置好的可以调用到目标方法的索引，invoke根据索引，使用switch块直接调用方法，而不是利用反射</span></span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例模式，防止重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.initLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                MethodProxy.CreateInfo ci = <span class="keyword">this</span>.createInfo;</span><br><span class="line">                MethodProxy.FastClassInfo fci = <span class="keyword">new</span> MethodProxy.FastClassInfo();</span><br><span class="line">                fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                fci.i1 = fci.f1.getIndex(<span class="keyword">this</span>.sig1);</span><br><span class="line">                fci.i2 = fci.f2.getIndex(<span class="keyword">this</span>.sig2);</span><br><span class="line">                <span class="keyword">this</span>.fastClassInfo = fci;</span><br><span class="line">                <span class="keyword">this</span>.createInfo = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FastClass <span class="title">helper</span><span class="params">(MethodProxy.CreateInfo ci, Class type)</span> </span>&#123;</span><br><span class="line">    Generator g = <span class="keyword">new</span> Generator();</span><br><span class="line">    g.setType(type);</span><br><span class="line">    g.setClassLoader(ci.c2.getClassLoader());</span><br><span class="line">    g.setNamingPolicy(ci.namingPolicy);</span><br><span class="line">    g.setStrategy(ci.strategy);</span><br><span class="line">    g.setAttemptLoad(ci.attemptLoad);</span><br><span class="line">    <span class="comment">// 进去代码后可以看到使用了缓存，所以不会重复生成FastClass</span></span><br><span class="line">    <span class="keyword">return</span> g.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span> </span>&#123;</span><br><span class="line">    FastClass f1;</span><br><span class="line">    FastClass f2;</span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line">    <span class="keyword">int</span> i2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FastClassInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数命令实在有点难懂，梳理一下，针对<code>run</code>方法，</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>c1</td><td><code>RunnerDefault</code></td></tr><tr><td>f1</td><td><code>RunnerDefault$$FastClassByCGLIB$$a60a67a3</code></td></tr><tr><td>i1</td><td>目标类<code>run</code>的索引</td></tr><tr><td>c2</td><td><code>RunnerDefault$$EnhancerByCGLIB$$5b557d48</code> (<code>Enhancer</code>代理类)</td></tr><tr><td>f2</td><td><code>RunnerDefault$$EnhancerByCGLIB$$5b557d48$$FastClassByCGLIB$$9f176e41</code>（<code>Enhancer</code>代理类的一个快速查找类）</td></tr><tr><td>i2</td><td><code>Enhancer</code>代理类调用<code>run</code>的索引</td></tr></tbody></table><p>下面是<code>RunnerDefault$$FastClassByCGLIB$$a60a67a3</code>的部分代码(如果是<code>RunnerDefault$$EnhancerByCGLIB$$5b557d48$$FastClassByCGLIB$$9f176e41</code>switch块会更大，因为<code>RunnerDefault$$EnhancerByCGLIB$$5b557d48</code>的方法更多)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Signature var1)</span> </span>&#123;</span><br><span class="line">    String var10000 = var1.toString();</span><br><span class="line">    <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1717138348</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"run(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这的var2是Enhancer代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    RunnerDefault var10000 = (RunnerDefault)var2;</span><br><span class="line">    <span class="keyword">int</span> var10001 = var1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(var10001) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.run((String)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Boolean(var10000.equals(var3[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.toString();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(var10000.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot find matching method/constructor"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StackOverflowError">6.4. StackOverflowError</h2><p>如果我们写Callback的时候，把<code>invokeSuper</code>写成<code>invoke</code>会怎么样，答案是：<strong>栈溢出</strong>。<br><code>MethodProxy</code>的<code>invoke</code>方法是这样的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f1.invoke(fci.i1, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>obj</code>是Enhancer代理类，而<code>f1</code>是<code>RunnerDefault$$FastClassByCGLIB$$a60a67a3</code>，所以又会索引到<code>Enhancer代理类</code>的代理<code>run</code>方法，接着又执行上面的<code>invoke</code>,balabala…陷入死循环。</p><h2 id="invoke与invokeSuper">6.5. invoke与invokeSuper</h2><p>那是不是<code>invoke</code>不能被调用了？不是，上面说到<strong>MethodProxy利用这两个签名，提供两种不同的目标方法调用，</strong>所以，<code>invoke</code>是另一种调用目标方法的姿势。</p><p>写<code>Callback</code>的时候，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        objects[<span class="number">0</span>] = <span class="string">"cglib "</span> + objects[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>传入的<code>Object o</code>是<code>Enhancer</code>代理类，而我们不能执行<code>methodProxy.invoke(o, objects)</code>陷入死循环，所以我们在<code>Callback</code>需要保存一个目标类实例的引用<code>target</code>，然后<code>methodProxy.invoke(target, objects)</code>。</p><h2 id="总结">6.6. 总结</h2><p><code>MethodProxy</code>与<code>Fastclass</code>提供了一个  <strong>Signature -&gt; index -&gt; invoke</strong>的机制。</p><h1 id="缺陷">7. 缺陷</h1><p>如果理解了<code>FastClass</code>，那么很容猜测<code>cglib</code>的性能瓶颈在于，当目标类的方法很多的时候，<code>switch</code>块就是一个很慢的查找，这个查找是有优化空间的。此外，<code>cglib</code>代理的创建时间会比<code>jdk</code>代理的创建更耗时间，不过我觉得这都不是事。</p><h1 id="参考">8. 参考</h1><ol><li><a href="https://www.jianshu.com/p/20203286ccd9" target="_blank" rel="noopener">cglib demo以及Enhancer源码解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cglib&quot;&gt;1. Cglib&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CGLIB是一个强大的高性能的代码生成包。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell
      
    
    </summary>
    
      <category term="Proxy" scheme="https://htchz.cc/categories/Proxy/"/>
    
    
      <category term="AOP" scheme="https://htchz.cc/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>[Java代理]Jdk代理</title>
    <link href="https://htchz.cc/68869360.html"/>
    <id>https://htchz.cc/68869360.html</id>
    <published>2019-03-04T16:16:00.000Z</published>
    <updated>2019-08-15T16:08:49.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>相比静态代理需要手动写代理类，动态代理可以通过抽象代码完成对一定规则的类的代理，生成的代理类直接以字节码的形式存在于内存中。Spring里Aop的实现使用了两种动态代理方案，一种是jdk代理，一种是<code>cglib</code>代理。</p><p>jdk代理是从目标类的接口生成实现类，cglib是继承目标类生成子类。</p><h1 id="Demo">2. Demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口实现类</span></span><br><span class="line"><span class="comment"> * created by Huang.Zhen on 2019-02-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerDefault</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"run: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> * created by Huang Zhen on 2019-02-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存目标类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxyHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对newProxyInstance方法的封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">"jdk "</span> + args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用下面的代码获取代理类并运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runner runner = (Runner) <span class="keyword">new</span> JdkProxyHandler(<span class="keyword">new</span> RunnerDefault()).getProxy();</span><br><span class="line">    runner.run(<span class="string">"proxy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 </p><pre><code>2019-03-01 16:02:17.623  INFO   --- [           main] com.htc.learning.api.impl.RunnerDefault  : run: jdk proxy</code></pre><h1 id="原理">3. 原理</h1><h2 id="怎么生成代理类class文件">3.1. 怎么生成代理类class文件</h2><p>直捣<code>Proxy.newProxyInstance</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br></pre></td></tr></table></figure><p>进入<code>getProxyClass0</code>，从<code>proxyClassCache</code>字面上理解，jdk代理是有缓存的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line"><span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line"><span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line"><span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br></pre></td></tr></table></figure><p>进入get方法。可以看到出现了jdk8级别的代码，说明jdk8里jdk代理又被优化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line"><span class="comment">// subKey from valuesMap</span></span><br><span class="line"><span class="comment">// subKeyFactory 其实是 java.lang.reflect.Proxy.ProxyClassFactory</span></span><br><span class="line">Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">...</span><br><span class="line">V value = supplier.get();</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>进入<code>java.lang.reflect.Proxy.ProxyClassFactory#apply</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">    proxyName, interfaces, accessFlags);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">    ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">    <span class="comment">// 生成字节码的方法，不想看</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">    <span class="comment">// 这里可以通过命令行参数设置要不要存储生成的class文件</span></span><br><span class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                        Files.createDirectories(var3);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以往都是说jdk代理比cglib性能差，其实优化到现在都没差多少了，更多的时候是从两者的特性按需求采取不同的。</p></blockquote><h2 id="缓存">3.2. 缓存</h2><p>jdk代理获取Class的时候使用了缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxyClassCache</code>的声明是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a cache of proxy classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>主要的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;K&gt; refQueue</span><br><span class="line">    = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="comment">// 缓存本存</span></span><br><span class="line"><span class="comment">// the key type is Object for supporting null key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">    = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 反向索引，用来快速判断一个对象是否存在缓存里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap</span><br><span class="line">    = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 两个二元运算方法</span></span><br><span class="line"><span class="comment">// subKeyFactory = new KeyFactory()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line"><span class="comment">// valueFactory = new ProxyClassFactory()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br></pre></td></tr></table></figure><p>这里里的缓存<code>map</code>的value又是一个<code>ConcurrentMap</code>,说明这个缓存是一个二级缓存。</p><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>一级缓存key</td><td>一个CacheKey类型的对象，以ClassLoader作为hash</td></tr><tr><td>一级缓存value</td><td>一级缓存</td></tr></tbody></table><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>二级缓存key</td><td>以interfaces为key</td></tr><tr><td>二级缓存value</td><td>Supplier接口，可能是CacheValue 或者 代理工厂对象</td></tr></tbody></table><p>看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Proxy类的代码中，key是ClassLoader，parameter是interface数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    <span class="comment">// 初始化二级缓存，用了双重校验，保证所有线程拿到的是同一个实例</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">    <span class="comment">// subKey from valuesMap</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lazily construct a Factory</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的代码主要是维护<code>Map.put</code>操作多线程下的一些同步，防止重复实例化。虽然<code>map</code>是<code>ConcurrentHashMap</code>,但重复put还是得避免的。</li><li>二级缓存<code>Map</code>的<code>value</code>为<code>Supplier</code>类型，第一次访问是 <code>Factory</code>对象，第二次访问就可能是<code>CacheValue</code>，因为<code>Factory</code>存有二级缓存map的引用，会把<code>value</code>从<code>this</code>（<code>Factory</code>本身）替换为<code>CacheValue</code></li></ul><blockquote><p>其实不太明白这种机制,可能为了提高并发性能？先返回值，再为值构造缓存。</p></blockquote><h2 id="缓存过期机制">3.3. 缓存过期机制</h2><p><code>CacheKey</code>是一个<code>WeakReference</code>，当gc时就会被清理掉引用的对象，这时需要把<code>CacheKey</code>从<code>Map</code>里<code>remove</code>，下面这个方法在<code>WeakCache</code>执行读操作的时候会执行一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheKey&lt;K&gt; cacheKey;</span><br><span class="line">    <span class="keyword">while</span> ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cacheKey.expungeFrom(map, reverseMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>CacheValue</code>也是虚引用。</p></blockquote><h2 id="InvocationHandler注入">3.4. InvocationHandler注入</h2><p>代理类已经生成了，我们写的<code>InvocationHandler</code>还没有注入，所以生成代理类的时候是不包含代理逻辑的。</p><p>我们回到<code>Proxy.newProxyInstance</code>方法，这时已经获取到<code>class</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"><span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure><p><code>InvocationHandler</code>是通过构造参数注入的。</p><h2 id="代理class文件的内容">3.5. 代理class文件的内容</h2><p>我们生成基本的class文件只需要给一个自定义类名和一个目标类就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveJdkProxyClass</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       String path = <span class="string">"./$Proxy0.class"</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy0"</span>, RunnerDefault.class.getInterfaces());</span><br><span class="line">       FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">           out.write(classFile);</span><br><span class="line">           out.flush();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">               out.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.htc.learning.api.Runner;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.htc.learning.api.Runner"</span>).getMethod(<span class="string">"run"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么cglib方案的代理类class文件又要怎么获取呢，下篇再说。</p></blockquote><p>可以看到字节码里每个目标方法都有一个同名的代理方法包着，代理逻辑已经写在<code>InvocationHandler</code>，代理方法直接调用<code>InvocationHandler</code>就可以了。</p><h1 id="从代理类获取原始对象的Class">4. 从代理类获取原始对象的Class</h1><p>在Spring里，bean被代理是很常见的，假如我们要获取目标bean上的注解，这时候我们拿到的如果是代理类，是获取不到的目标bean上的注解的。所以这时我们得从代理类获取原始对象，再获得对应的Class。</p><h2 id="我的做法">4.1. 我的做法</h2><p>在<code>InvocationHandler</code>实现类里，把目标类对象放入了一个<code>target</code>成员变量，然后当我们拿到代理类后，通过调用<code>java.lang.reflect.Proxy#getInvocationHandler</code>方法，再通过反射即可获取到原始对象<code>target</code>。</p><h2 id="Spring的做法">4.2. Spring的做法</h2><p>Spring有一个AopProxyUtils的工具，其中有个方法可以获取到jdk代理或cglib代理的原始对象。关于这个工具更多使用参考<a href="https://www.jianshu.com/p/273d8e2bb992" target="_blank" rel="noopener">AopProxyUtils详解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// candidate即传入的代理类实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; ultimateTargetClass(Object candidate) &#123;</span><br><span class="line">Assert.notNull(candidate, <span class="string">"Candidate object must not be null"</span>);</span><br><span class="line">Object current = candidate;</span><br><span class="line">Class&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// Spring的代理类都实现了 TargetClassAware，调用getTargetClass()可获取到目标对象，注意，这里不一定是原始对象，因为可能切面切了很多次，生成了很多层的代理类，这也是为什么需要一个while循环</span></span><br><span class="line"><span class="keyword">while</span> (current <span class="keyword">instanceof</span> TargetClassAware) &#123;</span><br><span class="line">result = ((TargetClassAware) current).getTargetClass();</span><br><span class="line">current = getSingletonTarget(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果是cglib代理，则获取对象父类，否则是jdk代理，直接获取对象类型</span></span><br><span class="line">result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSingletonTarget</span><span class="params">(Object candidate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">TargetSource targetSource = ((Advised) candidate).getTargetSource();</span><br><span class="line"><span class="keyword">if</span> (targetSource <span class="keyword">instanceof</span> SingletonTargetSource) &#123;</span><br><span class="line"><span class="keyword">return</span> ((SingletonTargetSource) targetSource).getTarget();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑看起来不难，但是涉及了Spring Aop的接口概念，所以具体调用我也不太懂是干嘛的。</p><blockquote><p>Spring在代理逻辑中拦截了<code>getTargetClass()</code>等切面方法，将这些方法转发给<code>Advised</code>去执行。</p></blockquote><h1 id="缺陷">5. 缺陷</h1><p>从class文件看，由于代理类继承了<code>Proxy</code>类（其实这个类看起来也只有一个<code>java.lang.reflect.Proxy#getInvocationHandler</code>比较通用的方法，其实我觉得这个<code>InvocationHandler</code>可以通过反射拿到，不懂为什么非要继承这个类，喵？），导致jdk代理不能通过继承目标类来达到代理的目的。</p><h1 id="关于Spring">6. 关于Spring</h1><p>Spring有个属性是<code>proxy-target-class</code>，默认值是<code>false</code>，表示默认使用jdk代理，这时使用常常会发生类型转换的错误，因为最终bean的class已经不是最初的bean的类型。<br>在Springboot里，<code>proxy-target-class</code>使用<code>spring.aop.proxy-target-class</code>属性来配置，默认为<code>true</code>，即都使用<code>cglib</code>来代理。如果配置为<code>false</code>，Springboot会对实现接口的bean使用jdk代理，对于没有实现接口的类依旧使用<code>cglib</code>代理。</p><h1 id="参考">7. 参考</h1><ol><li><a href="https://www.jianshu.com/p/273d8e2bb992" target="_blank" rel="noopener">AopProxyUtils详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;相比静态代理需要手动写代理类，动态代理可以通过抽象代码完成对一定规则的类的代理，生成的代理类直接以字节码的形式存在于内存中。Spring里Aop的实现使用了两种动态代理方案，一种是jdk代理，一种是&lt;code&gt;cglib&lt;/cod
      
    
    </summary>
    
      <category term="Proxy" scheme="https://htchz.cc/categories/Proxy/"/>
    
    
      <category term="AOP" scheme="https://htchz.cc/tags/AOP/"/>
    
  </entry>
  
</feed>
