<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>土川的自留地</title>
  
  <subtitle>via fennecs.huang@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://htchz.cc/"/>
  <updated>2020-10-23T02:20:03.979Z</updated>
  <id>https://htchz.cc/</id>
  
  <author>
    <name>土川</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[LeetCode]扁平化嵌套列表迭代器</title>
    <link href="https://htchz.cc/3913545735.html"/>
    <id>https://htchz.cc/3913545735.html</id>
    <published>2020-10-23T01:58:58.000Z</published>
    <updated>2020-10-23T02:20:03.979Z</updated>
    
    <content type="html"><![CDATA[<p>刷leetcode的时候看到这么道题，<br><img src="../images/20201023095530.png" alt><br>这个<code>NestedInteger</code>很明显组成了一颗只有叶子节点才有数据的树。于是一个DFS把所有元素抽成一个List，再生成一个迭代器在实现要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; iterator;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        iterate(nestedList);</span><br><span class="line">        iterator = list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger n : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n.isInteger())&#123;</span><br><span class="line">                list.add(n.getInteger());</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                iterate(n.getList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果数据很大，我们又只要迭代一小部分满足条件的元素之后，就中止迭代，那么这种<code>预加载</code>的模式就会浪费时间在构造上，所以应该有一个懒加载模式。</p><p>用一个栈来存储迭代器，栈顶就是当前的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Iterator&lt;NestedInteger&gt;&gt; dq = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Integer cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        dq.push(nestedList.iterator());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 非幂等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer res = cur;</span><br><span class="line">        cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 幂等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dq.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            Iterator&lt;NestedInteger&gt; it = dq.peek();</span><br><span class="line">            <span class="keyword">if</span> (it.hasNext())&#123;</span><br><span class="line">                NestedInteger i = it.next();</span><br><span class="line">                <span class="keyword">if</span> (i.isInteger())&#123;</span><br><span class="line">                    cur = i.getInteger();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dq.push(i.getList().iterator());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现是在<code>hasNext()</code>取值， 像<a href="https://htchz.cc/754409717.html">Java的SPI机制</a>的迭代也是在<code>hasNext()</code>取值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刷leetcode的时候看到这么道题，&lt;br&gt;&lt;img src=&quot;../images/20201023095530.png&quot; alt&gt;&lt;br&gt;这个&lt;code&gt;NestedInteger&lt;/code&gt;很明显组成了一颗只有叶子节点才有数据的树。于是一个DFS把所有元素抽成一个L
      
    
    </summary>
    
      <category term="algorithms" scheme="https://htchz.cc/categories/algorithms/"/>
    
    
      <category term="LeetCode" scheme="https://htchz.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>瞎谈LRU</title>
    <link href="https://htchz.cc/1917595334.html"/>
    <id>https://htchz.cc/1917595334.html</id>
    <published>2020-10-12T06:38:21.000Z</published>
    <updated>2020-10-13T15:09:22.635Z</updated>
    
    <content type="html"><![CDATA[<p>LRU是Least Recently Used的缩写，即<strong>最近最少使用算法</strong>。</p><ol><li>插入时是最新的数据，如果缓存已满，要淘汰最旧的数据。</li><li>更新时把旧元素变为最新数据，无需淘汰。</li><li>读取时把元素变为最新数据，无需淘汰。</li></ol><p>数组侧重读，链表侧重写。因为数组在删除插入非末尾元素的时候，需要调整余下元素的位置，所以链表会更合适。至于读，可以用哈希表提升性能。</p><p>链表和哈希表结合，这不就是java的<code>LinkedHashMap</code>么。<code>LinkedHashMap</code>会按put的顺序组织元素，链表头最旧，链表尾最新，<code>LinkedHashMap</code>有个<code>accessOrder</code>的属性，当为<code>true</code>时，访问元素的时候会把元素从原来的位置移除，放到链表尾，即最新的位置。因此如果要用<code>LinkedHashMap</code>实现一个LRU缓存，只需要给定一个容量，当元素超过这个容量的时候，把链表头（最旧）的元素移除就可以了。当然这只是一个idea，因为<code>LinkedHashMap</code>不是线程安全的，而缓存往往伴随多线程。</p><h1 id="Guava的LRU">1. Guava的LRU</h1><p>每个java程序员应该都用过Guava，guava的核心结构也是哈希表，为了线程安全，guava采用了segment分段的设计，而java8之前的<code>ConcurrentHashMap</code>也是采用分段来保证线程安全。</p><p>因此Guava的LRU是针对segment的，每个segment有自己的<code>accessQueue</code>,<code>writeQueue</code>,是两个双向链表，和哈希表本身结合，一个标准的LRU算法就呼之欲出了。</p><h1 id="Redis的LRU">2. Redis的LRU</h1><p>redis作为一个内存数据库，内存弥足珍贵，我们可以在内存不足时设定几种淘汰策略，默认是不驱逐，而LRU是可选择之一。</p><p>redis维护的key数量之多，如果用双向链表和哈希来做LRU，占用额外的空间会比我们应用里实现一个LRU多的多。</p><p>因此redis采取的是不严格的LRU，LFU亦如是。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>在redis里，一个key对应一个redisObject，redisObject有个属性是<code>lru</code>，长度为<code>LRU_BITS</code>24位。</p><p>然后redis还自己维护了一个全局时钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">       <span class="keyword">pid_t</span> pid;</span><br><span class="line">       <span class="keyword">char</span> *configfile;</span><br><span class="line">       <span class="comment">// 全局时钟，他的取值是 mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX</span></span><br><span class="line">       <span class="comment">// LRU_CLOCK_RESOLUTION表示精度，默认是1s，</span></span><br><span class="line">       <span class="comment">// 所以这个取值每过 2^24 * 1s ≈ 194天 就会归零</span></span><br><span class="line">       <span class="keyword">unsigned</span> lruclock:LRU_BITS;</span><br><span class="line">       ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个全局时钟根据<strong>redis.conf</strong>里的<strong>hz</strong>频率更新，将系统时间一顿操作转化为一个值。</p><p>redis在redisObject被访问的时候会更新lru属性，淘汰时根据<code>lru</code>就可以知道哪个对象时最久未被使用的。</p><p>redis每次淘汰时，随机选取samples=n的key，从中选取一个最旧未被访问的key进行淘汰。</p><p>因为是抽样，所以可能出现1天前加入的key没有被淘汰，1个小时前加入的key被淘汰的问题。但是至少，刚加入的key是绝对不会被淘汰。</p><h2 id="比较对象的年龄">2.1. 比较对象的年龄</h2><p>怎么比较两个对象的年龄呢，我们要计算一个idletime，如果idletime越大，则越久未被访问。由于对象时钟有可能比全局时钟大，有可能比全局时钟小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="comment">// 如果全局时钟比对象时钟大，那么直接相减，得到idletime</span></span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    <span class="comment">// 反之，则需要加上一个LRU_CLOCK_MAX周期，也就是194天，得到idletime</span></span><br><span class="line">    <span class="comment">// 这有点在求环形数组空闲空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面有个问题，加一个周期求的也是不准的，比如现在一个时钟是7点，另一个时钟是5点，现在确定7点的时钟比5点的时钟早，</span></span><br><span class="line">    <span class="comment">// 但是我们不能确定，这个7点是1天前的7点，还是两天前的7点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// redis只加了一个周期，因此这个idletime不是非常准确，但是至少保证，求出的idletime不会大于真实的idletime，如果一个key的idletime大，那他就是真的大！</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这么设计可能是为了省内存吧。</p><h1 id="innodb">3. innodb</h1><p>innodb的最小存储单位是页，对于那些加载过的数据页，innodb有一个LRU机制，把数据也缓存在buffer pool中，一个mysql实例有多个buffer pool实例。</p><p>假如innodb使用标准LRU，那么当一次大量数据加载后，将会淘汰掉buffer pool里的缓存，把这次的大量数据加载进缓存中。如果这一次大量数据只被使用一次，那么就老数据就白白地被淘汰了。</p><p><img src="../images/20201013213338.png" alt></p><p>innodb把缓存列表分为两部分，一部分是年轻代，占5/8，一部分是老年代，占3/8（垃圾回收乱入）。</p><ol><li>新数据页插入时，插在老年代的head位置。</li><li>用户读取数据页从buffer pool读取时，被移动到年轻代的head。数据页被预读时，不会移动。</li><li>随着数据的插入，年轻代的数据页会进入老年代位置，最终老年代tail的数据页会被移除。</li></ol><h1 id="我的实现">4. 我的实现</h1><p><a href="https://github.com/fennecs/leetcode-htc/blob/master/algorithms/0146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">leetcode146题</a></p><h1 id="参考">5. 参考</h1><ol><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual - Buffer Pool</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LRU是Least Recently Used的缩写，即&lt;strong&gt;最近最少使用算法&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入时是最新的数据，如果缓存已满，要淘汰最旧的数据。&lt;/li&gt;
&lt;li&gt;更新时把旧元素变为最新数据，无需淘汰。&lt;/li&gt;
&lt;li&gt;读取时把
      
    
    </summary>
    
      <category term="漫谈" scheme="https://htchz.cc/categories/%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="缓存" scheme="https://htchz.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>瞎谈补码</title>
    <link href="https://htchz.cc/2372178349.html"/>
    <id>https://htchz.cc/2372178349.html</id>
    <published>2020-07-23T16:39:27.000Z</published>
    <updated>2020-10-12T06:38:41.691Z</updated>
    
    <content type="html"><![CDATA[<p>补码是什么？记得C语言课本上写的，负数补码就是<strong>反码+1</strong>。很简单的一句话，但是讲的不明不白的。</p><ol><li>为什么负数补码是<strong>反码+1</strong>？</li><li>为什么正数的补码是其本身？</li><li>为什么127下一个数是-128？</li></ol><p>下面拿一个字节来扯淡。</p><h1 id="正数的编码是其本身">1. 正数的编码是其本身</h1><p>在计算机里，全部都是用补码表示数，补码就是一种对数的编码规则，一个二进制数就是一个<code>code point</code>，类似于unicode是一种字符的编码规则，一个<code>code point</code>可以对应一个真值。包括原码和反码，都是一种编码。所以这可以解答第二个问题，因为在补码里，我们把二进制<code>0000 0000</code>规定为0，最高位0的编码为正数，所以正数的补码是其本身，更确切的说法，<strong>在补码中，正数的编码是其本身</strong>。</p><p>所以8bit的范围是[-128,127]，当然我们可以规定8bit的范围是[-129,126]，或者[-127,128]这样做的后果就是：正数的编码不是其本身。</p><p>这会导致什么呢，我觉得这不会导致什么，无非就是对二进制认知会出现点问题，比如代码里写<code>byte a = 1;</code>，那么我们期望得到<code>00000001</code>，但是如果编码不是[-128,127]，那么我们声明的byte就不是我们期望的二进制序列——我们得按编码规则然后推出<code>00000001</code>对应的真值是多少，然后才能正确赋值。但是从计算的角度来说，只要编码确定了，计算就不会出错。</p><h1 id="原码和反码">2. 原码和反码</h1><p>有很多谈补码的，有一个观点是补码是在反码的基础上设计出来的，再加上这句负数补码是<strong>反码+1</strong>，就似乎更是如此了。</p><p>但是这有点由果推因的味道。反码英文是<code>1&#39;s complement</code>，称“1补数”，补码是<code>2&#39;s complement</code>，称“2补数”，其中<code>complement</code>的意思就是补码（后续补码单指<code>2&#39;s complement</code>），所以这两种码应该是不能看作依赖关系的，只能说两者之间可以互相推导。</p><p>从原码开始说起，原码是这么编码的：最高位是符号位，0是正数，1是负数，其他表示绝对值。但是对计算机来说，还得判断最高位才能计算，不行🙅。</p><p>反码是最高位作为符号位，负数保留符号位1不变，剩下位按位取反。反码只是为了让符号位参与计算，计算结果和真值计算结果相比，时对时错，其中根本问题是有两个0（+0/-0），这需要通过循环进位的规则才能正确应用。</p><p>要正确应用反码，运算规则是，如果最高位产生进位，要把进位循环进位到最低位。比如<code>0100 1000 + 1100 1000</code>进行计算，结果是<code>1 0001 0000</code>，那么在模=2^8的情况下最终结果应该是<code>0001 0001</code>。我的理解是，最高位进位，说明越过了(+0/-0)，是少一个数的，需要+1来调整。</p><blockquote><p>Internet协议IPv4，ICMP，UDP以及TCP都使用同样的16位反码检验和算法。虽然大多数计算机缺少“循环进位”硬件，但是这种额外的复杂性是可以接受的，因为“对于所有位（bit）位置上的错误都是同样敏感的”。 在UDP中，全0表示省略了可选的检验和特性。另外一种表示：FFFF，指示了0的检验和。 （在IPv4中，TCP和ICMP都强制性地规定了检验和，而在IPv6中可以省略）。</p></blockquote><h1 id="补码">3. 补码</h1><p>补码系统利用了模的思想，模就是用来表示一个计数范围，比如⏰的计量范围是0～11，模=12。二进制<code>0000 0000</code>～<code>1111 1111</code>的模就是<code>1 0000 0000</code>。</p><p>上面说到模，补码系统就是这么规定：一个数和他的二补码之和等于模。由于<code>1 0000 0000</code>和0的值是等价的，两个数之和等于0，那么，一个负数在补码系统里可以用正数的二补码来表示。同时可以得出一个结论，求一个数的相反数，只要求他的补码就好了。</p><p>由于<code>n</code>的二补码=<code>(模 - n)</code>=<code>(1 0000 0000 - n)</code>=<code>1 + 1111 1111 - n</code>，<code>1111 1111 - n</code>刚好又是按位取反，是反码，所以一个数的二补码是<strong>反码+1</strong>。但这只能作为一个定理，不能作为定义。<code>-128</code>不适用“负数补码是<strong>反码+1</strong>”，但是，在补码系统里，这个数却是存在的。事实上，<code>-128</code>的二补码等于其本身。</p><h1 id="编码是有序的">4. 编码是有序的</h1><p>在我看来，二进制没有正负之分，这个正负是人为加上去的，机器并不需要知道当前的数的正负。他只要拿到<code>0000 1000</code>和<code>1111 1101</code>相加，得到<code>0000 0101</code>，那么这个<code>0000 0101</code>是表示什么，机器不感兴趣。所以说即使8bit的范围变成[-129,126]或者[-127，128]，也不影响结果，<strong>只要编码是有序的</strong>，二进制计算法则总能保证结果是正确的（当然，这就不是补码了）。</p><p>这里的有序，指的是二进制的顺序和真值的顺序是一致的。比如不可以规定<code>{01111 1111,0111 1110,...,1000 0001,1000 0000}</code>对应<code>[-128,127]</code>，这样二进制顺序和真值顺序不一致。</p><p>像原码，-15 -&gt; -14，其编码<code>1000 1111</code>-&gt;<code>1000 1110</code>，这是不按顺序的。反码大致保证了顺序，但是存在两个0的<code>code point</code>，需要引入额外的调整才能消处两个0的问题。</p><p>真值的顺序和二进制顺序一致，所以127下一个数是-128，是因为<code>0111 1111</code>加1得到<code>1000 0000</code>。</p><p>总之，计算机不感兴趣正负，有符号数和无符号数分类，是在更高层面；计算机只负责计算，至于计算的结果是有符号还是无符号，取决于选取的指令是什么，取决于结果解释为什么。</p><h1 id="相反数">5. 相反数</h1><ol><li>不用乘法除法减法，怎么求相反数？按位取反+1，即求他的二补码。</li><li>8位数里，<code>1000 0000</code>的相反数？是<code>1000 0000</code>本身。</li></ol><h1 id="后记">6. 后记</h1><p>我的理解，在补码系统里，二补码是成对存在的，因此上面有时用<strong>补码</strong>有时用<strong>二补码</strong>，前者想表达一个数在补码系统里的表示，后者表示一个数对应的另一个数。</p><h1 id="参考">7. 参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/67227136" target="_blank" rel="noopener">趣谈计算机补码</a></li><li><a href="https://www.zhihu.com/question/405701348/answer/1329114111" target="_blank" rel="noopener">为什么8bit限制是-128到127而不是-127到128?</a></li><li><a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">Two’s complement</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;补码是什么？记得C语言课本上写的，负数补码就是&lt;strong&gt;反码+1&lt;/strong&gt;。很简单的一句话，但是讲的不明不白的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么负数补码是&lt;strong&gt;反码+1&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;为什么正数的补码是其本身？&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="漫谈" scheme="https://htchz.cc/categories/%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="编码" scheme="https://htchz.cc/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>[Redis]scan命令实现</title>
    <link href="https://htchz.cc/3055836750.html"/>
    <id>https://htchz.cc/3055836750.html</id>
    <published>2020-07-14T07:07:35.000Z</published>
    <updated>2020-07-14T10:15:06.237Z</updated>
    
    <content type="html"><![CDATA[<p>如果要在redis查找遍历key，<code>keys</code>命令会阻塞，是不能用的，这时就要用<code>scan</code>命令。</p><p><code>scan</code>命令支持传入<code>cursor</code>、<code>match pattern</code>、<code>count</code>、<code>type</code>(6.0新增type)，根据游标，返回<code>count</code>数量的符合条件的key，以及新游标。注意这个<code>count</code>只是一个期望值，看源码就知道为什么不是确切值。</p><p>db是由dict组成的，set、hash、ziplist也是有dict类型的，dict发生扩容和缩容的话，<strong>如果</strong>按自然数的方法去遍历，扩容会重复遍历，缩容会遗漏遍历。</p><p>假设dict稳定状态下，dict size从8变成16，刚访问过index为3的桶，接下来就应该遍历4-15桶，由于原先0-3号的桶的key有一部分挪到8-11中（+8），后面就会重复遍历到。</p><p>假设dict size从8变成4，刚访问过index为3的桶，那么接下来就是遍历结束了，这样原先4-7号的桶就会漏掉（-4）。</p><p>如果在扩容缩容情况下，需要遍历两条数组，同样会遇到上面的问题。</p><p>看看redis是怎么解决的。</p><p>redis不采用自然数顺序遍历，而是采用高位顺序遍历，也就是对游标前进的方式是酱紫的：用对应数组的掩码将游标的值截断（准确地说不是截断，可以先用截断理解） —&gt; 左右翻转 -&gt; 自增 -&gt; 左右翻转回来。</p><p>这个算法的原理是，数组扩容是<code>*2</code>，那么每次扩容，旧数组的元素哈希值<code>&amp; new_mask</code>得到下标，要么在原来的桶，要么是原来桶的index<code>*2</code>，具体表现为最高位分别是0和1。那么从高位起开始遍历的话，如果去掉最高位，其实遍历的顺序和旧数组是一样的。</p><p>举个例子，<br><img src="../images/20200714163911.png" alt><br>原来的顺序是</p><pre><code>000100010110</code></pre><p>那么扩容后，顺序是</p><pre><code>(0)000(1)000(0)100(1)100(0)010(1)010(0)110(1)100</code></pre><p>括号里就是最高位，去掉最高位，和原来的数组是一致的。</p><h1 id="遍历实现">1. 遍历实现</h1><p>代码基于6.0，主要分为两部分，一部分是dict非rehash状态，一部分是rehash状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将游标v的元素放到privdata，并用算法推进cursor，</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction* bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Having a safe iterator means no rehashing can happen, see _dictRehashStep.</span></span><br><span class="line"><span class="comment">     * This is needed in case the scan callback tries to do dictFind or alike. */</span></span><br><span class="line">    d-&gt;iterators++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">         * operates on the masked bits */</span></span><br><span class="line">        v |= ~m0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        v++;</span><br><span class="line">        v = rev(v);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                next = de-&gt;next;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里曾经有个bug，参考下面美团链接</span></span><br><span class="line">            <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">            v |= ~m1;</span><br><span class="line">            v = rev(v);</span><br><span class="line">            v++;</span><br><span class="line">            v = rev(v);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个(m0 ^ m1)就是前面说到的高位，我认为这个循环只会执行两次，小数组的一个桶下标对应大数组的两个桶下标</span></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* undo the ++ at the top */</span></span><br><span class="line">    d-&gt;iterators--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非rehash状态，用掩码定位计算cursor对应的桶，用一个循环取出桶下所有entry。</p><p>在rehash状态，不用区分是扩容还是缩容，只要需要确定大小数组，循环取出小数组的桶的entry，对于大数组，遍历两个桶的所有entry，并推进cursor</p><h1 id="游标推进">2. 游标推进</h1><p>cursor推进的算法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里将非掩码部分置1，如上面说的并非截断</span></span><br><span class="line">v |= ~m1;</span><br><span class="line"><span class="comment">// 翻转</span></span><br><span class="line">v = rev(v);</span><br><span class="line"><span class="comment">// 自增</span></span><br><span class="line">v++;</span><br><span class="line"><span class="comment">// 翻转回来</span></span><br><span class="line">v = rev(v);</span><br></pre></td></tr></table></figure><p>rev函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function to reverse bits. Algorithm from:</span></span><br><span class="line"><span class="comment"> * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s = CHAR_BIT * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = ~<span class="number">0U</span>L;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大意是，<code>unsigned long</code>是32位，即把前16位和后16位交换，然后16位里，前8位和后8位交换。。。以此类推，总共5次。</p><blockquote><p>想吐槽这个老哥不是不屑于这种位运算魔法吗 = =</p></blockquote><h1 id="scanGenericCommand">3. scanGenericCommand</h1><p>这个方法是scan命令的实现，源代码比较长，注释写的很详细，大约有四步：<br>Step 1: Parse options. 这一步是把参数校验<br>Step 2: Iterate the collection. 这一步是提取出目标的dict，调用前面的遍历方法。<br>Step 3: Filter elements. 这一步是根据match过滤或根据type过滤。<br>Step 4: Reply to the client. 回复客户端</p><p>主要看第二步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Iterate the collection.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Note that if the object is encoded with a ziplist, intset, or any other</span></span><br><span class="line"><span class="comment">    * representation that is not a hash table, we are sure that it is also</span></span><br><span class="line"><span class="comment">    * composed of a small number of elements. So to avoid taking state we</span></span><br><span class="line"><span class="comment">    * just return everything inside the object in a single call, setting the</span></span><br><span class="line"><span class="comment">    * cursor to zero to signal the end of the iteration. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">ht = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ht = c-&gt;db-&gt;dict;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">    ht = o-&gt;ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">    ht = o-&gt;ptr;</span><br><span class="line">    count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">    zset *zs = o-&gt;ptr;</span><br><span class="line">    ht = zs-&gt;dict;</span><br><span class="line">    count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ht) &#123;</span><br><span class="line">    <span class="keyword">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">/* We set the max number of iterations to ten times the specified</span></span><br><span class="line"><span class="comment">        * COUNT, so if the hash table is in a pathological state (very</span></span><br><span class="line"><span class="comment">        * sparsely populated) we avoid to block too much time at the cost</span></span><br><span class="line"><span class="comment">        * of returning no or very few elements. */</span></span><br><span class="line">    <span class="keyword">long</span> maxiterations = count*<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We pass two pointers to the callback: the list to which it will</span></span><br><span class="line"><span class="comment">        * add new elements, and the object containing the dictionary so that</span></span><br><span class="line"><span class="comment">        * it is possible to fetch more data in a type-dependent way. */</span></span><br><span class="line">    privdata[<span class="number">0</span>] = keys;</span><br><span class="line">    privdata[<span class="number">1</span>] = o;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cursor = dictScan(ht, cursor, scanCallback, <span class="literal">NULL</span>, privdata);</span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor &amp;&amp;</span><br><span class="line">            maxiterations-- &amp;&amp;</span><br><span class="line">            listLength(keys) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> ll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(intsetGet(o-&gt;ptr,pos++,&amp;ll))</span><br><span class="line">        listAddNodeTail(keys,createStringObjectFromLongLong(ll));</span><br><span class="line">    cursor = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH || o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vll);</span><br><span class="line">        listAddNodeTail(keys,</span><br><span class="line">            (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="keyword">char</span>*)vstr,vlen) :</span><br><span class="line">                                createStringObjectFromLongLong(vll));</span><br><span class="line">        p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Not handled encoding in SCAN."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意遍历停止的条件是<code>cursor &amp;&amp; maxiterations &gt; 0 &amp;&amp; listlength(keys) &lt; count</code>，</p><p>如果需要返回key/value，count *= 2，<br>maxiterations = count * 10；</p><p>结合后面的过滤，所以说返回结果的长度不是严格按照我们传入的count的值，有可能超了一丢丢，有可能遍历了10倍count数量的桶没几个元素，也有可能找到很多被过滤了一大堆。</p><p>还有一件事，第二步，如果scan目标是集合，且集合数量比较少，没用dict实现，那么不会用前面的遍历方法来收集元素，而是直接拿出所有元素。</p><h1 id="参考">4. 参考</h1><ol><li><a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html" target="_blank" rel="noopener">美团针对Redis Rehash机制的探索和实践</a></li><li><a href="https://www.shuzhiduo.com/A/Vx5MZGeYdN/" target="_blank" rel="noopener">Redis二进制反转算法分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果要在redis查找遍历key，&lt;code&gt;keys&lt;/code&gt;命令会阻塞，是不能用的，这时就要用&lt;code&gt;scan&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scan&lt;/code&gt;命令支持传入&lt;code&gt;cursor&lt;/code&gt;、&lt;code&gt;match pat
      
    
    </summary>
    
      <category term="redis" scheme="https://htchz.cc/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>[Mysql]两阶段提交和崩溃恢复</title>
    <link href="https://htchz.cc/2934732838.html"/>
    <id>https://htchz.cc/2934732838.html</id>
    <published>2020-06-05T03:15:08.000Z</published>
    <updated>2020-06-05T17:04:55.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两阶段提交">1. 两阶段提交</h1><p>innodb和bin log需要进行两阶段提交(Two-Phase Commit Protocol，2PC)，目的是为了保证日志一致性，要么都存在，要么都不存在。</p><p>要说明的是，两阶段提交不止redo log和binlog有关，undo log也是参与者。</p><p>XID是事务根据事务第一条query生成的id，通过XID将redo log和binlog关联起来。在上一篇的binlog日志里也能看到XID的身影。</p><p>两阶段提交，其实就是innodb prepare，写binlog，innodb commit；</p><p>具体是，</p><ol><li>prepare阶段，redo log写入根据事务提交时的刷盘策略决定是否刷盘，然后将log segment(不是回滚段！！！)标为<code>TRX_UNDO_PREPARED</code>；binlog不做任何事</li><li>commit阶段，binlog写入binlog日志；接着innodb将修改undo log segment状态，并在redo log写入一个commit log。</li></ol><p>如果没有两阶段提交，redo log和binlog各写各的，中间发生崩溃，就会出现不一致的情况。</p><ol><li>先写binlog，再写redo log：如果redo log没写成功，就会造成崩溃恢复的时候，主库没有、从库有的情况，主从不一致。</li><li>先写redo log，再写binlog：如果binlog没写成功，就会造成崩溃恢复的时候，主库有、从库没有的情况，主从不一致。</li></ol><p>说白了，为了保证事务，总是得做一些冗余的操作，例如tcp多次握手挥手，都是通过冗余操作来保证两个业务之间一致。</p><h2 id="redo-log和binlog顺序不一致的问题">1.1. redo log和binlog顺序不一致的问题</h2><p>两阶段的提交不只如此，如果只是像上面那样，还会出现主从不一致的情况。</p><h3 id="热备问题">1.1.1. 热备问题</h3><pre><code>T1 (--prepare--binlog[pos100]--------------------------------------------commit)T2 (-----prepare-----binlog[pos200]----------commit)T3 (--------prepare-------binlog[pos300]------commit)online-backup(----------------------------------------------backup------------)</code></pre><p>假设3个事务如上，那么</p><pre><code>redo log prepare的顺序：T1 --&gt; T2 --&gt; T3binlog的写入顺序：      T1 --&gt; T2 --&gt; T3redo log commit的顺序： T2 --&gt; T3 --&gt; T1</code></pre><p>可以看到redo log提交的顺序和bin log不一致了，这是不允许的，会导致主从不一致。</p><p>online-backup表示热备，因为从库在建立的时候需要对主库进行一次备份。当T2，T3提交后，这时热备来读位置，读到最后一个提交的事务T3，由于这个阶段不是读binlog的，所以T1没有被复制到，接下来的binlog复制从T3开始，所以会漏掉T1的数据。</p><h3 id="复制问题">1.1.2. 复制问题</h3><p>《MySQL5.7 核心技术揭秘：MySQL Group commit》（见参考）举了一个例子，就是有一行数据，x=1，y=1<br>T1:x=y+1,y=x+1;<br>T2:y=x+1,x=y+1;</p><p>文章说这两个事务颠倒执行出来的结果不一样。<strong>但是在我看来</strong>，这两个事务是没法颠倒的。事务为了防止<strong>回滚覆盖</strong>，对一条记录加X锁修改后，只有事务提交之后才能释放X锁，所以这两个事务是没办法同时处于2PC的，肯定是T1 2PC完，T2才开始2PC。才疏学浅，可能理解有误，欢迎指出。</p><p>所以早期的mysql用<code>prepare_commit_mutex</code>锁来发起2PC保证顺序，这在高并发下是很耗费性能的。一个事务要获取锁才能发起prepare，知道commit之后才释放锁。除了锁竞争，另一方面，<code>sync_binlog=1</code>的情况下，每次2PC需要刷盘binlog刷盘，这不仅增大了磁盘压力，也延长了占有锁的时长。</p><p>于是mysql5.6引入了组提交。</p><h2 id="组提交">1.2. 组提交</h2><p>组提交是通过一个机制保证binlog顺序和commit顺序一致。</p><p>加入组提交之后，2PC的过程稍微变了。在将commit阶段细分，保证commit顺序和写binlog一致。</p><p>这个过程每个阶段都用了一个队列来存储，先到的线程是list的leader，后到的加入链表成为follower，</p><ol><li>prepare阶段，事务获取<code>prepare_commit_mutex</code>，然后刷盘，设置prepare状态，然后释放锁。</li><li>commit阶段分成三个阶段：<ol><li>Flush stage: leader获得<code>Lock_log mutex</code>锁，将队列里的binlog写入文件缓冲</li><li>Sync stage:leader释放<code>Lock_log mutex</code>，持有<code>Lock_sync mutex</code>, 如果sync_binlog为1，进行sync操作</li><li>Commit stage: leader释放<code>Lock_sync mutex</code>，持有<code>Lock_commit mutex</code>，遍历队列，逐一进行commit。</li></ol></li></ol><p>每个阶段的队列长度不是一致的，可能Flush阶段的leader会在Sync阶段追加进前一个队列，成为follower，但是follower永远是follower。</p><p>网上的这个图很形象。<br><img src="../images/20200605174715.png" alt></p><p>在Sync stage阶段，有两个参数可以影响组提交：</p><ul><li><code>binlog_group_commit_sync_delay=N</code>:这个参数表明在Sync stage等待多少μs后可以刷盘，等的越久，就越可能合并后来的队列，一次刷更多日志，但是相应的，事务响应就变慢。</li><li><code>binlog_group_commit_sync_no_delay_count=N</code>:当队列的事务个数达到N，就进行刷盘。</li></ul><p>组提交优点：</p><ul><li>将本该串行的过程变成可并行的过程</li><li>虽然<code>prepare_commit_mutex</code>没有去除，但是占用的时间变短了，变成1/4</li><li>通过队列保证顺序一致</li><li>合并刷盘</li></ul><h1 id="崩溃恢复">2. 崩溃恢复</h1><h2 id="未开启binlog">2.1. 未开启binlog</h2><p>从redo log读到last checkpoint lsn，然后从这个位置开始重新应用redo log，不管是提交还是未提交状态。由于undo log会记录成redo log，所以构造出undo log之后，可以通过undo log回滚未提交的事务。</p><h2 id="开启binlog">2.2. 开启binlog</h2><p>先和上面执行一样的逻辑，由于多了binlog，为了和从库保证一致，需要提取最后一个binlog文件的XID，接着检查处于prepare状态的redo log，如果redo log的XID不在binlog里，则回滚，如果在，提交redo log。</p><h1 id="参考">3. 参考</h1><ol><li><a href="http://keithlan.github.io/2018/07/24/mysql_group_commit/" target="_blank" rel="noopener">《MySQL5.7 核心技术揭秘：MySQL Group commit》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;两阶段提交&quot;&gt;1. 两阶段提交&lt;/h1&gt;&lt;p&gt;innodb和bin log需要进行两阶段提交(Two-Phase Commit Protocol，2PC)，目的是为了保证日志一致性，要么都存在，要么都不存在。&lt;/p&gt;
&lt;p&gt;要说明的是，两阶段提交不止redo lo
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://htchz.cc/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>[Mysql]漫游bin log</title>
    <link href="https://htchz.cc/2414692924.html"/>
    <id>https://htchz.cc/2414692924.html</id>
    <published>2020-05-26T01:51:00.000Z</published>
    <updated>2020-06-05T09:00:10.794Z</updated>
    
    <content type="html"><![CDATA[<p>binlog是server层的日志，对于innodb来说，只有binlog写完后，才能提交redo log。binlog记录逻辑语句，只会记录写类似于sql的日志。binlog主要的作用</p><ol><li>崩溃恢复</li><li>主从复制</li></ol><h1 id="组织结构">1. 组织结构</h1><h2 id="文件">1.1. 文件</h2><p>binlog的相关配置可以执行<code>show variables like &#39;%bin%&#39;;</code>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%bin%';</span><br><span class="line">+<span class="comment">--------------------------------------------+---------------------------------+</span></span><br><span class="line">| Variable_name                              | Value                           |</span><br><span class="line">+<span class="comment">--------------------------------------------+---------------------------------+</span></span><br><span class="line">| bind_address                               | *                               |</span><br><span class="line">| binlog_cache_size                          | 32768                           |</span><br><span class="line">| binlog_checksum                            | CRC32                           |</span><br><span class="line">| binlog_direct_non_transactional_updates    | OFF                             |</span><br><span class="line">| binlog_error_action                        | ABORT_SERVER                    |</span><br><span class="line">| binlog_format                              | ROW                             |</span><br><span class="line">| binlog_group_commit_sync_delay             | 0                               |</span><br><span class="line">| binlog_group_commit_sync_no_delay_count    | 0                               |</span><br><span class="line">| binlog_gtid_simple_recovery                | ON                              |</span><br><span class="line">| binlog_max_flush_queue_time                | 0                               |</span><br><span class="line">| binlog_order_commits                       | ON                              |</span><br><span class="line">| binlog_row_image                           | FULL                            |</span><br><span class="line">| binlog_rows_query_log_events               | OFF                             |</span><br><span class="line">| binlog_stmt_cache_size                     | 32768                           |</span><br><span class="line">| binlog_transaction_dependency_history_size | 25000                           |</span><br><span class="line">| binlog_transaction_dependency_tracking     | COMMIT_ORDER                    |</span><br><span class="line">| innodb_api_enable_binlog                   | OFF                             |</span><br><span class="line">| innodb_locks_unsafe_for_binlog             | OFF                             |</span><br><span class="line">| log_bin                                    | ON                              |</span><br><span class="line">| log_bin_basename                           | /data/mysql3306/mysql-bin       |</span><br><span class="line">| log_bin_index                              | /data/mysql3306/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators            | ON                              |</span><br><span class="line">| log_bin_use_v1_row_events                  | OFF                             |</span><br><span class="line">| log_statements_unsafe_for_binlog           | ON                              |</span><br><span class="line">| max_binlog_cache_size                      | 18446744073709547520            |</span><br><span class="line">| max_binlog_size                            | 536870912                       |</span><br><span class="line">| max_binlog_stmt_cache_size                 | 18446744073709547520            |</span><br><span class="line">| sql_log_bin                                | ON                              |</span><br><span class="line">| sync_binlog                                | 1                               |</span><br><span class="line">+<span class="comment">--------------------------------------------+---------------------------------+</span></span><br></pre></td></tr></table></figure><p>执行<code>show master status;</code>可以看到当前写入的二进制文件的名字和位置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000930 | 178613715 |              | mysql,test       |                   |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.10</span> sec)</span><br></pre></td></tr></table></figure><p>binlog主要有两种文件：</p><ul><li>二进制日志索引文件（文件名后缀为.index）用于记录所有有效的的二进制文件。</li><li>二进制日志文件（文件名后缀为.****）记录数据库所有的DDL和DML语句事件</li></ul><p>如上输出，二进制日志文件存放的<code>basename</code>是”/data/mysql3306/mysql-bin.****”，二进制日志索引文件路径是”/data/mysql3306/mysql-bin.index”,</p><p>具体如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@dev_test63 mysql3306]# ls -l mysql-bin*</span><br><span class="line">-rw-r----- 1 mysql mysql 538582976 5月  22 01:17 mysql-bin.000919</span><br><span class="line">-rw-r----- 1 mysql mysql 536879010 5月  22 12:03 mysql-bin.000920</span><br><span class="line">-rw-r----- 1 mysql mysql 536885288 5月  22 20:03 mysql-bin.000921</span><br><span class="line">-rw-r----- 1 mysql mysql 536871917 5月  23 05:05 mysql-bin.000922</span><br><span class="line">-rw-r----- 1 mysql mysql 536871391 5月  23 21:40 mysql-bin.000923</span><br><span class="line">-rw-r----- 1 mysql mysql 536895385 5月  24 07:03 mysql-bin.000924</span><br><span class="line">-rw-r----- 1 mysql mysql 536945072 5月  25 00:03 mysql-bin.000925</span><br><span class="line">-rw-r----- 1 mysql mysql 536904757 5月  25 09:03 mysql-bin.000926</span><br><span class="line">-rw-r----- 1 mysql mysql 536871742 5月  25 19:28 mysql-bin.000927</span><br><span class="line">-rw-r----- 1 mysql mysql 536870960 5月  26 04:34 mysql-bin.000928</span><br><span class="line">-rw-r----- 1 mysql mysql 536871255 5月  26 19:33 mysql-bin.000929</span><br><span class="line">-rw-r----- 1 mysql mysql 153202413 5月  27 00:22 mysql-bin.000930</span><br><span class="line">-rw-r----- 1 mysql mysql       228 5月  26 19:33 mysql-bin.index</span><br></pre></td></tr></table></figure><p><code>sync_binlog</code>是用来表示同步刷binlog，如果数据库繁忙可能会造成磁盘io压力大</p><ol><li>参数为0时，并不是立即fsync文件到磁盘，而是依赖于操作系统的fsync机制；</li><li>参数为1时，立即fsync文件到磁盘；</li><li>参数大于1时，则达到指定提交次数后，统一fsync到磁盘。 因此只有当sync_binlog参数为1时，才是最安全的，当其不为1时，都存在binlog未fsync到磁盘的风险，若此时发生断电等故障，就有可能出现此事务并未刷出到磁盘。</li></ol><p><code>sql_log_bin</code>表示开启binlog，开关都需要重启mysql<br><strong>mysql-bin.index</strong>这个文件很简单，只是记录了当前的binlog列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@dev_test63 mysql3306]# cat mysql-bin.index</span><br><span class="line">./mysql-bin.000919</span><br><span class="line">./mysql-bin.000920</span><br><span class="line">./mysql-bin.000921</span><br><span class="line">./mysql-bin.000922</span><br><span class="line">./mysql-bin.000923</span><br><span class="line">./mysql-bin.000924</span><br><span class="line">./mysql-bin.000925</span><br><span class="line">./mysql-bin.000926</span><br><span class="line">./mysql-bin.000927</span><br><span class="line">./mysql-bin.000928</span><br><span class="line">./mysql-bin.000929</span><br><span class="line">./mysql-bin.000930</span><br></pre></td></tr></table></figure><p>而binlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数<code>0xfe62696e</code>开头（后3字节其实就是”bin”）</p><p>接着是一组Events，Event由header组成，header记录了创建时间、服务器标识等，data是数据。一个binlog文件里，第一个event描述binlog的格式，最后一个binlog描述下一个binlog文件的信息。</p><h2 id="rotation">1.2. rotation</h2><p>当下面三种情况发生时，binlog会rotate新文件：</p><ul><li>实例停止或重启时</li><li>flush logs 命令；</li><li>当前binlog &gt; <code>max_binlog_size</code>(像上面的配置是512M)</li></ul><blockquote><p>如果有一个大事务执行时，很可能会发生一个binlog文件稍大于<code>max_binlog_size</code></p></blockquote><h1 id="模式">2. 模式</h1><p>binlog有三种记录模式，分别是<strong>statement</strong>，<strong>row</strong>，<strong>mixed</strong>，通过<code>binlog_format</code>来指定，可以在运行时指定。</p><!--TODO mysql binlog设置--><h2 id="statement">2.1. statement</h2><p><strong>statement</strong>记录的是原语句，你执行什么语句就会记录什么语句。这在主从复制的时候就会出现一些问题：</p><p>这里提一个问题：<strong>为什么大多数数据库的默认隔离级别是RC，而innodb是RR呢</strong>：</p><p>这是一个历史遗留问题，网上也可以找到很多解释，大体就是：在mysql5.1.5之前只有<strong>statement</strong>模式，如果事务用RC隔离级别，就会可能出现主从不一致的情况。</p><!--TODO 验证--><p>现在已经不能在<strong>statement</strong>模式下执行RC事务了，会报下面的错误：</p><blockquote><p>Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.</p></blockquote><p>假设RC允许，那么假设student表有score字段，</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td>begin;</td></tr><tr><td>delete from student where score &lt; 6;</td><td>/</td></tr><tr><td>/</td><td>insert into student(score) values(1);</td></tr><tr><td>/</td><td>commit;</td></tr><tr><td>commit;</td><td>/</td></tr></tbody></table><p>在RR级别下，事务B的语句会阻塞，因为事务A会给满足条件的列加上X锁，给间隙加上gap锁，所以事务B是会被阻塞的。<br>在RC级别下，事务B的语句是不会阻塞的，因此先于事务A提交，提交完成写入binlog，接着A提交写入binlog，</p><p>所以在binlog里是这样的（只是举个🌰）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(age) <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> age &lt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这样binlog被从库消费之后就主从就不一致。</p><h2 id="row">2.2. row</h2><p><strong>row</strong>是记录到每一行的逻辑语句，比如执行<code>update student set name = &#39;土川&#39; where age &lt; 10</code>的sql，就会生成n条记录。</p><p>这样可以避免<strong>statement</strong>产生的问题，<strong>缺点</strong>就是日志量太大，可能会产生io压力。</p><h2 id="mixed">2.3. mixed</h2><p><strong>mixed</strong>模式是由mysql自行判断使用哪种模式。转换条件<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log-mixed.html" target="_blank" rel="noopener">传送门</a></p><blockquote><p>新版本的MySQL对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更；因此，现在一般使用row level即可。</p></blockquote><h1 id="binlog内容">3. binlog内容</h1><h2 id="mysqlbinlog">3.1. mysqlbinlog</h2><p>mysqlbinlog是mysql提供的一个查看binlog的工具，通过该工具可以将二进制文件解析为文本供我们进行阅读，还可以查看远程服务器上的binlog，可以指定时间或偏移量作为start、stop来作为查询条件。如果指定的偏移量不是一个event的起始偏移量，则会报错。</p><p>当前msyql是row模式，执行<code>mysqlbinlog -v --start-datetime=&quot;2020-05-25 09:59:59&quot; --stop-datetime=&quot;2020-05-25 10:00:00&quot; mysql-bin.000927 --base64-output=decode-rows</code>，<code>--base64-output=decode-rows</code>为了解码<code>row</code>格式，<code>-v</code>详细输出语句。截取一部分如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># at 26237733</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26237798 CRC32 0xbcd552f0 GTID [commit=no]</span></span><br><span class="line"><span class="keyword">SET</span> @@SESSION.GTID_NEXT= <span class="string">'ANONYMOUS'</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment"># at 26237798</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26237883 CRC32 0x5558cbbe Querythread_id=43976966exec_time=0error_code=0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">TIMESTAMP</span>=<span class="number">1590371999</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment"># at 26237883</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26237968 CRC32 0x8f9f400f Table_map: `superq_db`.`superq_trigger_registry` mapped to number 96550</span></span><br><span class="line"><span class="comment"># at 26237968</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26238162 CRC32 0x560afdaa Update_rows: table id 96550 flags: STMT_END_F</span></span><br><span class="line"><span class="comment">### UPDATE `superq_db`.`superq_trigger_registry`</span></span><br><span class="line"><span class="comment">### WHERE</span></span><br><span class="line"><span class="comment">###   @1=15093</span></span><br><span class="line"><span class="comment">###   @2='EXECUTOR'</span></span><br><span class="line"><span class="comment">###   @3='job-executor-saber'</span></span><br><span class="line"><span class="comment">###   @4='172.88.2.128:19012'</span></span><br><span class="line"><span class="comment">###   @5='172.88.2.128:10099'</span></span><br><span class="line"><span class="comment">###   @6=1590371989</span></span><br><span class="line"><span class="comment">### SET</span></span><br><span class="line"><span class="comment">###   @1=15093</span></span><br><span class="line"><span class="comment">###   @2='EXECUTOR'</span></span><br><span class="line"><span class="comment">###   @3='job-executor-saber'</span></span><br><span class="line"><span class="comment">###   @4='172.88.2.128:19012'</span></span><br><span class="line"><span class="comment">###   @5='172.88.2.128:10099'</span></span><br><span class="line"><span class="comment">###   @6=1590371999</span></span><br><span class="line"><span class="comment"># at 26238162</span></span><br><span class="line"><span class="comment">#200525  9:59:59 server id 3306  end_log_pos 26238193 CRC32 0x1e662746 Xid = 3290666026</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure><ul><li><code># at xxxx</code>：一个event的开头，</li><li><code>#200525  9:59:59</code>：时间，20年5月25日，9时59分59秒</li><li><code>server id 3306</code>：server编号</li><li><code>end_log_pos 26237798</code>：下一个事件开始的位置（即当前事件的结束位置+1）</li><li><code>CRC32 0xbcd552f0</code>：CRC32是校验和的算法，在上面配置清单里<code>binlog_checksum</code>可以看到，后面跟着的是32位校验和。</li><li><code>Query</code>：event type，具体可以翻阅<a href="https://dev.mysql.com/doc/internals/en/event-classes-and-types.html" target="_blank" rel="noopener">Event Classes and Types</a></li><li><code>thread_id=43976966</code>：线程id</li><li><code>exec_time=0</code>：执行时间</li><li><code>error_code=0</code>：错误码，0表示无错误</li><li><code>Xid = 3290666026</code>：表示redo log和binlog做XA的Xid</li></ul><h3 id="结构体">3.1.1. 结构体</h3><p>前面说到，event分为header和data，事实上，binlog 事件的结构主要有3个版本：</p><ul><li>v1: Used in MySQL 3.23</li><li>v3: Used in MySQL 4.0.2 though 4.1</li><li>v4: Used in MySQL 5.0 and up</li></ul><p>现在基本用的是v4版本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| event  | timestamp         0 : 4    |</span><br><span class="line">| header +<span class="comment">----------------------------+</span></span><br><span class="line">|        | type_code         4 : 1    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | server_id         5 : 4    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | event_length      9 : 4    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | next_position    13 : 4    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | flags            17 : 2    |</span><br><span class="line">|        +<span class="comment">----------------------------+</span></span><br><span class="line">|        | extra_headers    19 : x-19 |</span><br><span class="line">+=====================================+</span><br><span class="line">| event  | fixed part        x : y    |</span><br><span class="line">| data   +<span class="comment">----------------------------+</span></span><br><span class="line">|        | variable part              |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure><p>上面用<code>offset : length</code>描述了各个属性的位置，如果事件头的长度是 x 字节，那么事件体的长度为 (event_length - x) 字节；设事件体中 fixed part 的长度为 y 字节，那么 variable part 的长度为 (event_length - (x + y)) 字节</p><h3 id="binlog-checksum">3.1.2. binlog-checksum</h3><p>校验和功能是为了防止传输过程中发生差错，主从不一致。</p><p>关于binlog-checksum有三个参数，分别是</p><ul><li><code>binlog_checksum</code>：默认值是CRC32，可以设置为<code>NONE</code></li><li><code>master_verify_checksum</code>：主库校验event校验和，默认为0，在master thread进行dump的时候校验，在<code>SHOW BINLOG EVENTS</code>校验</li><li><code>slave_sql_verify_checksum</code>：从库校验event校验和，默认为1，当IO thread把event写入到relay log（从库读取到的binlog生成relay log）的时候校验。</li></ul><p>mysqlbinlog可以加上<code>--verify-binlog-checksum</code>参数，打印有问题的sql。</p><p>如果校验失败会报错，可以用<code>pt-table-checksum</code>工具进行修正，关于更多，另行了解。</p><h2 id="SHOW-BINLOG-EVENTS">3.2. SHOW BINLOG EVENTS</h2><p>这个是mysql命令，也是用来阅读binlog。使用方式是<code>SHOW BINLOG EVENTS [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count]</code>，中括号都是可选项。</p><h2 id="GTID">3.3. GTID</h2><p>可以在日志里看到<code>GTID</code>的字眼，GTID即Global Transaction ID，全局事务id，由<code>server_uuid:transaction_id</code>组成，是在mysql5.6引进的一个特性。</p><p>组复制插件<strong>MGR</strong>mysql官方的一个高可用插件，使用了PAXOS协议。在这种一致性协议中需要有一个全局增长的command index，GTID就承担了这个角色。</p><p>执行<code>show variables like &#39;%gtid%&#39;;</code>，输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----------------------------------+-----------+</span></span><br><span class="line">| Variable_name                    | Value     |</span><br><span class="line">+<span class="comment">----------------------------------+-----------+</span></span><br><span class="line">| binlog_gtid_simple_recovery      | ON        |</span><br><span class="line">| enforce_gtid_consistency         | OFF       |</span><br><span class="line">| gtid_executed_compression_period | 1000      |</span><br><span class="line">| gtid_mode                        | OFF       |</span><br><span class="line">| gtid_next                        | AUTOMATIC |</span><br><span class="line">| gtid_owned                       |           |</span><br><span class="line">| gtid_purged                      |           |</span><br><span class="line">| session_track_gtids              | OFF       |</span><br><span class="line">+<span class="comment">----------------------------------+-----------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p><code>gtid_mode</code>其实是<code>OFF</code>状态。</p><p>关于更多，另行了解。</p><h1 id="主从复制">4. 主从复制</h1><p>主从复制有基于binlog和基于GTID两种方式。基于binlog的复制模式的基本流程是：</p><ol><li>master事务提交，将记录变更写入binlog</li><li>slave的io进程连接master，从指定位置或从0开始请求日志</li><li>master返回日志给slave，并带上binlog名称和下一个binlog消费位置</li><li>slave接收到日志，将日志追加到relay log末端，并记录binlog名称和binlog消费位置，下次请求使带上。</li><li>slave的sql进程不断读relay log，执行sql。</li><li>如果slave开启了binlog，又会将执行的sql变更记入binlog；如果slave又是其他slave的master，就会执行一样的逻辑。</li></ol><p>在slave上执行，<code>show slave status\G</code>，部分输出如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 11.198.116.79</span><br><span class="line">                  Master_User: replicator</span><br><span class="line">                  Master_Port: 3018</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000831</span><br><span class="line">          Read_Master_Log_Pos: 1151797</span><br><span class="line">               Relay_Log_File: slave-relay.002490</span><br><span class="line">                Relay_Log_Pos: 313</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000831</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 1151797</span><br><span class="line">              Relay_Log_Space: 769</span><br></pre></td></tr></table></figure><p>如果<code>Read_Master_Log_Pos</code>和<code>Exec_Master_Log_Pos</code>一致，表示从库已经追赶上主库。</p><p>在主库执行<code>show master status\G</code>，可以看到主库当前正在写入的binlog和位置。</p><h1 id="参考">5. 参考</h1><ol><li><a href="https://dev.mysql.com/doc/internals/en/event-structure.html" target="_blank" rel="noopener">《Event Structure》</a></li><li><a href="https://dominicpoi.com/2019/06/16/MySQL-1/" target="_blank" rel="noopener">《MySQL为什么默认隔离级别为可重复读？》</a></li><li><a href="https://zhuanlan.zhihu.com/p/33504555" target="_blank" rel="noopener">《10分钟学会Mysql之Binlog》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;binlog是server层的日志，对于innodb来说，只有binlog写完后，才能提交redo log。binlog记录逻辑语句，只会记录写类似于sql的日志。binlog主要的作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;崩溃恢复&lt;/li&gt;
&lt;li&gt;主从复制&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>[Mysql]漫游redo log</title>
    <link href="https://htchz.cc/1559835943.html"/>
    <id>https://htchz.cc/1559835943.html</id>
    <published>2020-05-19T14:00:05.000Z</published>
    <updated>2020-06-05T09:01:05.959Z</updated>
    
    <content type="html"><![CDATA[<p>redo log负责记录物理数据页，所以无论执行多少次都是幂等的；而binlog是记录逻辑数据，执行多次就可能重复数据。</p><p>数据结构是一个<strong>环形数组</strong>，innodb将未写入磁盘的页叫做<strong>脏页</strong>，redo log的作用就是记录脏页的数据。</p><p>在宕机恢复时，一个事务是否持久化是根据redo log刷盘情况决定的。如果一个事务的redo log已经全部刷入磁盘，那么这个事务是有效的，反之需要根据undo log回滚。</p><p>redo log在硬盘中是分成多块来存储的，以<code>ib_logfile[number]</code>命名。</p><p>执行<code>SHOW GLOBAL VARIABLES LIKE &quot;innodb_log%&quot;;</code>，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----------------------------+-----------+</span></span><br><span class="line">| Variable_name               | Value     |</span><br><span class="line">+<span class="comment">-----------------------------+-----------+</span></span><br><span class="line">| innodb_log_buffer_size      | 67108864  |</span><br><span class="line">| innodb_log_checksums        | ON        |</span><br><span class="line">| innodb_log_compressed_pages | ON        |</span><br><span class="line">| innodb_log_file_size        | 536870912 |</span><br><span class="line">| innodb_log_files_in_group   | 4         |</span><br><span class="line">| innodb_log_group_home_dir   | ./        |</span><br><span class="line">| innodb_log_write_ahead_size | 8192      |</span><br><span class="line">+<span class="comment">-----------------------------+-----------+</span></span><br></pre></td></tr></table></figure><p><code>innodb_log_files_in_group</code>指定了redo log文件被分为几部分，每一部分的文件大小都是一样的，当写入ib_logfile3后，又继续写入ib_logfile0，如此循环。</p><p>这是在磁盘里的文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@dev_test63 mysql3306]#  ll ib*</span><br><span class="line">-rw-r----- 1 mysql mysql 683671552 5月  20 01:25 ibdata1</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  20 01:24 ib_logfile0</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  19 11:10 ib_logfile1</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  20 01:24 ib_logfile2</span><br><span class="line">-rw-r----- 1 mysql mysql 536870912 5月  20 01:25 ib_logfile3</span><br><span class="line">-rw-r----- 1 mysql mysql  79691776 5月  20 01:01 ibtmp1</span><br></pre></td></tr></table></figure><ul><li>ibtmp1是临时表空间，ibdata1是共享表空间。</li></ul><h1 id="为什么要有redo-log">1. 为什么要有redo log:</h1><ul><li>redo log是顺序写入的，而数据页落盘是随机存储。</li><li>延迟刷脏页可以起到合并多次修改的作用，mysql的最小存储单位是页，一个页有多行，如果每次修改一行就要更新整个页，并不是那么能接收。</li></ul><p>有了redo log之后，对于一行数据，首先更新<strong>buffer pool</strong>（在这之前还有undo log），然后再写入log buffer。</p><h1 id="组织结构">2. 组织结构</h1><p>由于redo记录的是物理变更，比如在“第100表空间第100页偏移量1024写入4个字节balabala”，而不是描述第几行改成什么样，一行记录变更涉及的物理页可能有很多，所以可能产生一条redo log，也有可能是多条redo log，这个和undo log不同。 </p><h2 id="redo-log">2.1. redo log</h2><p>这是一条redo log的通用结构<br><img src="../images/20200525182526.png" alt></p><ul><li>type：redo log的类型，可能是基础类型，也可能是复杂类型</li><li>Space ID：表空间id</li><li>page number：页号</li><li>data：redo log内容</li></ul><p>具体type的类型有很多，参考底部链接，其中包括undo log对应的redo log<code>MLOG_UNDO_INSERT</code>。一个操作产生的redo log可能是一个，也可能是一组redo log。</p><h2 id="log-block">2.2. log block</h2><p>组织redo log的是log block，一个log block是存储redo log的基本单位，和页有点类似。<br><img src="../images/20200526000820.png" alt></p><ul><li>log block header：存放block信息</li><li>log block body：存放多条redo log</li><li>log block trailer：存放block的校验值，用于正确性校验</li></ul><p>log buffer和log file都是以log block为基本操作单位，redo log在log block里顺序写入。<br><img src="../images/20200526001104.png" alt></p><h2 id="mtr">2.3. mtr</h2><p>Mini-Transaction，即mtr，</p><p>前面说到一个操作可能产生一组redo log，那么这组redo log是需要保证事务性的，innodb使用mtr这种比transaction更小粒度的事务，来保证一组redo的事务性。</p><p>mtr开启后，会定位到要修改的page的位置，对索引加锁；之后执行一系列写操作，期间产生的redo log会暂存在mtr对象中；mtr提交时，需要把暂存的redo log组放入log buffer中，然后把修改的脏页放入flush list，之后释放page的锁。</p><h1 id="刷盘策略">3. 刷盘策略</h1><p>这里有几个概念</p><ul><li>buffer pool：指在内存中的数据页，innodb需要把物流数据页读到内存中进行修改。</li><li>log buffer：指redo log的buffer，属于进程。</li><li>redo log file：指内存中的redo log文件，属于操作系统，待fsync到磁盘中。</li></ul><p>redo log刷盘时机如下：</p><ol><li>有事务提交时，根据<a href="#事务提交时的刷盘策略">事务提交时的刷盘策略</a>决定是否刷盘</li><li><code>innodb_flush_log_at_timeout</code>默认值为1，也就是1s内如果没发生刷盘，需要进行刷盘</li><li>当log buffer中已经使用的内存超过一半时</li><li>当到达checkpoint时</li></ol><h2 id="事务提交时的刷盘策略">3.1. 事务提交时的刷盘策略</h2><p><code>innodb_flush_log_at_trx_commit</code>指定了redo log的事务提交刷盘策略，分别三个值<br>0：每次提交事务，不会将log buffer写入redo log file，而是由master thread每秒将log buffer写入redo log file，并调用fsync落盘<br>1：每次提交事务，将log buffer写入redo log file，<strong>同时</strong>调用fsync落盘，是<strong>最严格</strong>也是性能<strong>最差</strong>的策略<br>2: 每次提交事务，将log buffer写入redo log file，<strong>每秒</strong>调用fsync落盘</p><p>0和2看起来有点相似。区别在于，前者没有将log buffer同步写入redo log file，要知道redo log file是文件，所以0没同步写入文件，性能会比2高，但mysql崩溃时，会丢失日志；而2同步写入文件，已经将日志提交到操作系统了，只有操作系统宕机了才会丢失日志。</p><p>我们线上数据库<code>innodb_flush_log_at_trx_commit</code>的值是1，有一次同事清理数据时做了个全表更新，redo log疯狂刷盘，从而导致数据库缓慢，于是运维关闭了双1（<code>innodb_flush_log_at_trx_commit</code>和<code>sync_binlog</code>），暂停了清理脚本，才得以恢复。</p><h1 id="LSN">4. LSN</h1><p>Log sequence number是一个8字节的不断增长的数字，表示日志编号，起到一个类似版本的作用，很多地方都有这个LSN，最终需要这n个地方的LSN达到一致。</p><p>通过LSN可以获得：</p><ol><li>数据页的版本信息。</li><li>写入的日志总量，通过LSN开始号码和结束号码可以计算出写入的日志量。</li><li>可知道检查点的位置。</li></ol><p>执行<code>SHOW ENGINE INNODB STATUS;</code>可以看到和LSN有关的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">LOG</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">Log sequence number 1509428892</span><br><span class="line">Log flushed up to   1509428892</span><br><span class="line">Pages flushed up to 1509300590</span><br><span class="line">Last checkpoint at  1509300581</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">3554874 log i/o's done, 0.00 log i/o's/second</span><br></pre></td></tr></table></figure><p><strong>Log sequence number</strong>是redo log buffer的LSN<br><strong>log flushed up to</strong>是刷到redo log file在硬盘中的LSN；<br><strong>pages flushed up to</strong>是已经刷到磁盘数据页上的LSN<br><strong>last checkpoint at</strong>是上一次检查点所在位置的LSN</p><p>可以看到LSN不是完全一致，测试环境db是空闲的，<strong>Log sequence number</strong>和<strong>log flushed up to</strong>是相同的，<strong>pages flushed up to</strong>落后，这是因为脏页很少的话可以暂时不刷到磁盘。</p><p>一般来说，log sequence number &gt; log flushed up to 和 pages flushed up to &gt; last checkpoint at</p><p>可能会出现数据页刷盘快于redo log刷盘的情况，这时checkpoint是有机制保护数据慢于日志，所以会暂停数据页刷盘，等待日志刷盘进度超过数据刷盘。</p><p>由于记录物理数据页，如果在一个事务里把a更新成b，又把b更新为a，会不会保存到redo log里的？</p><p>试验过后，执行<code>SHOW ENGINE INNODB STATUS\G</code>，可以看到<code>Log sequence number</code>有增加；</p><h1 id="checkpoint">5. checkpoint</h1><p>由于redo log相当于给数据页做了个备份，所以事务提交时并不一定要把数据页落盘。但是：1：buffer pool是有限的，2：redo log buffer是有限的。<br>所以需要一个时机，将buffer pool里的数据落盘，同时清除redo log buffer里已经落盘的数据页，这个时机就是checkpoint。数据库重启后的恢复，只需要从checkpoint lsn算起，checkpoint lsn之前的数据都是认为已经持久化的。</p><p>checkpoint的目的很简单，即把数据页落盘，但是什么时候、刷多少页到磁盘、从哪里取脏页都有些不同。</p><p><strong>checkpoint_lsn</strong>是指checkpoint发生刷盘之后，记录此次checkpoint的lsn到redo log file的第一个文件头可以理解为管理数据页缓冲的数据结构，需要保证<br>FLUSH列表：LRU的<br>有两种Checkpoint，分别为：Sharp Checkpoint、Fuzzy Checkpoint。</p><p><strong>Sharp Checkpoint</strong>是全部刷盘，发生在切换redo log文件或者数据库关闭的时候，需要把buffer pool的数据页全刷盘。</p><blockquote><p>MySQL停止时是否将脏数据和脏日志刷入磁盘，由变量<code>innodb_fast_shutdown={ 0|1|2 }</code>控制，默认值为1，即停止时忽略所有flush操作，在下次启动的时候再flush，实现fast shutdown。</p></blockquote><p><strong>Fuzzy Checkpoint</strong>是部分刷盘，分为四种。</p><h2 id="master-thread-checkpoint">5.1. master thread checkpoint</h2><p>由master线程控制，每1秒，每10秒刷入一定比例的脏页到磁盘，异步。</p><h2 id="flush-lru-list-checkpoint">5.2. flush_lru_list checkpoint</h2><p>从MySQL5.6开始可通过<code>innodb_page_cleaners</code>变量指定专门负责脏页刷盘的<strong>page cleaner</strong>线程的个数，该线程的目的是为了保证lru_list表有可用的空闲页。</p><h2 id="async-sync-flush-checkpoint：">5.3. async/sync flush checkpoint：</h2><p>同步刷盘/异步刷盘。例如还有非常多的脏页没刷到磁盘(非常多是多少，有比例控制)，这时候会选择同步刷到磁盘，但这很少出现；如果脏页不是很多，可以选择异步刷到磁盘，如果脏页很少，可以暂时不刷脏页到磁盘。</p><p>这里有四个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_files_in_group=4</span><br><span class="line">innodb_log_file_size=4G</span><br><span class="line">总文件大小: 17179869184</span><br><span class="line"></span><br><span class="line">log_sys-&gt;max_modified_age_async = 12175607164 (71%)</span><br><span class="line">log_sys-&gt;max_modified_age_sync = 13045293390 (76%)</span><br><span class="line">log_sys-&gt;max_checkpoint_age_async = 13480136503 (78%)</span><br><span class="line">log_sys-&gt;max_checkpoint_age = 13914979615 (81%)</span><br></pre></td></tr></table></figure><p>设，checkpoint_age = log_lsn - last_checkpoint_lsn，max_modified_age = log_lsn - 脏页最小lsn</p><p>当max_modified_age &gt; max_modified_age_asyncs，需要flush_list取出脏页，异步刷盘<br>当max_modified_age &gt; max_modified_age_sync，需要flush_list取出脏页，同步刷盘</p><p>当checkpoint_age &gt; max_checkpoint_age_async，可以无需等待checkpoint完成<br>当checkpoint_age &gt; max_checkpoint_age，需要同步等待checkpoint完成</p><h2 id="dirty-page-too-much-checkpoint">5.4. dirty page too much checkpoint</h2><p>脏页太多时强制触发检查点，目的是为了保证缓存有足够的空闲空间。脏页比例由变量 innodb_max_dirty_pages_pct 控制，MySQL 5.6默认的值为75，即当脏页占缓冲池的75%后，就强制刷一部分脏页到磁盘。</p><p>关于上面提到的列表：</p><p>lru_list：是一个使用了最近最少使用算法的列表，可以理解为管理数据页缓冲的数据结构。<br>flush_list：lru的的脏页会放进这个列表，但是不会从lru移除，所以脏页会存在两个地方。flush_list里的脏页会根据lsn最为排序依据，保证lsn小的先落盘。<br>free_list：free_list如果没有空闲页可以分配，就会从lru_list批量淘汰数据页以供使用。</p><h1 id="redo-log太大和太小">6. redo log太大和太小</h1><p>可以看到，<strong>async/sync flush checkpoint</strong>这种类型的checkpoint其实是和log_file的大小有关的。如果log_file小了，会使checkpoint变多，影响innodb性能；如果log_file大了，两次checkpoint跨度大，在恢复的时候<strong>可能</strong>就会等待太久（挂了跑路吧😄）。</p><p>具体多大应该结合实际测试。</p><h1 id="两阶段提交-崩溃恢复">7. 两阶段提交 崩溃恢复</h1><p>另外讲。</p><h1 id="参考">8. 参考</h1><ol><li><a href="https://juejin.im/entry/5ba0a254e51d450e735e4a1f" target="_blank" rel="noopener">《详细分析MySQL事务日志(redo log和undo log)》</a></li><li><a href="https://www.cnblogs.com/gomysql/p/3721478.html" target="_blank" rel="noopener">《InnoDB log file 设置多大合适？》</a></li><li><a href="http://www.yunweipai.com/archives/15563.html" target="_blank" rel="noopener">《MySQL运维内参》节选 | InnoDB日志管理机制（五）</a></li><li><a href="https://www.jianshu.com/p/fdae2e30b9fa" target="_blank" rel="noopener">《Redo Log——第一篇》</a></li><li><a href="http://mysql.taobao.org/monthly/2015/05/01/" target="_blank" rel="noopener">《MySQL · 引擎特性 · InnoDB redo log漫游》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redo log负责记录物理数据页，所以无论执行多少次都是幂等的；而binlog是记录逻辑数据，执行多次就可能重复数据。&lt;/p&gt;
&lt;p&gt;数据结构是一个&lt;strong&gt;环形数组&lt;/strong&gt;，innodb将未写入磁盘的页叫做&lt;strong&gt;脏页&lt;/strong&gt;，redo
      
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>[Mysql]漫游undo log</title>
    <link href="https://htchz.cc/1791523990.html"/>
    <id>https://htchz.cc/1791523990.html</id>
    <published>2020-05-10T01:51:00.000Z</published>
    <updated>2020-06-05T09:00:41.138Z</updated>
    
    <content type="html"><![CDATA[<p>Innodb学会是不可能学会的，这辈子都学不会的。</p><a id="more"></a><p>innodb是一个<strong>日志先行</strong>（Write-ahead logging）的存储引擎，这也是大部分关系型数据库的特点。而像redis这样的nosql就是数据为先，再进行落盘。</p><p>undo log和redo log和binlog，这三个log是mysql及innodb的关键。这三种日志都会刷盘，其中：</p><ul><li>undo log: 事务原子性和多版本控制MVCC（事务隔离）</li><li>redo log: 事务持久性，宕机恢复</li><li>binlog: 宕机恢复，主从同步</li></ul><p>可以看出三个日志在对应功能上需要相互协作。undo log和redo log是事务日志；redo log要等binlog写入成功才能commit；undo Log保证事务的原子性，redo log保证事务的持久性。</p><p>网上大多都是讲undo log能做什么，但没几篇讲清楚undo log组织结构。innodb最小存储粒度是页<code>page</code>，而页就分为<code>FIL_PAGE_INDEX</code>索引页（索引即数据）和<code>FIL_PAGE_UNDO_LOG</code>undo页。</p><p>部分概念是关于MVCC的，需要配合<a href="./3647734067.html#undo-log">[Mysql]Innodb的快照读实现</a>食用，本文不做讨论。</p><p>undo log就是个历史版本，落盘后不和redo log存在一起。</p><h1 id="表空间">1. 表空间</h1><p>InnoDB存储引擎提供二种数据库表的存储方式</p><ol><li>系统表空间：所有数据上放在一起，物理文件可以拆成多个文件。</li><li>独占表空间：每个表有自己的物理文件，性能更好。</li></ol><p>关于更多不在讨论范围。</p><h1 id="结构层次">2. 结构层次</h1><p>Rollback Segment（rseg）称为回滚段。Mysql5.6之前undo默认记录到系统表空间（ibdata），如果开启了 innodb_file_per_table ，将放在每个表的.ibd文件中。5.6之后还可以创建独立的undo表空间，8之后更是默认打开独立undo表空间，最低数量为2，这样才能保证至少一个undo表空间进行truncate，一个undo表空间继续使用。独立undo表空间的文件格式是undo001，undo002……</p><p>每个rollback Segment中默认有1024个undo log segment，mysql5.5后<strong>1个</strong>undo表空间支持<strong>128个</strong>rollback Segment。0号rollback Segment默认在系统表空间ibdata中，1-32rollback Segment在临时表空间，33～128在独立undo表空间中（没有打开则在系统表空间ibdata中，这样系统表空间会太大），所以<strong>1个</strong>表空间<strong>最多</strong>支持<strong>96*1024</strong>个事务，超了就报错啦。</p><p>一个undo log segment称为undo log或undo slot或undo；一个undo log对象对应多个undo log record，也就是记录的历史版本。</p><p>一个undo log segment有一个page链表，undo log record就是放在page中的，当一个page不足以放下新的undo log record时，会分配新的page，放到链表尾部。</p><p>一个undo log segment其实是一个页叫<code>undo log header page</code>，有INSERT/UPDATE两个类型。这个页有一项内容<code>TRX_UNDO_PAGE_LIST</code>是一个链表，即undo page链表。</p><p><img src="../images/20200510231756.png" alt></p><p>简单来说，结构是这样的：</p><ul><li>rollback segments(128)<ul><li>undo log segments(1024)<ul><li>undo page(N）<ul><li>undo record</li><li>undo record</li><li>…</li></ul></li></ul></li></ul></li></ul><blockquote><p>A collection of undo logs. Undo log segments exists within rollback segments. An undo log segment might contain undo logs from multiple transactions. An undo log segment can only be used by one transaction at a time but can be reused after it is released at transaction commit or rollback——<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log_segment" target="_blank" rel="noopener">mysql#undo_log_segment</a> </p></blockquote><p>一个rollback Segment可以被多个事务使用。而一个undo log segment只能被一个事务占有。由于undo log segment区分插入和更新，又区分临时表和普通表，所以一个事务至多占有<strong>四</strong>个undo log segment。</p><h2 id="头">2.1. 头</h2><p><img src="../images/20200510231756.png" alt><br>这张图里，</p><ul><li>Undo Log Segment Header：是undo log的第一页，不存放record</li><li>undo log header：图里<code>Undo Log Segment Header</code>的<code>TRX_UNDO_LAST_LOG</code>属性指向了一个undo page，每一个undo page都有undo log header描述这个undo page的信息。</li><li>undo page header：图里没有，这个header类似于数据页的page header。</li></ul><h1 id="写undo-log过程">3. 写undo log过程</h1><h2 id="分配回滚段">3.1. 分配回滚段</h2><p>当读写事务开启或只读事务转化为读写事务时，会为一个事务分配事务id和一个回滚段（只读事务的id是0）。</p><p>分配逻辑：</p><ol><li>轮询（环形缓冲，同redo log）选取一个可用的回滚段；</li><li>选取的回滚段引用计数+1（多对一），防止被回收（truncate）。</li><li>临时表使用临时表回滚段，特点是不用写redo log，普通表使用的普通回滚段需要写redo log。</li></ol><h2 id="使用回滚段">3.2. 使用回滚段</h2><p>数据变更时，insert和update分别写相似但不同的undo log。</p><ol><li>临时表不用写redo log</li><li>操作时未分配undo log statement，则对变更类型分配对应的undo log statement</li><li>分配undo log statement时，如果缓存列表有可用的undo log statement，取出来使用。</li></ol><p>redo log有许多种类型，这里是一种type为<code>MLOG_UNDO_INSERT</code>的日志，保证undo log是有效的。</p><h2 id="写入undo-log">3.3. 写入undo log</h2><p>insert的undo record长这样<br><img src="../images/20200510183601.png" alt></p><ul><li>type_cmpl：undo log类型，purge时用</li><li>undo no：事务编号</li><li>table id：表id</li></ul><p>update的undo record长这样<br><img src="../images/20200510185016.png" alt></p><ul><li>DATA_ROLL_PTR：该行对应的前一个历史版本的指针，从而构建一个历史版本的链表</li><li>type_cmpl：undo log类型，辅助purge线程清理</li><li>(posN,lenN,u_old_colN)[]：字段旧值，只需要记录被更新的字段</li><li>(pos,len,colN)[]：被更新的二级索引，回滚的时候需要</li><li>undo no：事务编号</li><li>table id：表id</li></ul><p>事务no和事务id还是有些不同的，事务编号是用来排序的，在事务提交之前通过全局计数器生成，目的是为了放入histroy list有序，方便purge清理。</p><p>不同类型的undo record下有些属性没有，例如索引没变化的情况下，<code>(pos,len,colN)[]</code>就没记录。</p><p>(其实我不知道记unique key干嘛的)</p><h2 id="undo-log类型">3.4. undo log类型</h2><p>purge线程在对待undo log时，会根据undo log的类型做不同的动作，下面分为三类，括号里是动作</p><ul><li>插入：<ul><li>TRX_UNDO_INSERT_REC：表示新增记录（主键记入日志）</li><li>TRX_UNDO_UPD_DEL_REC：当表中有一条被标记为删除的记录和要插入的数据主键相同时，实际是更新这条被标记删除的记录。（主键记入日志）</li></ul></li><li>更新：<ul><li>TRX_UNDO_UPD_EXIST_REC：（将主键和被更新了的字段内容记入日志）</li></ul></li><li>删除：<ul><li>TRX_UNDO_DEL_MARK_REC：（主键记入日志）标记删除</li></ul></li></ul><h2 id="插入">3.5. 插入</h2><p>插入时构建的undo log，包括undo类型，undo no，table id，主键各列信息。</p><p>insert undo log在事务提交后就会被删除。</p><h2 id="更新">3.6. 更新</h2><p>更新时构建的undo log，包括undo类型，undo no，table id，主键各列信息，data_trx_id、data_roll_pointer，被更新的二级索引，n_updated，字段旧值。</p><p>MVCC那篇讲过，每行记录都有三个隐藏字段，所以记录的<code>old_trx_id</code>、<code>old_roll_pointer</code>会被记入undo log，old trx_id表示修改的事务id，old_roll_pointer指向前一个undo record。</p><p>如果要更新一行记录的主键，需要删除记录（delete_mark置1，不能同步删除，为了MVCC），再插入新记录，所以会有<code>TRX_UNDO_DEL_MARK_REC</code>和<code>TRX_UNDO_INSERT_REC</code>两条日志。</p><p>对于二级索引的更新都是删除+插入。</p><p>如果更新一行前后的存储空间不一样大，也需要删除（同步删除）再插入。</p><h2 id="删除">3.7. 删除</h2><p>删除一条记录，其实分两个阶段，</p><ol><li>prepare阶段：将delete标志位置1，构造undo log</li><li>purge阶段：这个发生在事务提交后，将记录移动到垃圾链表，等待复用。</li></ol><p>垃圾链表是指数据页上的一个属性<code>PAGE_FREE</code>，指向一个链表的头节点，可以参阅文章底部的链接。</p><p>删除属于更新，所以他们的undo log是同一个数据结构，不过删除类型的undo log少了n_updated和字段旧值，以及被更新的二级索引。</p><h2 id="事务prepare">3.8. 事务prepare</h2><p>事务开始的阶段，需要将undo log header page的事务状态<code>TRX_UNDO_STATE</code>设置为<code>TRX_UNDO_PREPARED</code><br><img src="../images/20200512183520.png" alt></p><h2 id="事务提交">3.9. 事务提交</h2><p>先说一下history list，<code>show engine innodb status</code>执行这个命令我们可以看到history list</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">TRANSACTIONS</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">Trx id counter 2915975770</span><br><span class="line"><span class="keyword">Purge</span> done <span class="keyword">for</span> trx<span class="string">'s n:o &lt; 2915975770 undo n:o &lt; 0 state: running but idle</span></span><br><span class="line"><span class="string">History list length 47</span></span><br><span class="line"><span class="string">LIST OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="string">---TRANSACTION 421366361910208, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421366361903824, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1136, 0 row lock(s)</span></span><br></pre></td></tr></table></figure><p>这个值表示还有多少undo log没被清理，这个值太大的话，说明有undo log由于有大事务存在而无法被清理。</p><p><code>Undo Log Segment Header</code>有个<code>TRX_UNDO_STATE</code>，事务提交时，<code>TRX_UNDO_STATE</code>有三种值，</p><ul><li>如果当前的undo log只占一个page，且占用大小使用不足其3/4时(TRX_UNDO_PAGE_REUSE_LIMIT)，则状态设置为<code>TRX_UNDO_CACHED</code>，该undo对象会随后加入到undo cache list上；</li><li>如果事务类型是<code>TRX_UNDO_INSERT_REC</code>，则状态设置为<code>TRX_UNDO_TO_FREE</code></li><li>如果不满足上面的，就需要purge线程去清理，状态设置为<code>TRX_UNDO_TO_PURGE</code></li></ul><p>对于<strong>update undo</strong>对象需要放入<strong>history list</strong>上，具体是将当前undo加入到回滚段header的TRX_RSEG_HISTORY链表上。</p><p>如果<strong>update undo</strong>只有普通表，则给<strong>History list length</strong>+1，如果还有临时表，则+2，然后唤醒purge线程。</p><p>如果<strong>update undo</strong>需要缓存，则放入回滚段的update_undo_cached链表上；否则释放undo对象内存。</p><p>对于<strong>insert undo</strong>在事务释放锁、从读写事务链表清除、关闭read view后才进行，也就是等所有后事都办完才清理。</p><p>如果<strong>insert undo</strong>需要缓存，则放入回滚段的insert_undo_cached链表上；否则释放undo对象内存。和<strong>update undo</strong>不同的是，<strong>insert undo</strong>不需要放入hisotry list。</p><p>事务提交后，回滚段的引用计数-1。</p><p>tip1：由于cache的原因，即使db空闲中，history list的长度一般都不会是0。<br>tip2：insert undo的重用是直接reset，而update undo的重用是会和上一个事务的undo page共存的，具体是undo page上的undo log header有<code>TRX_UNDO_NEXT_LOG</code> 和<code>TRX_UNDO_PREV_LOG</code>来表示事务在页面中的偏移量的</p><h2 id="清理-purge">3.10. 清理 purge</h2><p>purge发生在事务commit时。update undo会被放入history list中，当没有活跃的事务作用于undo log时，会被purge线程清理。如何判断有没有活跃的事务作用于undo log?innodb会快克隆一个活跃的最老的read view，所有在这个read view之前的undo log都是可以清理的。</p><p>purge线程从history list批量取到undo log后，对于in-place更新，需要看需不需要清理二级索引；对于删除操作，需要将删除记录放入数据页垃圾链表<code>PAGE_FREE</code>中。</p><h2 id="回滚">3.11. 回滚</h2><p>事务回滚只需要拿到undo log的进行逆向操作就可以了。</p><p>对于标记删除的记录清理delete_mark；对于更新，将数据回滚到最老版本，回滚索引；对于插入操作，直接删除聚集索引（后）和二级索引（先）。</p><h2 id="持久化">3.12. 持久化</h2><p>todo</p><h2 id="崩溃恢复">3.13. 崩溃恢复</h2><p>其他篇。</p><h1 id="后记">4. 后记</h1><p>由于insert和update的种种区别，以至于undo log segment需要分成两种。</p><h1 id="参考">5. 参考</h1><ol><li><a href="http://mysql.taobao.org/monthly/2015/04/01/" target="_blank" rel="noopener">《MySQL · 引擎特性 · InnoDB undo log 漫游》</a></li><li><a href="https://www.kancloud.cn/digest/innodb-zerok/195091" target="_blank" rel="noopener">《innodb源码分析之page结构解析》</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html" target="_blank" rel="noopener">《MySQL 5.7 Reference Manual 14.6.7 Undo Logs》</a></li><li><a href="https://jimmy2angel.github.io/2019/05/07/InnoDB-undo-log/" target="_blank" rel="noopener">《InnoDB undo log》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Innodb学会是不可能学会的，这辈子都学不会的。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>[网络]端口转发</title>
    <link href="https://htchz.cc/2735588161.html"/>
    <id>https://htchz.cc/2735588161.html</id>
    <published>2020-05-01T15:53:39.000Z</published>
    <updated>2020-07-07T07:03:07.209Z</updated>
    
    <content type="html"><![CDATA[<p>之前买的GGC家的HK vps，从去年开始电信访问一直丢包，丢包率一上去，带宽再大速度也是提不上去（<a href="./3284953854.html">[网络]TCP拥塞控制那些事</a>）。</p><p>于是想到买个nat机中转一下流量。</p><p><img src="../images/20200502003159.png" alt><br>(2核384内存，适合用来中转流量)</p><p><img src="../images/20200502000957.png" alt></p><h1 id="iptables端口转发">1. iptables端口转发</h1><p>nat到手后，机器镜像用的是centos7，关闭firewall，把iptables装上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 firewalld</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld --now</span><br><span class="line"><span class="comment"># 装iptables</span></span><br><span class="line">yum install iptables-services</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service --now</span><br></pre></td></tr></table></figure><p>接着开启ipv4转发，默认iptables是关闭ipv4转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时开启 ipv4 转发</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="comment"># 永久开启 ipv4 转发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'net.ipv4.ip_forward = 1'</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>接着是加iptables规则，需要在nat表加入一条DNAT和一条SNAT，DNAT是修改目的地址，转发流量到HK vps；SNAT是修改源地址，保证流量回到这台机上（只有这台机知道怎么回到我家）。</p><p>假设NAT机监听<code>10086</code>端口，HK vps的ip是<code>104.104.104.104</code>，ss服务端口是<code>10010</code>，NAT机内网地址是<code>192.168.1.10</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DNAT</span></span><br><span class="line">iptables -t nat -A PREROUTING -p  tcp -m tcp --dport 10086 -j DNAT --to-destination 104.104.104.104:10010</span><br><span class="line"><span class="comment"># SNAT，--to-source ip[:port] port可以不指定，会是随机的</span></span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -m tcp -d 104.104.104.104 --dport 10010  -j SNAT --to-source 192.168.1.10</span><br><span class="line"><span class="comment"># 应用iptables</span></span><br><span class="line">service iptables save</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="comment"># 看下nat表</span></span><br><span class="line">iptables -nL -t nat</span><br></pre></td></tr></table></figure><p>此外，nat机要开放<strong>10086</strong>端口。</p><p>最后一步，在nat控制面板的<strong>NAT转发策略</strong>创建策略，创建一个映射到该机器10086的策略，就能拿到公网ip和端口了。</p><p><img src="../images/20200502002852.png" alt></p><h1 id="firewall端口转发">2. firewall端口转发</h1><p>firewall的会简单一些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许防火墙伪装IP</span></span><br><span class="line">firewall-cmd --add-masquerade --permanent</span><br><span class="line"><span class="comment"># 检查是否允许伪装IP</span></span><br><span class="line">firewall-cmd --query-masquerade </span><br><span class="line"><span class="comment"># 添加转发规则</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-forward-port=port=10086:proto=tcp:toport=10010:toaddr=104.104.104.104</span><br><span class="line"><span class="comment"># 开放监听端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=10086/tcp --permanent</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前买的GGC家的HK vps，从去年开始电信访问一直丢包，丢包率一上去，带宽再大速度也是提不上去（&lt;a href=&quot;./3284953854.html&quot;&gt;[网络]TCP拥塞控制那些事&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;于是想到买个nat机中转一下流量。&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="https://htchz.cc/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]JVM中三色标记法</title>
    <link href="https://htchz.cc/2394647798.html"/>
    <id>https://htchz.cc/2394647798.html</id>
    <published>2020-03-17T14:53:15.000Z</published>
    <updated>2020-04-02T08:07:09.175Z</updated>
    
    <content type="html"><![CDATA[<p>三色标记算法是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。对象分成三种类型:</p><ul><li>黑色:根对象，或者该对象与它的子对象都被扫描</li><li>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><p>根对象被置为黑色，子对象被置为灰色。<br><img src="/images/pasted-115.png" alt="upload successful"><br>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p><p><img src="/images/pasted-116.png" alt="upload successful"><br>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。<br><img src="/images/pasted-117.png" alt="upload successful"><br>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p><p>我们看下面一种情况，当垃圾收集器扫描到下面情况时：<br><img src="/images/pasted-118.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.c=C</span><br><span class="line">B.c=null</span><br></pre></td></tr></table></figure><p>这样，对象的状态图变成如下情形：<br><img src="/images/pasted-119.png" alt="upload successful"><br>这时候垃圾收集器再标记扫描的时候就会下图成这样：<br><img src="/images/pasted-120.png" alt="upload successful"></p><p>显然，C是白色的，也就是漏标了，会被当成垃圾回收掉，这对程序来说是不可以接受的。</p><p>漏标的情况只会发生在白色对象中，且满足以下任意一个条件：</p><ol><li>并发标记时，应用线程给一个黑色对象的引用类型字段赋值了该白色对象</li><li>并发标记时，应用线程删除所有灰色对象到该白色对象的引用</li></ol><p>事实上，方法1是CMS的实现关键，方法2是G1的实现关键，有关实现就移步<a href="./4242301031.html">[JVM]CMS</a>和<a href="./2687941502.html">[JVM]G1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三色标记算法是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。对象分成三种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑色:根对象，或者该对象与它的子对象都被扫描&lt;/li&gt;
&lt;li&gt;灰色:对象本身被扫描,但还没扫描完该对象中的子对象&lt;/li&gt;
&lt;li&gt;白色:未被扫描对
      
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="https://htchz.cc/tags/JVM/"/>
    
      <category term="GC" scheme="https://htchz.cc/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]内存模型</title>
    <link href="https://htchz.cc/93872510.html"/>
    <id>https://htchz.cc/93872510.html</id>
    <published>2020-03-17T06:28:45.000Z</published>
    <updated>2020-06-15T03:57:27.881Z</updated>
    
    <content type="html"><![CDATA[<p>补个内存模型笔记。</p><a id="more"></a><p>JVM 内存共分为虚拟机栈、堆、方法区（jdk8是元空间，在jvm之外）、PC寄存器（程序计数器）、本地方法栈五个部分。<br><img src="../images/20200317143112.png" alt><br>这是jdk7的实现，方法区其实就是永久代。<br><img src="../images/20200615115524.png" alt><br>这是jdk8的实现，永久代废除，将类信息放到本地内存中，也就是放在jvm外。</p><h1 id="虚拟机栈">1. 虚拟机栈</h1><p>线程私有。一个线程一个虚拟机栈</p><p>一个栈里有多个帧，栈帧包含局部变量表、操作数栈、动态链接、方法出口等。线程调用方法时会创建栈帧入栈，结束方法时会出栈。</p><p>栈深度超过限制会<code>StackOverflowError</code>，栈帧申请时内存不足会报<code>OutOfMemoryError</code>。</p><h2 id="局部变量表">1.1. 局部变量表</h2><p>用于存放局部变量和方法参数的引用，使用<strong>索引</strong>进行访问。</p><p>这个表的组成单位是slot，32位的jvm会使用32位的slot，这也就是为什么<strong>long</strong>/<strong>double</strong>在32jvm不是线程安全的。</p><blockquote><p>被虚拟机栈引用的对象，属于GCROOT，不会回收。如果一个方法很长，但是一个大对象不再被使用，可以设置为将大对象的变量赋值为null来帮助gc。（长方法你就该优化一下了）</p></blockquote><h2 id="操作数栈">1.2. 操作数栈</h2><p>也是存放基本数据类型或引用的，只能进行<strong>出栈/压栈</strong>，使用场景如发起方法调用的时候放参数，算术运算的中间值</p><h2 id="动态链接">1.3. 动态链接</h2><p>一个引用，指向方法区的方法，由于java多态特性，编译后大多数不能确定哪个方法的调用，只能在运行时才能将符号引用转换为直接引用。</p><h2 id="方法返回值">1.4. 方法返回值</h2><p>如果方法是正常退出（没有异常）且有返回值，调用方需要从这里取到返回值，并在栈帧的操作数栈进行压栈。</p><h1 id="PC寄存器（程序计数器）">2. PC寄存器（程序计数器）</h1><p>线程私有。一个线程一个PC寄存器，也叫程序计数器。</p><p>PC寄存器存放了线程当前执行的指令的地址，用于上下文切换后恢复线程上下文。</p><p>如果当前执行的是<strong>native</strong>方法，那么PC寄存器为空。</p><h1 id="本地方法栈">3. 本地方法栈</h1><p>线程私有。一个线程一个本地方法栈。</p><p>类似于<strong>虚拟机栈</strong>，只不过表示的是<strong>native</strong>方法。</p><p>栈深度超过限制会<code>StackOverflowError</code>，栈帧申请时内存不足会报<code>OutOfMemoryError</code>。</p><h1 id="堆">4. 堆</h1><p>线程共享。GC区域。</p><h1 id="方法区-元空间">5. 方法区(元空间)</h1><p>线程共享。主要用于存储类的信息、常量池、静态变量、及时编译器编译后的代码等数据。方法区逻辑上属于堆内存。这就给gc带来了负担，因为这些基本都是不变的对象。</p><p>jdk8将这部分挪到堆外内存，称为元空间（Metaspace）</p><h2 id="方法区，元空间与永久代">5.1. 方法区，元空间与永久代</h2><p><strong>方法区</strong>是jvm规范，Hotspot以前用<strong>永久代</strong>实现，放在了堆内存里。jdk8完全废除了<strong>永久代</strong>，将这些数据放到了<strong>本地内存</strong>。</p><p>主要原因是:</p><ol><li>常量存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。比如jsp生成动态类，这是比较难预测的。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低，毕竟这些东西是一直不变的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补个内存模型笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="https://htchz.cc/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[k8s]istio自动注入失败</title>
    <link href="https://htchz.cc/855478903.html"/>
    <id>https://htchz.cc/855478903.html</id>
    <published>2020-02-26T16:05:20.000Z</published>
    <updated>2020-02-26T17:25:53.347Z</updated>
    
    <content type="html"><![CDATA[<p>查了我一天喵的</p><a id="more"></a><h1 id="过程">1. 过程</h1><p>istio两种注入模式，一种是执行<code>istioctl kube-inject</code>将目标<code>deployment</code>的yaml先修改，也就是手动注入<code>sidecar</code>和<code>initContainer</code>，另一种就是在<code>pod</code>被部署的时候，利用k8s的<code>webhook</code>机制，进行自动注入。</p><p>在自动注入前，要在部署容器的<code>namespace</code>打上<code>istio-injection: enabled</code>标签，这样才会自动注入，同时，还可以指定<code>template</code>的注解:<code>sidecar.istio.io/inject: true</code>来做更小粒度的控制。</p><p>在使用<code>bookinfo</code>的demo过程中，自动注入并没有生效，甚至连<code>pod</code>都没有<code>create</code>。</p><p>执行<code>kubectl describe deployment productpage</code>查看其中一个<code>deployment</code>，发现只有一个事件， <code>Scaled up replica set productpage-v1-596598f447 to 1</code>，然后就没有然后了。</p><p>执行<code>kubectl describe replicaset productpage-v1-596598f447</code>，显示<strong>failed calling webhook “sidecar-injector.istio.io”: Post <a href="https://istio-sidecar-injector.istio-system.svc:443/inject?timeout=30s" target="_blank" rel="noopener">https://istio-sidecar-injector.istio-system.svc:443/inject?timeout=30s</a>: context deadline exceeded`</strong>，</p><p>查看<code>apiserver</code>的日志，一直提示</p><pre><code>&quot;sidecar-injector.istio.io&quot;: Post https://istio-sidecar-injector.istio-system.svc:443/inject?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</code></pre><p>查看<code>controller-manager</code>的日志，一直提示</p><pre><code>Event(v1.ObjectReference{Kind:&quot;HorizontalPodAutoscaler&quot;, Namespace:&quot;istio-system&quot;, Name:&quot;istio-telemetry&quot;, UID:&quot;da322eac-127a-4c78-89e6-db614d697949&quot;, APIVersion:&quot;autoscaling/v2beta2&quot;, ResourceVersion:&quot;10847941&quot;, FieldPath:&quot;&quot;}): type: &apos;Warning&apos; reason: &apos;FailedComputeMetricsReplicas&apos; invalid metrics (1 invalid out of 1), first error is: failed to get cpu utilization: unable to get metrics for resource cpu: no metrics returned from resource metrics API</code></pre><p>看起来是在说找不到<strong>metrics api</strong>？</p><p>上官网，<a href="https://istio.io/docs/ops/common-problems/injection/" target="_blank" rel="noopener">Istio / Sidecar Injection Problems</a>没有一个描述是符合的。github issue也没有提到要安装<code>metrics-server</code>。</p><p>最后找到一篇<a href="https://www.yp14.cn/2019/12/12/Istio%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5sidecar%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">博客</a>，里面提到</p><p><img src="../images/20200227005407.png" alt><br>于是乖乖安装<code>metrics-server</code>，然后注入<code>sidecar</code>的<code>pod</code>就成功创建了 = = 其实一早就看到关于<strong>metrics api</strong>的报错，但是我认为那是收集监控数据的，于是没鸟他，还是图样了。</p><h1 id="demo">2. demo</h1><p><img src="../images/20200227012503.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查了我一天喵的&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://htchz.cc/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://htchz.cc/tags/k8s/"/>
    
      <category term="istio" scheme="https://htchz.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>[Java代理]Spring的cglib与final方法的坑</title>
    <link href="https://htchz.cc/4249712641.html"/>
    <id>https://htchz.cc/4249712641.html</id>
    <published>2020-01-12T05:51:39.000Z</published>
    <updated>2020-07-01T12:23:51.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>cglib是采用生成目标类subclass方式来代理目标类的，所以如果目标类的方法是<code>final</code>的话，就会直接调用目标类的方法。Spring的cglib代理实现有点坑，就是生成的代理对象是没有调用父类构造函数的，这个代理对象的成员变量不会初始化。</p><h1 id="null">2. null</h1><p>Spring的aop是基于代理的，而采用cglib的实现下，对于一个bean，假设只代理一次的情况下（增强一次），内存实际是有两个对象，一个代理对象，一个目标对象。当我们调用代理对象的非fianl方法，代理对象调用完切面逻辑，不是调用自己父类方法，而是调用目标对象的目标方法；如果调用代理对象的final方法，代理对象会直接调用目标方法。</p><p>看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRunner</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm &#123;&#125;"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">·</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        objects[<span class="number">0</span>] = <span class="string">"hijacked!"</span>;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxy</span><span class="params">(Class klass)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(klass);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    DefaultRunner runner = (DefaultRunner) cglibProxy.newProxy(DefaultRunner.class);</span><br><span class="line">    runner.run(<span class="string">"proxy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们调用代理对象的<code>runner.run(&quot;Tony&quot;)</code>，日志输出的将会是“I’m Tony”而不是“I’m hijacked!”。</p><p>而Spring使用<code>org.springframework.aop.framework.CglibAopProxy</code>对目标对象进行代理，我的程序在调用一个fianl方法的时候，报了一个NPE异常，debug进去一看，成员变量<code>logger</code>居然是<code>null</code>。<br><img src="../images/20200112142005.png" alt><br>事实上，Spring的<code>CglibAopProxy</code>生成的代理对象的成员变量都是null，因为从Spring设计上，代理类只负责增强逻辑，然后再调用目标对象的方法，所以并没有初始化成员变量的必要。</p><p><img src="../images/20200112142143.png" alt></p><p>实际上我也不需要这个对象被代理。。手动new一个对象就正常了。</p><h1 id="为什么没有初始化成员变量？">3. 为什么没有初始化成员变量？</h1><p>我们在反射生成代理对象的时候，会调用构造方法。如果子类无参构造函数没有写super()，编译的时候，是会写进一句<code>super()</code>的。</p><p>但是由于是代理类是用子节码生成的，所以代理类构造函数是没有调用<code>super()</code>的，故没有初始化成员变量。</p><h1 id="参考">4. 参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/131584403" target="_blank" rel="noopener">Spring AOP避坑指南</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;cglib是采用生成目标类subclass方式来代理目标类的，所以如果目标类的方法是&lt;code&gt;final&lt;/code&gt;的话，就会直接调用目标类的方法。Spring的cglib代理实现有点坑，就是生成的代理对象是没有调用父类构造函
      
    
    </summary>
    
      <category term="Proxy" scheme="https://htchz.cc/categories/Proxy/"/>
    
    
      <category term="AOP" scheme="https://htchz.cc/tags/AOP/"/>
    
      <category term="BUG" scheme="https://htchz.cc/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>[Mysql]Innodb的快照读实现</title>
    <link href="https://htchz.cc/3647734067.html"/>
    <id>https://htchz.cc/3647734067.html</id>
    <published>2019-12-11T14:08:30.000Z</published>
    <updated>2020-06-05T09:01:20.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>有一次面试，面试官问我：mysql事务隔离级别有哪些？<br>我：balabala……<br>面试官问：那可重复读是怎么实现的？<br>我：emm。。第一次读会有快照。。<br>面试官：嗯。。<br>我：。。。</p><p>然后呢，然后就不知道啦。</p><p>事实上，Innodb的RC和RR隔离级别下，读有<strong>快照读（snapshot read）</strong>和<strong>当前读（current read）</strong>之分，<strong>当前读</strong>就是<code>SELECT ... LOCK IN SHARE MODE</code>和<code>SELECT ... FOR UPDATE</code>，快照读就是普通的<code>SELECT</code>操作。</p><p><strong>快照读</strong>的实现，利用了<strong>undo log</strong>和<strong>read view</strong>。</p><p><strong>快照读不是在读的时候生成快照，而是在写的时候保留了快照。</strong></p><p><strong>快照读</strong>实现了<strong>Multi-Version Concurrent Control（多版本并发控制）</strong>，简称<strong>MVCC</strong>，指对于同一个记录，不同的事务会有不同的版本，不同版本互不影响，最后事务提交时根据版本先后确定能否提交。</p><p>但是，<strong>Innodb</strong>的读写事务会加排他锁，不同版本其实是<strong>串行</strong>的，所以首先要指出的是，<strong>Innodb事务快照读不是严格的MVCC实现</strong>。</p><h1 id="实现">2. 实现</h1><h2 id="隐藏字段">2.1. 隐藏字段</h2><p>Innodb每一行都有三个隐藏字段，分别是<code>DB_ROW_ID</code>、<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>。</p><p><code>DB_ROW_ID</code>：如果表没有设置主键，用来作为记录的主键，因为<strong>Innodb</strong>使用聚簇索引的方式存储，记录必须有主键。<br><code>DB_TRX_ID</code>：记录修改这行记录事务的id。<br><code>DB_ROLL_PTR</code>：指向这行记录的前一个版本。</p><h2 id="undo-log">2.2. undo log</h2><p>多版本其实是用<strong>undo log</strong>来实现的，<strong>undo log</strong>听起来是做回滚使用的，没错，但是事务提交后<strong>undo log</strong>可不会立刻清除，它作为历史版本存在着。只有当前没有事务依赖在这行记录上时，mysql的清理线程才会清理掉无用的<strong>undo log</strong>。</p><p><code>insert</code>操作的<strong>undo log</strong>在事务回滚或提交后就会删除，因为只有回滚会用到。<br><code>update</code>、<code>delete</code>的<strong>undo log</strong>需要保留（可见<code>delete</code>只是逻辑删除，其实也是个<code>update</code>操作，逻辑删除后由后台线程清理）。</p><p>下面假设有一条记录如下，<strong>column_1</strong>、<strong>column_2</strong>初始值为1和2。<br><img src="../images/20191212171021.png" alt><br>假设这时有个三个事务ABC，A,C事务开始，对这条记录的查询结果如下：</p><table><thead><tr><th align="center">column_1</th><th align="center">column_2</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>接着A事务执行更新<strong>column_1</strong>为11；<br>具体过程是：给记录加X锁，复制记录为<strong>undo_log_1</strong>，然后再将记录的<strong>column_1</strong>改为11，<code>DB_TRX_ID</code>为A，<code>DB_ROLL_PTR</code>指向前一个版本。</p><blockquote><p>虽然数据行和<strong>undo log</strong>画的一样，但实际<strong>undo log</strong>有自己的数据结构。</p></blockquote><p><img src="../images/20191212171048.png" alt><br>A事务提交，释放X锁。</p><p>接着B开启事务，执行更新<strong>column_2</strong>为22；<br>具体过程是：给记录加X锁，复制A事务更新完的记录为<strong>undo_log_2</strong>，然后再将记录的<strong>column_2</strong>改为22，<code>DB_TRX_ID</code>为B，<code>DB_ROLL_PTR</code>指向前一个版本。<br><img src="../images/20191212171106.png" alt><br>然后B事务提交。</p><p>注意！！如果A事务没有提交，X锁是不会释放的，那么B事务对这行记录执行update为了获取X锁会阻塞住的，而<strong>MVCC</strong>标准各个版本应该是不会相互影响的，所以说<strong>Innodb事务快照读不是严格的MVCC实现</strong>。</p><p>那么问题来了，C事务这时执行第二次查询，查询结果会是什么呢。</p><h2 id="read-view">2.3. read view</h2><p>光有多版本还不够，需要一个机制对<strong>undo log</strong>进行可见性判断，决定当前事务读到的是哪个版本，这个机制就是通过<strong>read view</strong>完成，</p><p><strong>read view</strong>是对当前系统中活跃的所有事务列表的封装，注意是所有事务，而不是作用于目标行的事务。</p><p><strong>read view</strong>最早的事务id记为<code>up_limit_id</code>，最迟的事务id记为<code>low_limit_id</code>（<code>low_limit_id</code> = 未开启的事务id = 当前最大事务id+1），活跃事务id列表记为<code>descriptors</code>。</p><p>RC和RR的区别就是，RR在第一次查询会创建新的<strong>read view</strong>，RC是每次查询都创建<strong>read view</strong>。</p><blockquote><p>如果记录上的<code>trx_id</code>小于<code>read_view_t-&gt;up_limit_id</code>，则说明这条记录的最后修改在readview创建之前，因此这条记录可以被看见。</p><p>如果记录上的<code>trx_id</code>大于等于<code>read_view_t-&gt;low_limit_id</code>，则说明这条记录的最后修改在readview创建之后，因此这条记录肯定不可以被看见。</p><p>如果记录上的<code>trx_id</code>在<code>up_limit_id</code>和<code>low_limit_id</code>之间，且<code>trx_id</code>在<code>read_view_t-&gt;descriptors</code>之中，则表示这条记录的最后修改是在readview创建之后，被另外一个活跃事务所修改，所以这条记录也不可以被看见。如果<code>trx_id</code>不在<code>read_view_t-&gt;descriptors</code>之中，则表示这条记录的最后修改在readview创建之前，所以可以看到。</p><p>基于上述判断，如果记录不可见，则尝试使用undo去构建老的版本(row_vers_build_for_consistent_read)，直到找到可以被看见的记录或者解析完所有的undo。</p></blockquote><p>上一节里，假设事务隔离级别是<strong>RR</strong>，事务id大小顺序是：X &lt; C &lt; A &lt; B &lt; D(D是未开启的事务Id)，事务都是读写事务（只读事务不会加入<strong>read view</strong>）</p><p>那么C事务第一次查询创建一个<strong>read view</strong>，<code>up_limit_id</code>为C，<code>low_limit_id</code>为B，<code>descriptors</code>为{C，A}，这时记录的<code>DB_TRX_ID</code>是X，A &gt; X，说明记录可见。</p><p>当A事务更新完毕B事务更新完毕后，C事务执行第二次查询，<strong>read view</strong>还是最开始的那个，此时记录的<code>DB_TRX_ID</code>是B，&gt;= <code>low_limit_id</code>， 因此这条记录肯定不可以被看见，需要沿着历史版本找。</p><p>记录的前一个版本的<code>DB_TRX_ID</code>是A，在<code>up_limit_id</code>和<code>low_limit_id</code>之间, 且在<code>descriptors</code>之间，所以此版本还是不可以被看见，继续往历史版本找。</p><p>前一个版本的<code>DB_TRX_ID</code>是X，&lt; <code>up_limit_id</code>, 所以该版本可见，所以C事务第二次查询结果依旧是：</p><table><thead><tr><th align="center">column_1</th><th align="center">column_2</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>这就做到了可重复读。</p><p><strong>如果是RC呢？</strong></p><p>C事务执行第二次查询，创建新的<strong>read view</strong>，<code>up_limit_id</code>为C，<code>low_limit_id</code>为D，<code>descriptors</code>为{C}，此时记录的<code>DB_TRX_ID</code>是B，在<code>up_limit_id</code>和<code>low_limit_id</code>之间，但是不在在<code>descriptors</code>之中，所以记录是可见的，也就是说C事务可以读到B事务提交的结果，这就是RC快照读的实现。</p><h2 id="幻读">2.4. 幻读</h2><p>RR级别下，在一个事务里，如果全程只进行<strong>快照读</strong>操作，那么是不会发生幻读的，也不会加锁；如果事务进行快照读又进行了写操作，那么就会发生幻读。</p><p>也就是说：RR的幻读只发生在写操作中</p><p>可以用当前读解决幻读。</p><h2 id="聚簇索引">2.5. 聚簇索引</h2><p>聚簇索引在更新主键的时候，会删掉旧记录，插入带有新主键的记录。</p><h2 id="二级索引">2.6. 二级索引</h2><p>二级索引是没有隐藏字段的，所以<strong>没有undo log</strong>，只有一个标志位。</p><p>如果一个update语句更新到了二级索引，旧二级索引<code>delete_mark</code>置1，插入新二级索引。查询的时候，要判断可见性怎么办？根据二级索引找到聚簇索引（无视delete_mark），再从聚簇索引开始可见性判断，找到可见记录，如果可见记录和二级索引维护的结果一致（索引值和主键值一样），就返回记录，否则返回空。</p><p>这样效率比较低，比如student表里age是二级索引，查询条件是age=10，满足这个条件的age-&gt;student_id的二级索引会有多个，事务事务需要遍历所有age=10的索引进行可见性判断才能拿到旧值。</p><p>于是innodb给二级索引加了个<code>MAX_TRX_ID</code>记录最后更新二级索引的事务，如果当前事务read_view的 up_limit_id &gt; MAX_TRX_ID，说明在创建read_view时最后一次更新二级索引的事务已经结束，就可以无视<code>delete_mark=1</code>的二级索引。如果<code>MAX_TRX_ID</code>失效，依旧要遍历所有age=10的二级索引。</p><h2 id="题外话">2.7. 题外话</h2><p>在InnoDB里面有两种事务模式，一种是读写事务，就是会对数据进行修改的事务，另外一种是只读事务，仅仅对数据进行读取。开启一个读写事务要做的事比开启一个只读事务多许多，需要分配回滚段来记录undo log，需要把读写事务加入到全局读写事务链表，把事务id加入活跃读写事务数组中，所以你的事务没有写操作的话，声明为只读事务是个不错的优化。</p><p>5.6 如果要开始只读事务，需要显式指明事务模式为只读；</p><p>5.7如果不指明事务模式，mysql会初始化为只读事务，如果发生写操作，再将事务提升为读写事务，分配回滚段，分配事务id（只读事务也有id啦），加入读写事务链表。<br>5.7如果一次<strong>read view</strong>使用完后，没有新的读写事务创建，那么可以给下一个事务复用。</p><p>还有<strong>性能</strong>，由于读是不加锁的，RR似乎比RC开销小，那是不是RR的性能比RC好？事实是不一定的，在写的时候，RR为了防止幻读，加入了gap和next-key锁，这通常是RR会造成死锁，导致RR比RC差的原因。</p><h1 id="后记">3. 后记</h1><p>在这之前，不明白为什么事务可以临时指定隔离级别，临时指定不需要其他事务配合么，现在应该懂了😎，不过事务还有好多不懂😎</p><h1 id="参考">4. 参考</h1><ol><li><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">《MySQL · 引擎特性 · InnoDB 事务系统》</a></li><li><a href="https://www.cnblogs.com/stevenczp/p/8018986.html" target="_blank" rel="noopener">《MySQL InnoDB MVCC深度分析》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;有一次面试，面试官问我：mysql事务隔离级别有哪些？&lt;br&gt;我：balabala……&lt;br&gt;面试官问：那可重复读是怎么实现的？&lt;br&gt;我：emm。。第一次读会有快照。。&lt;br&gt;面试官：嗯。。&lt;br&gt;我：。。。&lt;/p&gt;
&lt;p&gt;然后
      
    
    </summary>
    
      <category term="Mysql" scheme="https://htchz.cc/categories/Mysql/"/>
    
    
      <category term="事务" scheme="https://htchz.cc/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>[Redis]《Redis设计与实现》</title>
    <link href="https://htchz.cc/1473130276.html"/>
    <id>https://htchz.cc/1473130276.html</id>
    <published>2019-12-03T01:01:33.000Z</published>
    <updated>2020-07-30T07:33:58.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>《Redis设计与实现》第二版基于redis3.0，现在6.0都快出了。现在redis和书里有些内容已经不一致了，不过用来探索redis是挺好的。</p><h1 id="碎碎念">2. 碎碎念</h1><h2 id="编码">2.1. 编码</h2><p>现在的redis已经增加了quicklist、stream编码。</p><p>quicklist是ziplist和linkedlist的整合，作为list的唯一编码，其思想就是将ziplist分段，ziplist内存碎片少但每次操作都要申请内存，将ziplist分段，并用操作性能比较好的双向链表把段串起来，这算是时间与空间的折中。</p><p>stream编码用于消息队列，没有去了解。</p><h2 id="字典">2.2. 字典</h2><p>字典expand/resize是redis的一个大话题。</p><p>字典执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时负载因子必须达到5才能进行扩容，执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时不能进行缩容。</p><p>之所以，是因为<code>BGSAVE</code>或<code>BGREWRITEAOF</code>使用了<code>copy-on-write</code>，也就是写时复制。执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时redis会fork子进程，这时候如果进行一个内存的拷贝（保证数据一致性），那么内存的浪费是很大的。使用写时复制，会将父进程的内存设置为只读，将内存和子进程共享，由于内存是分页机制，当某一页内存要发生写操作时，会发生中断，操作系统会把这一页内存复制出来进行修改。</p><p>因此，为了减少写操作导致内存页复制，redis才有了在上面的策略。</p><h2 id="下个2的幂">2.3. 下个2的幂</h2><p>redis在expand/resize都将新数组的长度设置为2的幂，这是因为把数组长度设置为2的幂，就可以把取模运算转化为位运算，java里也是这么做。</p><p>redis作者使用了这么一个算法来求给定一个数的下个2的幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的循环，不过有人给他提出可以用位运算：<a href="https://github.com/antirez/redis/pull/3833" target="_blank" rel="noopener">传送门</a>，java里用的也是这个算法，<a href="./2353864749.html">HashMap的tableSizeFor()</a>。</p><p>作者说不错，但是没必要，这种位运算的魔法对现实来说都是假的，只会把代码搞复杂😮</p><h2 id="EMBSTR">2.4. EMBSTR</h2><p>书里的<code>REDIS_ENCODING_EMBSTR</code>支持最大长度39字节，而现在最大支持44字节，原因是3.2版本之后sdshdr变了。<code>REDIS_ENCODING_EMBSTR</code>使用<code>sdshdr8</code>来表示，原来的sdshdr需要8字节，现在使用<code>sdshdr8</code>只需要三字节，那么：44 + 1（<code>&#39;\0&#39;</code>）+ 3 + 16(robj) = 64，刚好是64字节，可以达到64字节内存对齐。</p><p>作者一度用着44的限制，写着39的注释，让我一度迷惑。</p><h2 id="多线程">2.5. 多线程</h2><p>redis6.0加入了多线程，不知道和阿里云的多线程redis有什么区别，看起来都是在io线程并行，工作线程串行。</p><h2 id="raft">2.6. raft</h2><p>redis sentinel和redis cluster选举都是采用raft协议的选举方式：同一个term里，一人一票；当得到majority的票时选举成功，当票被瓜分选举失败开始新一轮。</p><p>在<strong>sentinel</strong>模式下，负责故障转移的sentinel是通过raft选举出来的：只需要先发起投票的sentinel节点就能拿到票。接着领头sentinel在从节点中选出复制偏移量最大的从节点作为新master；如果从节点的复制偏移量一致，则选取服务器id较小的那个。</p><p>在<strong>cluster</strong>模式下，从节点晋升为主节点比sentinel模式复杂一些，需要得到majority主节点的票。在选举过程，当candidate收到投票请求时，判断投票请求是否过期、candidate是否有选票，比较主从复制偏移量，符合的话那就投给那个节点。</p><h2 id="LFU">2.7. LFU</h2><p>redis4.0新增了lfu策略来淘汰key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>通过redis.conf的设置，<code>unsigned lru:LRU_BITS</code>的有不同的表示。当表示lfu时，这个字段用8位来当作计数器，用16位当时间戳，16位长度只有两个字节，所以存的时间是以秒位单位。</p><p>在redis里lfu策略下，如果一个key被访问，那么计数器会增加，不过这种增加是需要乘上一个概率的，计数器越大，计数增加的几率越小；而同时key还要根据时间戳判断要不要衰减计数器，以此调整计数。</p><p>在这种策略下，redis会为key初始化一个5的计数器，防止key刚被初始化就被淘汰。</p><h2 id="BITSET">2.8. BITSET</h2><p>位图用来统计是很不错的一个数据类型，在redis里位图也是一个<code>sdshdr</code>，redis将一个字符用作8位，并把位图从低位往高位存储（sdshdr用buf数组存储字符串，当sdshdr表示位图时，buf数组从左往右是从低位到高位），这样当位图需要扩大的时候，只需要在buf数组尾部增加字符就可以了。</p><p>位图的统计的是一个有趣的问题，也就是统计一个二进制数的1有多少个。</p><p>暴力法不考虑，要说的是两个方法，<strong>查表法</strong>还有<strong>variable-precision SWAR算法</strong></p><h3 id="查表法">2.8.1. 查表法</h3><p>查表法就是预先给出各个数的二进制的1的数量，对于比较小的数字，这是一个速度最快的方法。</p><h3 id="variable-precision-SWAR算法">2.8.2. variable-precision SWAR算法</h3><p>这个方法采用位运算，而且还不占额外内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swar</span><span class="params">(<span class="keyword">uint32_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算每两位二进制数中1的个数</span></span><br><span class="line">    i = ( i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    <span class="comment">//计算每四位二进制数中1的个数</span></span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    <span class="comment">//计算每八位二进制数中1的个数</span></span><br><span class="line">    i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    <span class="comment">//将每八位二进制数中1的个数和相加，并移至最低位八位</span></span><br><span class="line">    i = (i * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个32位的数，通过位运算归并1的数量到4个字节中，最后用一个乘法汇总4个字节的1的数量到高8位，这个乘法过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">  x                             00000001 00000001 00000001 00000001</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                                00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">                       00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">              00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">     00000001 00000010 00000011 00000100</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                               |00001010|·······no sense bit·······</span><br></pre></td></tr></table></figure><p>最后右移24位得到这8位的值。</p><h3 id="redis-bitcount">2.8.3. redis bitcount</h3><p>redis采用查法和variable-precision SWAR算法结合的方法来实现bitcount。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> redisPopcount(<span class="keyword">void</span> *s, <span class="keyword">long</span> count) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p4;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> bitsinbyte[<span class="number">256</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">        bits += bitsinbyte[*p++];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count bits 28 bytes at a time */</span></span><br><span class="line">    p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;=<span class="number">28</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4, aux5, aux6, aux7;</span><br><span class="line"></span><br><span class="line">        aux1 = *p4++;</span><br><span class="line">        aux2 = *p4++;</span><br><span class="line">        aux3 = *p4++;</span><br><span class="line">        aux4 = *p4++;</span><br><span class="line">        aux5 = *p4++;</span><br><span class="line">        aux6 = *p4++;</span><br><span class="line">        aux7 = *p4++;</span><br><span class="line">        count -= <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">        aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux2 = aux2 - ((aux2 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux2 = (aux2 &amp; <span class="number">0x33333333</span>) + ((aux2 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux3 = aux3 - ((aux3 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux3 = (aux3 &amp; <span class="number">0x33333333</span>) + ((aux3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux4 = aux4 - ((aux4 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux4 = (aux4 &amp; <span class="number">0x33333333</span>) + ((aux4 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux5 = aux5 - ((aux5 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux5 = (aux5 &amp; <span class="number">0x33333333</span>) + ((aux5 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux6 = aux6 - ((aux6 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux6 = (aux6 &amp; <span class="number">0x33333333</span>) + ((aux6 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux7 = aux7 - ((aux7 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux7 = (aux7 &amp; <span class="number">0x33333333</span>) + ((aux7 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux2 + (aux2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux3 + (aux3 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux4 + (aux4 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux5 + (aux5 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux6 + (aux6 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux7 + (aux7 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>))* <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Count the remaining bytes. */</span></span><br><span class="line">    p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)p4;</span><br><span class="line">    <span class="keyword">while</span>(count--) bits += bitsinbyte[*p++];</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对于位图需要4字节对齐，因为redis里的SWAR算法一次操作4个字节，保证字节对齐可以提高内存读取速度，然后源码里有这么一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">    bits += bitsinbyte[*p++];</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段我看了半天看不懂，最后在stackoverflow<a href="https://stackoverflow.com/questions/19190502/how-do-i-check-a-memory-address-is-32-bit-aligned-in-c" target="_blank" rel="noopener">How Do I check a Memory address is 32 bit aligned in C</a>找到答案，大概意思就是地址结尾是<code>0b100</code>的倍数，也就是<code>&amp; 0b11 = 0</code>，那么这个地址就是可以4字节对齐的。所以如果<code>(unsigned long)p &amp; 3</code>为true，说明地址不对齐，就要指针前进一个字节，并通过查表法计算这个字节的1的数量。</p><p>接着同时计算连续的28个字节，每4字节使用一次SWAR算法，再把7次结果汇总。</p><p>最后余下不足28字节的再用查表法计算。整个bitcount的过程就是这样。</p><blockquote><p>统计一个位数组中非0位的数量，数学上称作：”Hanmming Weight“(汉明重量)。</p></blockquote><h2 id="AOF">2.9. AOF</h2><p>即使开启<strong>appendfsync always</strong>配置，redis还是可能丢数据。</p><p>AOF主要靠<code>aof_buf</code>和AOF文件。</p><p>都说redis是基于事件循环的。在一次事件循环里，每个写事件redis都会追加到<code>aof_buf</code>中；每次事件循环后，redis都会把<code>aof_buf</code>的内容写进AOF文件里。但是AOF文件是不会实时刷入硬盘的，而<strong>appendfsync</strong>配置具体就是刷盘时机。开启<strong>appendfsync always</strong>配置后，每个事件循环都会进行刷盘，在这个模式下redis宕机，也会至多丢失一个事件循环的命令。</p><p>题外话，innodb日志系统也有<strong>log buffer</strong>和<strong>log file</strong>，类似于<code>aof_buf</code>和AOF文件，而<strong>innodb_flush_log_at_trx_commit</strong>这个配置控制的也是<strong>log file</strong>刷盘策略，不过innodb可以做到不丢数据，而redis不行。</p><h1 id="参考">3. 参考</h1><ol><li><a href="https://segmentfault.com/a/1190000015481454" target="_blank" rel="noopener">【Redis学习笔记】bitcount分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;《Redis设计与实现》第二版基于redis3.0，现在6.0都快出了。现在redis和书里有些内容已经不一致了，不过用来探索redis是挺好的。&lt;/p&gt;
&lt;h1 id=&quot;碎碎念&quot;&gt;2. 碎碎念&lt;/h1&gt;&lt;h2 id=&quot;编码&quot;&gt;2
      
    
    </summary>
    
      <category term="redis" scheme="https://htchz.cc/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>[分布式]手撕raft</title>
    <link href="https://htchz.cc/1823228532.html"/>
    <id>https://htchz.cc/1823228532.html</id>
    <published>2019-10-03T08:27:57.000Z</published>
    <updated>2020-02-23T04:26:12.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>Raft作为一个简单的一致性算法，实现一下还是挺好玩的。代码基于<strong>6.824</strong> <a href="http://nil.csail.mit.edu/6.824/2018/labs/lab-raft.html" target="_blank" rel="noopener">lab-raft</a>，<strong>6.824</strong>是麻省理工的分布式课程的一个编号，里面有4个lab，第二个就是raft协议的实现，第三个是基于raft协议的kv存储设计，有待实现（oh我居然在做麻省理工的课程设计）。该lab要求使用go实现算法，并提供了一个<a href="http://oserror.com/distributed/golang-rpc-with-failure-simulation/" target="_blank" rel="noopener">具有故障模拟功能的RPC</a>，即通过模拟网络，在单台机器我们就可以运行raft算法。</p><blockquote><p>做实验前，你应该熟读raft论文，这里是<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">中文版</a></p></blockquote><h1 id="实现">2. 实现</h1><p>参照raft论文和lab提示，整体利用channel作为事件驱动、mutex保证线程安全，写出一个raft算法骨架还是比较容易的。不过在跑test的时候，小小的细节不对就会导致<code>test failed</code>。<br><img src="../images/20191004005135.png" alt><br><strong>raft-lab</strong>提供了17个test，检验了各种情况下的一致性，模拟了各种奇葩网络变化（网络变成这样还是跑路吧），要求4分钟内pass。</p><h2 id="数据结构">2.1. 数据结构</h2><p>参照论文，定义几个数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower = <span class="literal">iota</span></span><br><span class="line">Candidate</span><br><span class="line">Leader</span><br><span class="line"></span><br><span class="line">HeartbeatInterval = <span class="number">100</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">CommandValid <span class="keyword">bool</span></span><br><span class="line">Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">CommandIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="keyword">int</span></span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">LeaderId     <span class="keyword">int</span></span><br><span class="line">PrevLogIndex <span class="keyword">int</span></span><br><span class="line">PrevLogTerm  <span class="keyword">int</span></span><br><span class="line">Entries      []LogEntry</span><br><span class="line">LeaderCommit <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term      <span class="keyword">int</span></span><br><span class="line">Success   <span class="keyword">bool</span></span><br><span class="line">NextIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">currentTerm     <span class="keyword">int</span></span><br><span class="line">mu              sync.Mutex          <span class="comment">// Lock to protect shared access to this peer's state</span></span><br><span class="line">peers           []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister       *Persister          <span class="comment">// Object to hold this peer's persisted state</span></span><br><span class="line">me              <span class="keyword">int</span>                 <span class="comment">// this peer's index into peers[]</span></span><br><span class="line">state           <span class="keyword">int</span>                 <span class="comment">// 0:Follower 1:Candidate 2:Leader</span></span><br><span class="line">votedFor        <span class="keyword">int</span>                 <span class="comment">// 这个实验用index来代替节点</span></span><br><span class="line">voteCount       <span class="keyword">int</span></span><br><span class="line">commitIndex     <span class="keyword">int</span></span><br><span class="line">lastApplied     <span class="keyword">int</span></span><br><span class="line">currentLeaderId <span class="keyword">int</span></span><br><span class="line">log             []LogEntry</span><br><span class="line">nextIndex       []<span class="keyword">int</span></span><br><span class="line">matchIndex      []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">heartbeatCh <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">leaderCh    <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">commitCh    <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">CandidateId  <span class="keyword">int</span> <span class="comment">// 这个实验用index来代替节点</span></span><br><span class="line">LastLogIndex <span class="keyword">int</span></span><br><span class="line">LastLogTerm  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">VoteGranted <span class="keyword">bool</span> <span class="comment">// 是否支持</span></span><br><span class="line">Term        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小声bb，<code>AppendEntriesReply</code>论文是没有返回<code>nextIndex</code>的，而是由leader自己去<strong>减一重试</strong>，这其实是比较慢的，在设置了网络故障<strong>unreliable</strong>的test中，单纯的<strong>减一重试</strong>会导致raft集群在一定时间内不能达到一致。让follower过滤掉同一个term的index，并返回应该尝试的<code>nextIndex</code>，虽然会导致一次复制的日志变多，不过提高了集群达到一致的速度。</p><h2 id="一些封装">2.2. 一些封装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁/释放锁的封装，可以在利用`runtime.Caller`打印获取锁的调用点，虽然性能损失比较大。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字如其名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">getLastLogTerm</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">getLastLogIndex</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="raft实例初始化">2.3. raft实例初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span> *<span class="title">Raft</span></span> &#123;</span><br><span class="line">rf := &amp;Raft&#123;&#125;</span><br><span class="line">rf.peers = peers</span><br><span class="line">rf.persister = persister</span><br><span class="line">rf.me = me</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your initialization code here (2A, 2B, 2C).</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = <span class="number">0</span></span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.currentLeaderId = <span class="number">-1</span></span><br><span class="line"><span class="comment">// 初始化空白日志</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;Term: <span class="number">0</span>&#125;)</span><br><span class="line">rf.applyCh = applyCh</span><br><span class="line"></span><br><span class="line">rf.heartbeatCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">rf.leaderCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">rf.commitCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化随机数资源库</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> rf.state &#123;</span><br><span class="line"><span class="keyword">case</span> Follower:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-rf.heartbeatCh:</span><br><span class="line"><span class="comment">// 这是lab要求心跳</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Int63()%<span class="number">333</span>+<span class="number">550</span>) * time.Millisecond):</span><br><span class="line">rf.state = Candidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Leader:</span><br><span class="line">rf.broadcastAppendEntries()</span><br><span class="line">time.Sleep(HeartbeatInterval)</span><br><span class="line"><span class="keyword">case</span> Candidate:</span><br><span class="line"><span class="keyword">go</span> rf.broadcastVote()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Int63()%<span class="number">300</span>+<span class="number">500</span>) * time.Millisecond): <span class="comment">//随机投票超时是必须的，为了防止票被瓜分完。</span></span><br><span class="line"><span class="keyword">case</span> &lt;-rf.heartbeatCh:</span><br><span class="line">rf.state = Follower</span><br><span class="line"><span class="keyword">case</span> &lt;-rf.leaderCh: </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&lt;-rf.commitCh</span><br><span class="line">rf.applyMsg(applyCh)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回一个raft实例，读取持久化数据，起了两个goroutine。</p><ul><li><p>goroutine1是raft三种状态的转化，这里的超时时间不宜设的太短（太短指论文里的时间），在lab文档里有指出为了配合test，选举超时时间应该<strong>larger than the paper’s 150 to 300 milliseconds</strong></p></li><li><p>goroutine2应用已提交日志。</p></li></ul><p>在初始化channel的时候应该设置缓冲大于1。多余的事件并不会导致系统不一致，但是若由于channel缓冲不够而导致阻塞，就会使raft节点死锁。</p><h2 id="votedFor清空时机">2.4. votedFor清空时机</h2><p>一次rpc，无论是发起端还是接收端，只要收到更大的term，就要调整自己的状态，发生下面变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = remoteTerm</span><br></pre></td></tr></table></figure><p>可以看到<code>state</code>会变成<code>Follower</code>。</p><p>假设一种情景，ABC三个节点下，A为leader，此时C发生分区，那么C一定会不断循环进行超时选举，C的term会一直增大，当C网络恢复重新加入集群后会继续发投票请求rpc。由于C的投票请求rpc中的<code>term</code>较大，集群就会调整<code>currentTerm</code>以及<code>state</code>，已有leader会废掉。而问题是，C的请求投票是无意义的，却使集群进行了一次选举。针对这个问题有个<strong>preVote</strong>方案，就是在投票前调研一下自己是否有投票必要，如果没必要，就不发起投票。这篇文章暂无涉及<strong>preVote</strong>。</p><h2 id="投票发起与接收">2.5. 投票发起与接收</h2><h3 id="broadcastVote-发起投票">2.5.1. broadcastVote() 发起投票</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">broadcastVote</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line">rf.currentTerm++</span><br><span class="line">rf.voteCount = <span class="number">1</span></span><br><span class="line">rf.votedFor = rf.me</span><br><span class="line">vote := &amp;RequestVoteArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">CandidateId:  rf.me,</span><br><span class="line">LastLogIndex: rf.getLastLogIndex(),</span><br><span class="line">LastLogTerm:  rf.getLastLogTerm(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.persist()</span><br><span class="line">rf.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.state != Candidate &#123; <span class="comment">// 发送</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> vote.CandidateId == i &#123; <span class="comment">// 自己的票已经给自己了</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply RequestVoteReply</span><br><span class="line">ok := rf.sendRequestVote(server, vote, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般来说，reply.Term &gt; rf.currentTerm 的情况下 reply.VoteGranted 不会为true</span></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">rf.voteCount++</span><br><span class="line"><span class="keyword">if</span> rf.state == Candidate &amp;&amp; rf.voteCount &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">rf.becomeLeader()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendRequestVote</span><span class="params">(server <span class="keyword">int</span>, args *RequestVoteArgs, reply *RequestVoteReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">"Raft.RequestVote"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接收到投票reply后，查看票根是否过半，如果过半转化为leader。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有加锁，外部调用已经加锁了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.state = Leader</span><br><span class="line">rf.nextIndex = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">rf.matchIndex = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"><span class="comment">// 初始化为0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">rf.leaderCh &lt;- <span class="literal">true</span> <span class="comment">// 结束选举阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestVote-接收投票">2.5.2. RequestVote 接收投票</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args *RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过期的投票请求</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果发起方的term比接收方大</span></span><br><span class="line"><span class="comment">// adjust current term</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &lt; args.Term &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upToDate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm &gt; rf.getLastLogTerm() &#123;</span><br><span class="line">upToDate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm == rf.getLastLogTerm() &amp;&amp; args.LastLogIndex &gt;= rf.getLastLogIndex() &#123;</span><br><span class="line">upToDate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId) &amp;&amp; <span class="comment">// 保证有票</span></span><br><span class="line">upToDate &#123;</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = args.CandidateId</span><br><span class="line">rf.heartbeatCh &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1，进行投票后要发送心跳<code>rf.heartbeatCh &lt;- true</code>，不然节点会由<code>Follower</code>超时，从而使集群选举循环下去。<br>2，判断日志是否较新要满足其中一个条件：一，term较大，二，term一样，但日志index比较大</p><h2 id="日志复制与接收">2.6. 日志复制与接收</h2><h3 id="broadcastAppendEntries-广播日志-心跳">2.6.1. broadcastAppendEntries 广播日志/心跳</h3><p>日志复制lab文档要求一秒不能超过10次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">broadcastAppendEntries</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"></span><br><span class="line">N := rf.commitIndex</span><br><span class="line"><span class="keyword">for</span> i := rf.commitIndex + <span class="number">1</span>; i &lt;= rf.getLastLogIndex(); i++ &#123;</span><br><span class="line"><span class="comment">// 1 是leader本身</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line"><span class="comment">// 只能提交本term的，一旦提交了本term的，旧term也算提交了</span></span><br><span class="line"><span class="keyword">if</span> rf.me != j &amp;&amp; rf.matchIndex[j] &gt;= i &amp;&amp; rf.log[i].Term == rf.currentTerm &#123;</span><br><span class="line">num++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">N = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> N != rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = N</span><br><span class="line">rf.commitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.state != Leader &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123; <span class="comment">// 不用给自己心跳</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args AppendEntriesArgs</span><br><span class="line">args.Term = rf.currentTerm</span><br><span class="line">args.LeaderCommit = rf.commitIndex</span><br><span class="line">args.LeaderId = rf.me</span><br><span class="line">args.PrevLogIndex = rf.nextIndex[i] - <span class="number">1</span></span><br><span class="line">args.PrevLogTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">args.Entries = <span class="built_in">make</span>([]LogEntry, <span class="built_in">len</span>(rf.log[args.PrevLogIndex+<span class="number">1</span>:]))</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="built_in">copy</span>(args.Entries, rf.log[args.PrevLogIndex+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, args AppendEntriesArgs)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line">ok := rf.sendAppendEntries(i, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rf.handleAppendEntriesReply(&amp;args, &amp;reply, i)</span><br><span class="line">&#125;(i, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendAppendEntries</span><span class="params">(server <span class="keyword">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">"Raft.AppendEntries"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次发送日志前，leader从<code>matchIndex[]</code>里统计出应该commit的index，如果index前进，发送commit事件。统计时要判断<code>rf.log[i].Term == rf.currentTerm</code>，也就是说只能提交自己term的log，一旦提交了自己term的log，之前term未被提交的log也算提交了。这个在论文有提到。</p><p>下面是复制日志的响应代码，也很直白。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reply 为 false， 如果不是任期问题，就是日志不匹配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">handleAppendEntriesReply</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.Unlock()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> rf.state != Leader &#123; <span class="comment">// 获取锁后校验自己的状态</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.Term != rf.currentTerm &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.persist()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">        <span class="comment">// len(args.Entries)  == 0 就是心跳了，不用处理</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) &gt; <span class="number">0</span> &#123;</span><br><span class="line">rf.matchIndex[i] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">rf.nextIndex[i] = rf.matchIndex[i] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[i] = reply.NextIndex <span class="comment">// 直接采用follower的建议</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppendEntries-接收日志">2.6.2. AppendEntries 接收日志</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">AppendEntries</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉老term的节点该更新啦</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 心跳</span></span><br><span class="line">rf.heartbeatCh &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust current term</span></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这坨是在日志不匹配的情况下，对leader的NextIndex建议</span></span><br><span class="line"><span class="keyword">if</span> rf.getLastLogIndex() &lt; args.PrevLogIndex &#123;</span><br><span class="line">reply.NextIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">term := rf.log[args.PrevLogIndex].Term</span><br><span class="line"><span class="keyword">if</span> args.PrevLogTerm != term &#123;</span><br><span class="line"><span class="keyword">for</span> i := args.PrevLogIndex - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> rf.log[i].Term != term &#123;</span><br><span class="line">reply.NextIndex = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">reply.NextIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line"><span class="comment">// 删除已存在日志</span></span><br><span class="line">rf.log = rf.log[:args.PrevLogIndex+<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 附加新日志</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = Min(args.LeaderCommit, rf.getLastLogIndex())</span><br><span class="line">rf.commitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这理主要是<code>NextIndex</code>建议值的计算。</p><h2 id="将提交的日志应用至状态机">2.7. 将提交的日志应用至状态机</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">applyMsg</span><span class="params">(applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">msg := ApplyMsg&#123;</span><br><span class="line"><span class="literal">true</span>,</span><br><span class="line">rf.log[i].Command,</span><br><span class="line">i,</span><br><span class="line">&#125;</span><br><span class="line">applyCh &lt;- msg</span><br><span class="line">rf.lastApplied = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用过程其实是由test去管理的，我们只要负责把需要应用的日志放入<code>chan ApplyMsg</code>。</p><h2 id="持久化">2.8. 持久化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">persist</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := gob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">readPersist</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := gob.NewDecoder(r)</span><br><span class="line">d.Decode(&amp;rf.currentTerm)</span><br><span class="line">d.Decode(&amp;rf.votedFor)</span><br><span class="line">d.Decode(&amp;rf.log)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个持久化函数，持久化了<code>currentTerm</code>当前term,<code>votedFor</code>得票者,<code>log</code>日志数组，当这三个属性变化时，都执行一次<code>rf.persist()</code>就没错啦。</p><h1 id="后记">3. 后记</h1><p>表面是在贴代码，实际就是在贴代码。</p><p>由于实验是并发过程，一旦<code>test failed</code>是不容易按线性的过程来分析的。我的方法是多打日志，以及利用<code>net/http/pprof</code>包对程序的goroutine、mutex状态进行分析。</p><p>实现完以后我感觉又变强了（并没有）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;Raft作为一个简单的一致性算法，实现一下还是挺好玩的。代码基于&lt;strong&gt;6.824&lt;/strong&gt; &lt;a href=&quot;http://nil.csail.mit.edu/6.824/2018/labs/lab-raft.h
      
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="raft" scheme="https://htchz.cc/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>[k8s]k8s部署踩坑</title>
    <link href="https://htchz.cc/2102019255.html"/>
    <id>https://htchz.cc/2102019255.html</id>
    <published>2019-08-25T06:06:02.000Z</published>
    <updated>2020-02-26T16:06:20.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>自己搭个k8s集群，踩了一些坑</p><h1 id="镜像">2. 镜像</h1><p><code>kubeadm init</code>命令会去<code>k8s.gcr.io</code>拉镜像，这个地址是得挂代理才能上的（可以指定地址忽略代理），可以用<code>kubeadm config images pull</code>尝试一下，十有八九是不行。不想挂代理的话，用下面这个方法。</p><p>先执行<code>kubeadm config images list</code>列出镜像，输出信息中有两行<code>WARN</code>是获取版本timeout可以不理会。</p><p>接着把列出来的信息放到下面的bash脚本中，运行脚本就把镜像下载好啦(其实就是从阿里云下镜像改tag)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">images=(  <span class="comment"># 下面的镜像应该去除"k8s.gcr.io"的前缀，版本换成上面获取到的版本</span></span><br><span class="line">kube-apiserver:v1.15.3</span><br><span class="line">kube-controller-manager:v1.15.3</span><br><span class="line">kube-scheduler:v1.15.3</span><br><span class="line">kube-proxy:v1.15.3</span><br><span class="line">pause:3.1</span><br><span class="line">etcd:3.3.10</span><br><span class="line">coredns:1.3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="token和ca-cert-hash">3. token和ca-cert-hash</h1><p>在master进行<code>kubeadm init</code>后会输出<code>token</code>和<code>ca-cert-hash</code>，这个要记住，如果忘记了虽然可以执行<code>kubeadm token list</code>获取<code>token</code>，但是<code>ca-cert-hash</code>是不会输出的，忘记<code>ca-cert-hash</code>只能重新执行<code>kubeadm token create</code>从输出中拿到。</p><h1 id="ip转发">4. ip转发</h1><p>在node主机执行<code>kubeadm join</code>的时候，报</p><pre><code>[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1`</code></pre><p>意思是没有开启ipv4转发，设置一下就好了：<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p><h1 id="时间同步">5. 时间同步</h1><p>在node主机执行<code>kubeadm join</code>的时候，一直卡住，加上<code>--v=2</code>可以输出详细信息，输出了一个信息</p><pre><code>I0824 21:58:46.950161   16866 token.go:146] [discovery] Failed to request cluster info, will try again: [Get https://192.168.0.113:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: x509: certificate has expired or is not yet valid]`</code></pre><p>但是我的证书没过期呀，在一个issue里一位老哥说是不是几台机器时间没同步，我在node主机上执行<code>date</code>，果然时间和master差了好久，用于是ntp命令同步了一下时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntpdate</span><br><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><h1 id="hostname">6. hostname</h1><p>在node主机执行<code>kubeadm join</code>的时候，要用<code>--node-name</code>指定节点名字，如果不指定，会用hostname，如果你和我一样主机是用vmware克隆出来的，几台机器的hostname都是一样的，就会执行<code>kubeadm join</code>成功，<code>kubectl get nodes</code>只有一台master(三台机hostname都是master)，<code>kubectl get pods --namespace kube-system</code>的pod也都只有一份。</p><h1 id="网桥地址重复">7. 网桥地址重复</h1><p><code>failed to set bridge addr: &quot;cni0&quot; already has an IP address different from 10.244.1.1/24</code>，执行<code>ip link delete cin0</code>删除<strong>cni0</strong>网桥。</p><h1 id="dashboard-404错误">8. dashboard 404错误</h1><p>输入token后显示的是404，执行<code>kubectl logs</code>发现找不到某些<code>Resource</code>，查看iusse，dashboard v1.X和新版的k8s不兼容，升到v2.x就好了。不过v2.x还没有正式版。</p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;自己搭个k8s集群，踩了一些坑&lt;/p&gt;
&lt;h1 id=&quot;镜像&quot;&gt;2. 镜像&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kubeadm init&lt;/code&gt;命令会去&lt;code&gt;k8s.gcr.io&lt;/code&gt;拉镜像，这个地址是得挂代理才能上的（
      
    
    </summary>
    
      <category term="容器" scheme="https://htchz.cc/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://htchz.cc/tags/k8s/"/>
    
      <category term="deploy" scheme="https://htchz.cc/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>[网络]在浏览器输入一个url到页面展现发生了什么</title>
    <link href="https://htchz.cc/334107480.html"/>
    <id>https://htchz.cc/334107480.html</id>
    <published>2019-08-20T17:01:46.000Z</published>
    <updated>2020-06-11T04:10:48.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>被问起的时候总是两三句话就结束了。这一次想好好总结，描述我所知道的流程。</p><h1 id="过程">2. 过程</h1><h2 id="DNS">2.1. DNS</h2><p>向DNS发起请求，通常是udp协议，获得域名对应的ip地址。</p><p>查找顺序是：浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; ISP的DNS缓存 -&gt; 根服务器</p><h2 id="ARP">2.2. ARP</h2><p>如果不是同一网络的地址，按照路由表找下一跳的ip，通过广播ARP请求获得下一跳mac地址，将报文发往此地址。</p><p>目标网络的网关接收到此报文后，同样发起ARP广播请求，寻找目标ip对应的mac地址，将报文发往此地址。</p><h2 id="TCP三次握手">2.3. TCP三次握手</h2><p>发送端随机选择一个端口和接收端端口之间发起三次握手，之后建立起TCP连接。</p><blockquote><p>Linux执行<code>sysctl -a|grep ip_local_port_range</code>可以看到随机端口选择范围</p></blockquote><h2 id="MSS协商与TCP分段">2.4. MSS协商与TCP分段</h2><p>MSS，Maximum Segment Size，TCP报文数据不能大于这个值，MSS = MTU - IP首部长度，20 - TCP首部长度，20</p><p>为了得出路径最小MSS，TCP一端设置IP报文DF标志（Don’t Fragment flag）告诉IP层不要分片，这样IP必须分片的时候，就会传回一个ICMP差错报文。</p><p>高级的ICMP差错报文会返回发生差错的MTU大小，如果ICMP差错报文没有带回MTU大小，需要发送端不断减少MSS并重发报文，得出合适的MSS。注意，一段时间后TCP会重新协商路径最小MSS，调整路径最小MSS。</p><p>将一个数据分组根据MSS拆成多个TCP报文，这就是<strong>TCP分段</strong>。</p><h2 id="HTTP">2.5. HTTP</h2><p>建立起连接之后，发送HTTP报文。HTTP由<strong>请求行</strong>、<strong>请求头</strong>、<strong>请求主体</strong>组成。</p><ul><li>请求行只有一行，由<strong>方法</strong>，<strong>path</strong>，<strong>协议版本</strong>，以一个<code>\r\n</code>结束。</li><li>请求头由多对<code>key-value</code>组织而成，以一个<code>\r\n</code>换行，以两个<code>\r\n</code>结束。</li><li>请求主体，包含请求的数据/响应数据。</li></ul><p>http1.1版本加入了<code>Connection:Keep-Alive</code>,使得一个TCP连接可以复用多次，而不是一个请求建立起一次连接。<br>http2版本加入TCP多路复用。虽然http1.1版本可以复用TCP连接，但是一次只能发一个HTTP请求报文，想要并行发起多个请求，追能多建立TCP连接，而浏览器一般会限制并发6～8个连接，其余请求只能排队。加入TCP多路复用之后，减少了连接；此外http2采用了二进制传输，头部压缩大幅提高了性能。虽然二进制传输在调试过程不是很方便，但是调试工具都会帮我们转成明文格式展示。</p><blockquote><p>更多信息http2可参见<a href="https://juejin.im/post/5c4e6d11e51d4534dc477f05" target="_blank" rel="noopener">再谈HTTP2性能提升之背后原理—HTTP2历史解剖</a>。本站也有启用http2。</p></blockquote><h2 id="HTTPS">2.6. HTTPS</h2><p>如果启用用HTTPS，客户端会校验服务端的证书，根据证书和服务器协商一个对称加密算法和一个密钥，这一部分是RSA非对称加密，之后客户端和服务端会使用这个算法和密钥进行数据加密传输。HTTPS的原理出门左转<a href="https://zhuanlan.zhihu.com/p/26684050" target="_blank" rel="noopener">TLS完全指南（一）：TLS和安全通信</a>，这文章讲了HTTPS的部分内容，主要内容是证书方面的内容；还有一部分内容看<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a>，主要补充了用DH算法代替RSA进行密钥交换，避免了密钥在网络中传输。</p><h2 id="TCP拥塞控制">2.7. TCP拥塞控制</h2><p>TCP需要拥塞控制逻辑使用网络不好的情况，详见<a href="./3284953854.html">TCP拥塞控制那些事</a>。</p><h2 id="应用">2.8. 应用</h2><p>关于应用层, 大多数是请求走cdn-&gt;</p><h2 id="TCP四次挥手">2.9. TCP四次挥手</h2><p>发送端和接收端之间进行四次挥手断开连接，接着主动断开的端口进入<code>FIN_WAIT_1</code>，收到<strong>ACK报文</strong>后进入<code>FIN_WAIT_2</code>,收到接收端的<strong>FIN报文</strong>后最终会进入<code>TIME_WAIT</code>状态， 默认保持<code>2MSL</code>的不可用时间，防止<strong>相同五元组</strong>的连接建立后，收到上一代连接的重复报文，而产生混乱。被动断开的端口先进入<code>CLOSE_WAIT</code>，由服务器执行断开后发送<strong>FIN报文</strong>进入<code>LAST_ACK</code>状态，收到客户端<strong>ACK报文</strong>进入<code>CLOSED</code>状态。</p><h1 id="后记">3. 后记</h1><p>这个问题能反映出对计算机的网络的了解，其实算是一个能扯很久的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;被问起的时候总是两三句话就结束了。这一次想好好总结，描述我所知道的流程。&lt;/p&gt;
&lt;h1 id=&quot;过程&quot;&gt;2. 过程&lt;/h1&gt;&lt;h2 id=&quot;DNS&quot;&gt;2.1. DNS&lt;/h2&gt;&lt;p&gt;向DNS发起请求，通常是udp协议，获得域名对
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://htchz.cc/tags/TCP/"/>
    
      <category term="HTTP" scheme="https://htchz.cc/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>[分布式]Raft和ZAB的异同</title>
    <link href="https://htchz.cc/3841980432.html"/>
    <id>https://htchz.cc/3841980432.html</id>
    <published>2019-08-18T11:28:38.000Z</published>
    <updated>2020-06-18T14:22:32.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>为了学习<code>etcd</code>,先学习了解一下Raft协议，想总结一下Raft和zookeeper的ZAB协议协议的异同。</p><p>ZAB是对PAXOS算法的改进（没看过PASXOS，好像没有leader概念，我直接看的ZAB），增加了leader、follower、learner的角色。</p><p>Raft自称是比PAXOS更容易理解的一致性算法，和ZAB一样有leader、follower，而且一个强leader的算法。</p><h1 id="时间">2. 时间</h1><p>Raft：使用任期<code>term</code>表示一个选举轮次。  </p><p>ZAB：使用<code>electionEpoch</code>表示一个选举轮次。</p><h1 id="选举">3. 选举</h1><h2 id="投票">3.1. 投票</h2><p>Raft：忽略上一轮投票。选举过程只能进行一次投票，如果投过票了，收到投票请求就会无视。这样越早发起投票的人越有可能当leader；同时，也可能出现每个节点都没有收到majority的投票，出现投票被瓜分的情况。Raft采用设置随机的<strong>选举超时时间</strong>来解决投票被瓜分。  </p><p>ZAB：忽略上一轮投票。每次收到投票请求都会进行判定，然后若自己的投票有变，会重新通知所有节点。这样不会出现投票被瓜分，但是时间会比Raft多很多，导致<strong>服务可用性降低</strong>。</p><h2 id="投票pk">3.2. 投票pk</h2><p>Raft：term大的胜出，相同时<code>index</code>大的胜出</p><p>ZAB：<code>electionEpoch</code>大的胜出，相同时<code>zxid</code>大的胜出</p><h2 id="投票结果">3.3. 投票结果</h2><p>Raft：每个节点都只有自己的投票结果，如果发现自己投票过半，要通知所有节点，并发送心跳，<strong>心跳间隔</strong> &lt; <strong>选举超时时间</strong>.  </p><p>ZAB：每个节点保存所有节点的票根信息，每个节点收到投票请求后都会检查是否有过半的票根，如果有，会和leader建立起一个连接，leader会发送心跳。</p><h2 id="选举结束">3.4. 选举结束</h2><p>Raft：选举完可以立刻提供服务，对于节点不一致的问题，Raft靠接下来附加条目RPC来逐渐修复。按论文说的5台节点的集群，重新选举完成的时间平均是35ms，最长是150ms（选举超时时间配置为12-24ms）。  </p><p>ZAB：选举完得完成<strong>日志同步</strong>才能对外提供服务，而且ZAB的选举可能长达秒级的时间，导致<strong>服务可用性降低</strong>。</p><h1 id="分区容错性">4. 分区容错性</h1><p>当 可用节点 &gt; N/2，Raft和ZAB的集群都是可用的。</p><h1 id="客户端请求">5. 客户端请求</h1><h2 id="读（针对读请求落到follower的情况）">5.1. 读（针对读请求落到follower的情况）</h2><p>Raft：Raft的读其实有几个方案</p><ol><li><strong>强一致读</strong>：转发给leader；leader插入一个空日志获得readIndex；心跳广播(确认自己是leader，才能拥有最新日志)；等待状态机applyIndex经过readIndex（同步最新日志条目）；返回给follower；返回给客户端；</li><li><strong>在follower读</strong>：从leader获得readIndex；等待applyIndex经过readIndex；查询自身状态机；（从leader获得readIndex时，leader也要进行心跳广播）</li><li><strong>折中方案</strong>：leader在接受到majority心跳响应后一段时间内不广播，这是论文作者不推荐的，因为“响应后一段时间内”这个时间可能是不准确的。</li></ol><p>ZAB：follower直接返回，如果一个follower和leader未同步完成，follower返回的是脏数据，如果要保证数据最新，需要客户端调用<code>sync()</code>方法同步数据，正常情况下ZAB只保证最终一致性。</p><h2 id="写">5.2. 写</h2><h3 id="主要流程">5.2.1. 主要流程</h3><p>Raft:</p><ol><li>转发给leader;</li><li>leader将请求封装为entries，写入日志，得到在日志中的index，连同entries发送给followers，注意这可以是<strong>批量</strong>的</li><li>follower执行<strong>接收逻辑</strong>，如果成功写入文件，返回true</li><li>leader收到过半成功回复就更新<code>committIndex</code>，把entries应用到状态机中，回复客户端</li><li>leader下次心跳会带上<code>committIndex</code>的值用<code>leaderCommit</code>表示，followers发现<code>leaderCommit</code>大于自己维护的<code>committIndex</code>，就令 <code>commitIndex</code> 等于 <code>leaderCommit</code> 和 新日志条目索引值中较小的一个  </li></ol><p>ZAB：典型的两阶段提交</p><ol><li>转发给leader</li><li>leader封装为<strong>一个</strong><code>proposal</code>，写入日志，发送给followers</li><li>follower执行<strong>接收逻辑</strong>，如果成功写入文件，返回true</li><li>leader收到过半成功回复就提交<code>proposal</code>，同时广播一个<code>commit</code>消息，通知followers提交提议</li></ol><h3 id="接收逻辑">5.2.2. 接收逻辑</h3><p>Raft：如果<code>prevLogIndex</code>和<code>prevLogTerm</code>不匹配，返回false，由leader调整，从而达到在写请求再同步数据的目的  </p><p>ZAB：没有什么特别的，接收到<code>proposal</code>写入文件，接收到<code>commit</code>提交日志</p><h1 id="旧leader数据">6. 旧leader数据</h1><p>这个是指旧leader崩溃后，新leader对旧数据的处理</p><p>Raft：保守，过半或未过半日志都是未提交。只能提交当前term的日志，如果提交了当前日志，那么旧term的日志也会被一波提交（旧term的日志只能被间接提交）。允许出现未提交的数据被覆盖。</p><p>ZAB：激进，过半或未过半日志都被提交，由zookeeper选举完成后的数据同步完成。</p><h1 id="leader假死">7. leader假死</h1><p>Raft：leader和follower是没有连接的。旧leader假死后，新leader诞生，旧leader复活后发送带有<strong>旧term</strong>的RPCs，follower收到之后返回<strong>新term</strong>给旧leader，旧leader更新<code>term</code>，加入follower大军。 </p><p>ZAB：leader和follower存在连接。旧leader假死后，连接断开，旧leader进入LOOKING状态，从集群中学习投票结果/重新选举，最终找到leader建立起连接。</p><h1 id="请求异常">8. 请求异常</h1><p>Raft：重试，Raft要保证RPCs是幂等的。</p><p>ZAB：follower和leader断开连接，重新加入集群</p><h1 id="挂了的机器加入一个选举完成的集群（不是新加机器）">9. 挂了的机器加入一个选举完成的集群（不是新加机器）</h1><p>Raft：leader会对follower进行RPCs重试，所以恢复的follower会收到leader的心跳请求。</p><p>ZAB：恢复的follower会学习集群中的投票结果，可以识别到leader</p><h1 id="日志复制的顺序">10. 日志复制的顺序</h1><p>Raft：由leader维护log顺序。如果follower重启，不会阻塞leader写入请求，会按照leader顺序追赶日志；如果leader挂了，新leader也可以将旧term、新term日志按顺序提交。</p><p>ZAB：由leader维护log顺序。如果follower重启，会获取leader读锁，leader<strong>阻塞</strong>写入请求，接着追赶差异，获取leader已提交<code>proposal</code>和未提交<code>proposal</code>，然后再释放leader读锁；如果leader重启，新leader选举后会进行数据同步</p><h1 id="集群成员变更">11. 集群成员变更</h1><p>集群配置不能一下子全切换，否则同一个时期可能会出现两个leader。<br>Raft：使用两阶段变更。旧配置为<code>C-old</code>，新配置为<code>C-new</code>，<code>C-old-new</code>表示中间配置。配置变更命令由客户端发起，leader以log传播<code>C-old-new</code>，等<code>C-old-new</code>提交之后，再广播<code>C-new</code>配置，这时不在<code>C-new</code>里的机器就要自觉退出。Raft论文参与者后来还提出一个一阶段变更，提出限制<strong>一次变更只能添加或删除一个成员</strong>来简化问题，如果要变更多个成员，需要执行多次成员变更。</p><p>ZAB：3.5版本以前是停机的，但停机变更也有问题，3.5开始使用了动态变更成员，出门左转<a href="https://zhuanlan.zhihu.com/p/57128195" target="_blank" rel="noopener">Zab协议中的动态成员变更</a>，比Raft难理解😐，反正我是看不下去😐。</p><h1 id="总结">12. 总结</h1><p>Raft是在想解决PAXOS过于复杂的缺点的背景下提出来的一个一致性算法，之前也看过ZAB协议，感觉Raft可用性比ZAB高很多。</p><p>不过有个问题让我迷惑是，在两阶段成员变更方案里，如果提交了<code>C-old-new</code>后，还有旧的Server1，Server2没有复制到，Server1，Server2的配置还是<code>C-old</code><br><img src="../images/20200618222230.png" alt><br>这时候Server1，Server2发生了网络分区，那么这两台服务器还是可以产生基于<code>C-old</code>的leader，而Server3，Server4，Server5形成另一个<strong>majority</strong>，也可以产生一个leader，不一样还会出现双leader问题么？若使用一阶段成员变更，就可以阻止多个majority产生，杜绝这种情况吧。</p><p>很有兴趣实现一个Raft算法。</p><h1 id="参考">13. 参考</h1><ol><li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a>Raft论文汉化</li><li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm(Extended Version)</a>Raft论文原版</li><li><a href="https://mp.weixin.qq.com/s/8HkeYupmqeMjVlXGJDdlLg" target="_blank" rel="noopener">Raft对比ZAB协议</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;为了学习&lt;code&gt;etcd&lt;/code&gt;,先学习了解一下Raft协议，想总结一下Raft和zookeeper的ZAB协议协议的异同。&lt;/p&gt;
&lt;p&gt;ZAB是对PAXOS算法的改进（没看过PASXOS，好像没有leader概念，我
      
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="一致性算法" scheme="https://htchz.cc/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="raft" scheme="https://htchz.cc/tags/raft/"/>
    
      <category term="ZAB" scheme="https://htchz.cc/tags/ZAB/"/>
    
  </entry>
  
  <entry>
    <title>[网络]TCP拥塞控制那些事</title>
    <link href="https://htchz.cc/3284953854.html"/>
    <id>https://htchz.cc/3284953854.html</id>
    <published>2019-08-15T02:05:00.000Z</published>
    <updated>2020-06-08T09:53:39.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>看完了《TCP/IP详解 卷一》，对TCP/IP协议簇的认知多了一些。总结一下TCP窗口有关的慢启动、拥塞避免、快速重传、快速恢复的概念。</p><h1 id="TCP滑动窗口">2. TCP滑动窗口</h1><p>窗口有两种，通告窗口(Receiver Window,rwnd)和拥塞窗口(Congestion Window,cwnd)。  </p><ul><li>通告窗口：通告窗口表明了接收端当前的接受能力。TCP在发送端和接收端都是有缓冲区的，通告窗口声明了当前接收端的缓冲区还能接收的字节大小。这个数值会在TCP报文里携带。</li><li>拥塞窗口：拥塞窗口不被TCP报文传输，是发送端基于拥塞避免算法算出来的一个窗口。这个窗口限制了发送方的发送速率避免网络拥塞。</li></ul><p>两个窗口共同组成了一个滑动窗口。简单来说，通告窗口是强制限制，拥塞窗口是自发限制。</p><p>有一点要注意的是，窗口的单位用字节表示，但是拥塞窗口的调整总是以一个MSS的倍数来调整。</p><p>这里用书上的图描述滑动窗口，<br><img src="/images/pasted-178.png" alt="upload successful"><br>当一个TCP发送方发送数据的时候就会查看可用窗口能否发送（如果启用了Nagle算法，可用窗口必须大于等于一个MSS，发送方才发送数据）</p><p><img src="/images/pasted-177.png" alt="upload successful"><br>上面是抓包得到的一个报文，Win=2027是一个通告窗口，表示服务器的缓冲区还能接受2027字节的数据。</p><h1 id="拥塞控制">3. 拥塞控制</h1><p><img src="/images/pasted-183.png" alt="upload successful"><br>上图是一个tcp刚开始传输数据时的速率变化走向。</p><p>拥塞避免、慢启动、快速重传、快速恢复这四个词其实并不能单独分开讲。当一个连接的网络情况不好的时候，就会<strong>丢包</strong>或<strong>超时</strong>，这时就要降低发送方的发送速率防止恶化，这种就是拥塞控制。</p><p>这种机制涉及到cwnd和ssthresh两个指标，ssthresh是一个区分慢启动和拥塞避免的阈值，当拥塞发生时，分两种情况<br>超时：ssthresh = cwnd / 2（最小为2MSS），cwnd = 1MSS，进入慢启动<br>丢包：ssthresh = cwnd / 2（最小为2MSS），cwnd = ssthresh + 3MSS，进入快速重传</p><h1 id="慢启动">4. 慢启动</h1><p>慢启动其实是发送速率重新计算，cwnd 初始值为一个数据报大小，ssthresh初始值为65535，是一个然后在到达阈值之前，每接收到一个新的ACK，cwnd就会增加一个报文段的大小，这样子慢启动其实是以指数增加速率.</p><h1 id="拥塞控制-1">5. 拥塞控制</h1><p><img src="/images/pasted-185.png" alt="upload successful"><br>上图是一个tcp刚开始传输数据时的速率变化走向。</p><p>拥塞避免、慢启动、快速重传、快速恢复这四个词其实并不能单独分开讲。当一个连接的网络情况不好的时候，就会<strong>丢包</strong>或<strong>超时</strong>，这时就要降低发送方的发送速率防止恶化，这种就是拥塞控制。</p><p>这种机制涉及到cwnd和ssthresh两个指标，ssthresh是一个区分慢启动和拥塞避免的阈值，当拥塞发生时，分两种情况<br>超时：ssthresh = cwnd / 2（最小为2MSS），cwnd = 1MSS，进入慢启动<br>丢包：进入快速重传</p><h2 id="慢启动-1">5.1. 慢启动</h2><p>慢启动其实是发送速率重新计算，cwnd 初始值为一个数据报大小，ssthresh初始值为65535，是一个然后在到达阈值之前，每接收到一个新的ACK，cwnd就会增加一个报文段的大小，这样子慢启动其实是以指数增加网速到一个比较平衡的水平。</p><h2 id="拥塞避免">5.2. 拥塞避免</h2><p>当cwnd大于等于ssthresh时进入拥塞避免状态，在一个RTT内无论收到多少ACK都只将cwnd增加一个报文大小，从时间上来看网速线性增加。</p><h2 id="快速重传和快速恢复">5.3. 快速重传和快速恢复</h2><p>快速重传指，当收到重复的3个ACK报文时（duplicate ack），设置<code>ssthresh = cwnd / 2（最小为2MSS），cwnd = ssthresh + 3MSS</code>，然后进入快速恢复阶段。</p><p>暂停发送新的报文，重传丢失报文。</p><p>接下来每收到重复的ACK时，将cwnd增加一个报文大小。如果cwnd大于未确认报文大小（报文丢失后我们还在发新的报文，未确认报文指丢失报文到最后一个报文之间报文总大小），可以发送新报文。</p><p>接下来如果收到新的ACK报文，将cwnd设置为ssthresh，也就是网速降为一半，并进入拥塞避免阶段。</p><p>总的来说，网速一直处于一个动态调整的过程，一个连接上cwnd随时间的变化如图所示</p><p><img src="/images/pasted-182.png" alt="upload successful"></p><p>还有一点，上面关于cwnd的比较其实还要考虑rwnd的值，如果rwnd&gt;cwnd，应取rwnd去比较，毕竟两者决定了可用窗口大小。</p><h1 id="后记">6. 后记</h1><p>TCP拥塞控制其实还有很多改进未去了解。比如当收到重复的3个ACK报文时，其实不一定只丢了一个报文，所以网速可能指数下降，不能达到快速恢复的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;看完了《TCP/IP详解 卷一》，对TCP/IP协议簇的认知多了一些。总结一下TCP窗口有关的慢启动、拥塞避免、快速重传、快速恢复的概念。&lt;/p&gt;
&lt;h1 id=&quot;TCP滑动窗口&quot;&gt;2. TCP滑动窗口&lt;/h1&gt;&lt;p&gt;窗口有两种，
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://htchz.cc/tags/TCP/"/>
    
  </entry>
  
</feed>
