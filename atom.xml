<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>土川的自留地</title>
  
  <subtitle>via fennecs.huang@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://htchz.cc/"/>
  <updated>2019-12-06T07:51:22.548Z</updated>
  <id>https://htchz.cc/</id>
  
  <author>
    <name>土川</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[碎碎念]《Redis设计与实现》</title>
    <link href="https://htchz.cc/1473130276.html"/>
    <id>https://htchz.cc/1473130276.html</id>
    <published>2019-12-03T01:01:33.000Z</published>
    <updated>2019-12-06T07:51:22.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>《Redis设计与实现》第二版基于redis3.0，现在6.0都快出了。现在redis和书里有些内容已经不一致了，不过用来探索redis是挺好的。</p><h1 id="碎碎念">2. 碎碎念</h1><h2 id="编码">2.1. 编码</h2><p>现在的redis已经增加了quicklist、stream编码。</p><p>quicklist是ziplist和linkedlist的整合，作为list的唯一编码，其思想就是将ziplist分段，ziplist内存碎片少但每次操作都要申请内存，将ziplist分段，并用操作性能比较好的双向链表把段串起来，这算是时间与空间的折中。</p><p>stream编码用于消息队列，没有去了解。</p><h2 id="字典">2.2. 字典</h2><p>字典expand/resize是redis的一个大话题。</p><p>字典执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时负载因子必须达到5才能进行扩容，执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时不能进行缩容。</p><p>之所以，是因为<code>BGSAVE</code>或<code>BGREWRITEAOF</code>使用了<code>copy-on-write</code>，也就是写时复制。执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>时redis会fork子进程，这时候如果进行一个内存的拷贝（保证数据一致性），那么内存的浪费是很大的。使用写时复制，会将父进程的内存设置为只读，将内存和子进程共享，由于内存是分页机制，当某一页内存要发生写操作时，会发生中断，操作系统会把这一页内存复制出来进行修改。</p><p>因此，为了减少写操作导致内存页复制，redis才有了在上面的策略。</p><h2 id="下个2的幂">2.3. 下个2的幂</h2><p>redis在expand/resize都将新数组的长度设置为2的幂，这是因为把数组长度设置为2的幂，就可以把取模运算转化为位运算，java里也是这么做。</p><p>redis作者使用了这么一个算法来求给定一个数的下个2的幂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的循环，不过有人给他提出可以用位运算：<a href="https://github.com/antirez/redis/pull/3833" target="_blank" rel="noopener">传送门</a>，java里用的也是这个算法，<a href="./2353864749.html">HashMap的tableSizeFor()</a>。</p><p>作者说不错，但是没必要，这种位运算的魔法对现实来说都是假的，只会把代码搞复杂。</p><h2 id="EMBSTR">2.4. EMBSTR</h2><p>书里的<code>REDIS_ENCODING_EMBSTR</code>支持最大长度39字节，而现在最大支持44字节，原因是3.2版本之后sdshdr变了。<code>REDIS_ENCODING_EMBSTR</code>使用<code>sdshdr8</code>来表示，原来的sdshdr需要8字节，现在使用<code>sdshdr8</code>只需要三字节，那么：44 + 1（<code>&#39;\0&#39;</code>）+ 3 + 16(robj) = 64，刚好是64字节，可以达到64字节内存对齐。</p><p>作者一度用着44的限制，写着39的注释，让我一度迷惑。</p><h2 id="多线程">2.5. 多线程</h2><p>redis6.0加入了多线程，不知道和阿里云的多线程redis有什么区别，看起来都是在io线程并行，工作线程串行。</p><h2 id="raft">2.6. raft</h2><p>redis 领头sentinel选举和主节点选举都是采用raft协议的选举方式：同一个term里，一人一票；当得到majority的票时选举成功，当票被瓜分选举失败开始新一轮。</p><h2 id="LFU">2.7. LFU</h2><p>redis4.0新增了lfu策略来淘汰key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>通过redis.conf的设置，<code>unsigned lru:LRU_BITS</code>的有不同的表示。当表示lfu时，这个字段用8位来当作计数器，用16位当时间戳，16位长度只有两个字节，所以存的时间是以秒位单位。</p><p>在redis里lfu策略下，如果一个key被访问，那么计数器会增加，不过这种增加是需要乘上一个概率的，计数器越大，计数增加的几率越小；而同时key还要根据时间戳判断要不要衰减计数器，以此调整计数。</p><p>在这种策略下，redis会为key初始化一个5的计数器，防止key刚被初始化就被淘汰。</p><h2 id="BITSET">2.8. BITSET</h2><p>位图用来统计是很不错的一个数据类型，在redis里位图也是一个<code>sdshdr</code>，redis将一个字符用作8位，并把位图从低位往高位存储（sdshdr用buf数组存储字符串，当sdshdr表示位图时，buf数组从左往右是从低位到高位），这样当位图需要扩大的时候，只需要在buf数组尾部增加字符就可以了。</p><p>位图的统计的是一个有趣的问题，也就是统计一个二进制数的1有多少个。</p><p>暴力法不考虑，要说的是两个方法，<strong>查表法</strong>还有<strong>variable-precision SWAR算法</strong></p><h3 id="查表法">2.8.1. 查表法</h3><p>查表法就是预先给出各个数的二进制的1的数量，对于比较小的数字，这是一个速度最快的方法。</p><h3 id="variable-precision-SWAR算法">2.8.2. variable-precision SWAR算法</h3><p>这个方法采用位运算，而且还不占额外内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swar</span><span class="params">(<span class="keyword">uint32_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算每两位二进制数中1的个数</span></span><br><span class="line">    i = ( i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    <span class="comment">//计算每四位二进制数中1的个数</span></span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    <span class="comment">//计算每八位二进制数中1的个数</span></span><br><span class="line">    i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    <span class="comment">//将每八位二进制数中1的个数和相加，并移至最低位八位</span></span><br><span class="line">    i = (i * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个32位的数，通过位运算归并1的数量到4个字节中，最后用一个乘法汇总4个字节的1的数量到高8位，这个乘法过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">  x                             00000001 00000001 00000001 00000001</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                                00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">                       00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">              00000001 00000010 00000011 00000100</span><br><span class="line"></span><br><span class="line">     00000001 00000010 00000011 00000100</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">                               |00001010|·······no sense bit·······</span><br></pre></td></tr></table></figure><p>最后右移24位得到这8位的值。</p><h3 id="redis-bitcount">2.8.3. redis bitcount</h3><p>redis采用查法和variable-precision SWAR算法结合的方法来实现bitcount。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> redisPopcount(<span class="keyword">void</span> *s, <span class="keyword">long</span> count) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p4;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> bitsinbyte[<span class="number">256</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">        bits += bitsinbyte[*p++];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count bits 28 bytes at a time */</span></span><br><span class="line">    p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;=<span class="number">28</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4, aux5, aux6, aux7;</span><br><span class="line"></span><br><span class="line">        aux1 = *p4++;</span><br><span class="line">        aux2 = *p4++;</span><br><span class="line">        aux3 = *p4++;</span><br><span class="line">        aux4 = *p4++;</span><br><span class="line">        aux5 = *p4++;</span><br><span class="line">        aux6 = *p4++;</span><br><span class="line">        aux7 = *p4++;</span><br><span class="line">        count -= <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">        aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux2 = aux2 - ((aux2 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux2 = (aux2 &amp; <span class="number">0x33333333</span>) + ((aux2 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux3 = aux3 - ((aux3 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux3 = (aux3 &amp; <span class="number">0x33333333</span>) + ((aux3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux4 = aux4 - ((aux4 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux4 = (aux4 &amp; <span class="number">0x33333333</span>) + ((aux4 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux5 = aux5 - ((aux5 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux5 = (aux5 &amp; <span class="number">0x33333333</span>) + ((aux5 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux6 = aux6 - ((aux6 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux6 = (aux6 &amp; <span class="number">0x33333333</span>) + ((aux6 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux7 = aux7 - ((aux7 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux7 = (aux7 &amp; <span class="number">0x33333333</span>) + ((aux7 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux2 + (aux2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux3 + (aux3 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux4 + (aux4 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux5 + (aux5 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux6 + (aux6 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ((aux7 + (aux7 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>))* <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Count the remaining bytes. */</span></span><br><span class="line">    p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)p4;</span><br><span class="line">    <span class="keyword">while</span>(count--) bits += bitsinbyte[*p++];</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对于位图需要4字节对齐，因为redis里的SWAR算法一次操作4个字节，保证字节对齐可以提高内存读取速度，然后源码里有这么一段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">    bits += bitsinbyte[*p++];</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段我看了半天看不懂，最后在<a href="https://stackoverflow.com/questions/19190502/how-do-i-check-a-memory-address-is-32-bit-aligned-in-c" target="_blank" rel="noopener">How Do I check a Memory address is 32 bit aligned in C</a>找到答案，大概意思就是地址结尾是100的倍数，也就是<code>&amp; 11b = 0</code>，那么这个地址就是可以4字节对齐的。所以如果<code>(unsigned long)p &amp; 3</code>为true，说明地址不对齐，就要指针前进一个字节，并通过查表法计算这个字节的1的数量。</p><p>接着同时计算连续的28个字节，每4字节使用一次SWAR算法，再把7次结果汇总。</p><p>最后余下不足28字节的再用查表法计算。整个bitcount的过程就是这样。</p><h2 id="AOF">2.9. AOF</h2><p>即使开启<strong>appendfsync always</strong>配置，redis还是可能丢数据。</p><p>AOF主要靠<code>aof_buf</code>和AOF文件。</p><p>都说redis是基于事件循环的。在一次事件循环里，每个写事件redis都会追加到<code>aof_buf</code>中；每次事件循环后，redis都会把<code>aof_buf</code>的内容写进AOF文件里。但是AOF文件是不会实时刷入硬盘的，而<strong>appendfsync</strong>配置具体就是刷盘时机。开启<strong>appendfsync always</strong>配置后，每个事件循环都会进行刷盘，在这个模式下redis宕机，也会至多丢失一个事件循环的命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;《Redis设计与实现》第二版基于redis3.0，现在6.0都快出了。现在redis和书里有些内容已经不一致了，不过用来探索redis是挺好的。&lt;/p&gt;
&lt;h1 id=&quot;碎碎念&quot;&gt;2. 碎碎念&lt;/h1&gt;&lt;h2 id=&quot;编码&quot;&gt;2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[分布式]手撕raft</title>
    <link href="https://htchz.cc/1823228532.html"/>
    <id>https://htchz.cc/1823228532.html</id>
    <published>2019-10-03T08:27:57.000Z</published>
    <updated>2019-10-04T00:18:18.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>Raft作为一个简单的一致性算法，实现一下还是挺好玩的。代码基于<strong>6.824</strong> <a href="http://nil.csail.mit.edu/6.824/2018/labs/lab-raft.html" target="_blank" rel="noopener">lab-raft</a>，<strong>6.824</strong>是麻省理工的分布式课程的一个编号，里面有4个lab，第二个就是raft协议的实现，第三个是基于raft协议的kv存储设计，有待实现（oh我居然在做麻省理工的课程设计）。该lab要求使用go实现算法，并提供了一个<a href="http://oserror.com/distributed/golang-rpc-with-failure-simulation/" target="_blank" rel="noopener">具有故障模拟功能的RPC</a>，即通过模拟网络，在单台机器我们就可以运行raft算法。</p><blockquote><p>做实验前，你应该熟读raft论文，这里是<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">中文版</a></p></blockquote><h1 id="实现">2. 实现</h1><p>参照raft论文和lab提示，整体利用channel作为事件驱动、mutex保证线程安全，写出一个raft算法骨架还是比较容易的。不过在跑test的时候，小小的细节不对就会导致<code>test failed</code>。<br><img src="../images/20191004005135.png" alt><br><strong>raft-lab</strong>提供了17个test，检验了各种情况下的一致性，模拟了各种奇葩网络变化（网络变成这样还是跑路吧），要求4分钟内pass。</p><h2 id="数据结构">2.1. 数据结构</h2><p>参照论文，定义几个数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower = <span class="literal">iota</span></span><br><span class="line">Candidate</span><br><span class="line">Leader</span><br><span class="line"></span><br><span class="line">HeartbeatInterval = <span class="number">100</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ApplyMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">CommandValid <span class="keyword">bool</span></span><br><span class="line">Command      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">CommandIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="keyword">int</span></span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">LeaderId     <span class="keyword">int</span></span><br><span class="line">PrevLogIndex <span class="keyword">int</span></span><br><span class="line">PrevLogTerm  <span class="keyword">int</span></span><br><span class="line">Entries      []LogEntry</span><br><span class="line">LeaderCommit <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term      <span class="keyword">int</span></span><br><span class="line">Success   <span class="keyword">bool</span></span><br><span class="line">NextIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">currentTerm     <span class="keyword">int</span></span><br><span class="line">mu              sync.Mutex          <span class="comment">// Lock to protect shared access to this peer's state</span></span><br><span class="line">peers           []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister       *Persister          <span class="comment">// Object to hold this peer's persisted state</span></span><br><span class="line">me              <span class="keyword">int</span>                 <span class="comment">// this peer's index into peers[]</span></span><br><span class="line">state           <span class="keyword">int</span>                 <span class="comment">// 0:Follower 1:Candidate 2:Leader</span></span><br><span class="line">votedFor        <span class="keyword">int</span>                 <span class="comment">// 这个实验用index来代替节点</span></span><br><span class="line">voteCount       <span class="keyword">int</span></span><br><span class="line">commitIndex     <span class="keyword">int</span></span><br><span class="line">lastApplied     <span class="keyword">int</span></span><br><span class="line">currentLeaderId <span class="keyword">int</span></span><br><span class="line">log             []LogEntry</span><br><span class="line">nextIndex       []<span class="keyword">int</span></span><br><span class="line">matchIndex      []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">heartbeatCh <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">leaderCh    <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">commitCh    <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">CandidateId  <span class="keyword">int</span> <span class="comment">// 这个实验用index来代替节点</span></span><br><span class="line">LastLogIndex <span class="keyword">int</span></span><br><span class="line">LastLogTerm  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">VoteGranted <span class="keyword">bool</span> <span class="comment">// 是否支持</span></span><br><span class="line">Term        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小声bb，<code>AppendEntriesReply</code>论文是没有返回<code>nextIndex</code>的，而是由leader自己去<strong>减一重试</strong>，这其实是比较慢的，在设置了网络故障<strong>unreliable</strong>的test中，单纯的<strong>减一重试</strong>会导致raft集群在一定时间内不能达到一致。让follower过滤掉同一个term的index，并返回应该尝试的<code>nextIndex</code>，虽然会导致一次复制的日志变多，不过提高了集群达到一致的速度。</p><h2 id="一些封装">2.2. 一些封装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁/释放锁的封装，可以在利用`runtime.Caller`打印获取锁的调用点，虽然性能损失比较大。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字如其名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">getLastLogTerm</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">getLastLogIndex</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="raft实例初始化">2.3. raft实例初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span> *<span class="title">Raft</span></span> &#123;</span><br><span class="line">rf := &amp;Raft&#123;&#125;</span><br><span class="line">rf.peers = peers</span><br><span class="line">rf.persister = persister</span><br><span class="line">rf.me = me</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your initialization code here (2A, 2B, 2C).</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = <span class="number">0</span></span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">    rf.currentLeaderId = <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 初始化空白日志</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, LogEntry&#123;Term: <span class="number">0</span>&#125;)</span><br><span class="line">rf.applyCh = applyCh</span><br><span class="line"></span><br><span class="line">rf.heartbeatCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">rf.leaderCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">rf.commitCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化随机数资源库</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> rf.state &#123;</span><br><span class="line"><span class="keyword">case</span> Follower:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-rf.heartbeatCh:</span><br><span class="line"><span class="comment">// 这是lab要求心跳</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Int63()%<span class="number">333</span>+<span class="number">550</span>) * time.Millisecond):</span><br><span class="line">rf.state = Candidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Leader:</span><br><span class="line">rf.broadcastAppendEntries()</span><br><span class="line">time.Sleep(HeartbeatInterval)</span><br><span class="line"><span class="keyword">case</span> Candidate:</span><br><span class="line"><span class="keyword">go</span> rf.broadcastVote()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Int63()%<span class="number">300</span>+<span class="number">500</span>) * time.Millisecond): <span class="comment">//随机投票超时是必须的，为了防止票被瓜分完。</span></span><br><span class="line"><span class="keyword">case</span> &lt;-rf.heartbeatCh:</span><br><span class="line">rf.state = Follower</span><br><span class="line"><span class="keyword">case</span> &lt;-rf.leaderCh: </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&lt;-rf.commitCh</span><br><span class="line">rf.applyMsg(applyCh)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回一个raft实例，读取持久化数据，起了两个goroutine。</p><ul><li><p>goroutine1是raft三种状态的转化，这里的超时时间不宜设的太短（太短指论文里的时间），在lab文档里有指出为了配合test，选举超时时间应该<strong>larger than the paper’s 150 to 300 milliseconds</strong></p></li><li><p>goroutine2应用已提交日志。</p></li></ul><p>在初始化channel的时候应该设置缓冲大于1。多余的事件并不会导致系统不一致，但是若由于channel缓冲不够而导致阻塞，就会使raft节点死锁。</p><h2 id="votedFor清空时机">2.4. votedFor清空时机</h2><p>一次rpc，无论是发起端还是接收端，只要收到更大的term，就要调整自己的状态，发生下面变化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = remoteTerm</span><br></pre></td></tr></table></figure><p>可以看到<code>state</code>会变成<code>Follower</code>。</p><p>假设一种情景，ABC三个节点下，A为leader，此时C发生分区，那么C一定会不断循环进行超时选举，C的term会一直增大，当C网络恢复重新加入集群后会继续发投票请求rpc。由于C的投票请求rpc中的<code>term</code>较大，集群就会调整<code>currentTerm</code>以及<code>state</code>，已有leader会废掉。而问题是，C的请求投票是无意义的，却使集群进行了一次选举。针对这个问题有个<strong>preVote</strong>方案，就是在投票前调研一下自己是否有投票必要，如果没必要，就不发起投票。这篇文章暂无涉及<strong>preVote</strong>。</p><h2 id="投票发起与接收">2.5. 投票发起与接收</h2><h3 id="broadcastVote-发起投票">2.5.1. broadcastVote() 发起投票</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">broadcastVote</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line">rf.currentTerm++</span><br><span class="line">rf.voteCount = <span class="number">1</span></span><br><span class="line">rf.votedFor = rf.me</span><br><span class="line">vote := &amp;RequestVoteArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">CandidateId:  rf.me,</span><br><span class="line">LastLogIndex: rf.getLastLogIndex(),</span><br><span class="line">LastLogTerm:  rf.getLastLogTerm(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.persist()</span><br><span class="line">rf.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.state != Candidate &#123; <span class="comment">// 发送</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> vote.CandidateId == i &#123; <span class="comment">// 自己的票已经给自己了</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply RequestVoteReply</span><br><span class="line">ok := rf.sendRequestVote(server, vote, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般来说，reply.Term &gt; rf.currentTerm 的情况下 reply.VoteGranted 不会为true</span></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">rf.voteCount++</span><br><span class="line"><span class="keyword">if</span> rf.state == Candidate &amp;&amp; rf.voteCount &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">rf.becomeLeader()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendRequestVote</span><span class="params">(server <span class="keyword">int</span>, args *RequestVoteArgs, reply *RequestVoteReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">"Raft.RequestVote"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接收到投票reply后，查看票根是否过半，如果过半转化为leader。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有加锁，外部调用已经加锁了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.state = Leader</span><br><span class="line">rf.nextIndex = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">rf.matchIndex = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line"><span class="comment">// 初始化为0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">rf.leaderCh &lt;- <span class="literal">true</span> <span class="comment">// 结束选举阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestVote-接收投票">2.5.2. RequestVote 接收投票</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args *RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过期的投票请求</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果发起方的term比接收方大</span></span><br><span class="line"><span class="comment">// adjust current term</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &lt; args.Term &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upToDate := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm &gt; rf.getLastLogTerm() &#123;</span><br><span class="line">upToDate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm == rf.getLastLogTerm() &amp;&amp; args.LastLogIndex &gt;= rf.getLastLogIndex() &#123;</span><br><span class="line">upToDate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId) &amp;&amp; <span class="comment">// 保证有票</span></span><br><span class="line">upToDate &#123;</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = args.CandidateId</span><br><span class="line">rf.heartbeatCh &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1，进行投票后要发送心跳<code>rf.heartbeatCh &lt;- true</code>，不然节点会由<code>Follower</code>超时，从而使集群选举循环下去。<br>2，判断日志是否较新要满足其中一个条件：一，term较大，二，term一样，但日志index比较大</p><h2 id="日志复制与接收">2.6. 日志复制与接收</h2><h3 id="broadcastAppendEntries-广播日志-心跳">2.6.1. broadcastAppendEntries 广播日志/心跳</h3><p>日志复制lab文档要求一秒不能超过10次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">broadcastAppendEntries</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"></span><br><span class="line">N := rf.commitIndex</span><br><span class="line"><span class="keyword">for</span> i := rf.commitIndex + <span class="number">1</span>; i &lt;= rf.getLastLogIndex(); i++ &#123;</span><br><span class="line"><span class="comment">// 1 是leader本身</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line"><span class="comment">// 只能提交本term的，一旦提交了本term的，旧term也算提交了</span></span><br><span class="line"><span class="keyword">if</span> rf.me != j &amp;&amp; rf.matchIndex[j] &gt;= i &amp;&amp; rf.log[i].Term == rf.currentTerm &#123;</span><br><span class="line">num++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">N = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> N != rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = N</span><br><span class="line">rf.commitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.state != Leader &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123; <span class="comment">// 不用给自己心跳</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args AppendEntriesArgs</span><br><span class="line">args.Term = rf.currentTerm</span><br><span class="line">args.LeaderCommit = rf.commitIndex</span><br><span class="line">args.LeaderId = rf.me</span><br><span class="line">args.PrevLogIndex = rf.nextIndex[i] - <span class="number">1</span></span><br><span class="line">args.PrevLogTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">args.Entries = <span class="built_in">make</span>([]LogEntry, <span class="built_in">len</span>(rf.log[args.PrevLogIndex+<span class="number">1</span>:]))</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="built_in">copy</span>(args.Entries, rf.log[args.PrevLogIndex+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, args AppendEntriesArgs)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line">ok := rf.sendAppendEntries(i, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rf.handleAppendEntriesReply(&amp;args, &amp;reply, i)</span><br><span class="line">&#125;(i, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendAppendEntries</span><span class="params">(server <span class="keyword">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := rf.peers[server].Call(<span class="string">"Raft.AppendEntries"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次发送日志前，leader从<code>matchIndex[]</code>里统计出应该commit的index，如果index前进，发送commit事件。统计时要判断<code>rf.log[i].Term == rf.currentTerm</code>，也就是说只能提交自己term的log，一旦提交了自己term的log，之前term未被提交的log也算提交了。这个在论文有提到。</p><p>下面是复制日志的响应代码，也很直白。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reply 为 false， 如果不是任期问题，就是日志不匹配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">handleAppendEntriesReply</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.Unlock()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> rf.state != Leader &#123; <span class="comment">// 获取锁后校验自己的状态</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.Term != rf.currentTerm &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.persist()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">        <span class="comment">// len(args.Entries)  == 0 就是心跳了，不用处理</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) &gt; <span class="number">0</span> &#123;</span><br><span class="line">rf.matchIndex[i] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">rf.nextIndex[i] = rf.matchIndex[i] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[i] = reply.NextIndex <span class="comment">// 直接采用follower的建议</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppendEntries-接收日志">2.6.2. AppendEntries 接收日志</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">AppendEntries</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">defer</span> rf.persist()</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉老term的节点该更新啦</span></span><br><span class="line"><span class="keyword">if</span> rf.currentTerm &gt; args.Term &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 心跳</span></span><br><span class="line">rf.heartbeatCh &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// adjust current term</span></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这坨是在日志不匹配的情况下，对leader的NextIndex建议</span></span><br><span class="line"><span class="keyword">if</span> rf.getLastLogIndex() &lt; args.PrevLogIndex &#123;</span><br><span class="line">reply.NextIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">term := rf.log[args.PrevLogIndex].Term</span><br><span class="line"><span class="keyword">if</span> args.PrevLogTerm != term &#123;</span><br><span class="line"><span class="keyword">for</span> i := args.PrevLogIndex - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> rf.log[i].Term != term &#123;</span><br><span class="line">reply.NextIndex = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">reply.NextIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line"><span class="comment">// 删除已存在日志</span></span><br><span class="line">rf.log = rf.log[:args.PrevLogIndex+<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 附加新日志</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = Min(args.LeaderCommit, rf.getLastLogIndex())</span><br><span class="line">rf.commitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这理主要是<code>NextIndex</code>建议值的计算。</p><h2 id="将提交的日志应用至状态机">2.7. 将提交的日志应用至状态机</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">applyMsg</span><span class="params">(applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> &#123;</span><br><span class="line">rf.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.Unlock()</span><br><span class="line"><span class="keyword">for</span> i := rf.lastApplied + <span class="number">1</span>; i &lt;= rf.commitIndex; i++ &#123;</span><br><span class="line">msg := ApplyMsg&#123;</span><br><span class="line"><span class="literal">true</span>,</span><br><span class="line">rf.log[i].Command,</span><br><span class="line">i,</span><br><span class="line">&#125;</span><br><span class="line">applyCh &lt;- msg</span><br><span class="line">rf.lastApplied = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用过程其实是由test去管理的，我们只要负责把需要应用的日志放入<code>chan ApplyMsg</code>。</p><h2 id="持久化">2.8. 持久化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">persist</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := gob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">readPersist</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := gob.NewDecoder(r)</span><br><span class="line">d.Decode(&amp;rf.currentTerm)</span><br><span class="line">d.Decode(&amp;rf.votedFor)</span><br><span class="line">d.Decode(&amp;rf.log)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个持久化函数，持久化了<code>currentTerm</code>当前term,<code>votedFor</code>得票者,<code>log</code>日志数组，当这三个属性变化时，都执行一次<code>rf.persist()</code>就没错啦。</p><h1 id="后记">3. 后记</h1><p>表面是在贴代码，实际就是在贴代码。</p><p>由于实验是并发过程，一旦<code>test failed</code>是不容易按线性的过程来分析的。我的方法是多打日志，以及利用<code>net/http/pprof</code>包对程序的goroutine、mutex状态进行分析。</p><p>实现完以后我感觉又变强了（并没有）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;Raft作为一个简单的一致性算法，实现一下还是挺好玩的。代码基于&lt;strong&gt;6.824&lt;/strong&gt; &lt;a href=&quot;http://nil.csail.mit.edu/6.824/2018/labs/lab-raft.h
      
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="raft" scheme="https://htchz.cc/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>[容器]k8s部署踩坑</title>
    <link href="https://htchz.cc/2102019255.html"/>
    <id>https://htchz.cc/2102019255.html</id>
    <published>2019-08-25T06:06:02.000Z</published>
    <updated>2019-08-27T08:32:48.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>自己搭个k8s集群，踩了一些坑</p><h1 id="镜像">2. 镜像</h1><p><code>kubeadm init</code>命令会去<code>k8s.gcr.io</code>拉镜像，这个地址是得挂代理才能上的（可以指定地址忽略代理），可以用<code>kubeadm config images pull</code>尝试一下，十有八九是不行。不想挂代理的话，用下面这个方法。</p><p>先执行<code>kubeadm config images list</code>列出镜像，输出信息中有两行<code>WARN</code>是获取版本timeout可以不理会。</p><p>接着把列出来的信息放到下面的bash脚本中，运行脚本就把镜像下载好啦(其实就是从阿里云下镜像改tag)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">images=(  <span class="comment"># 下面的镜像应该去除"k8s.gcr.io"的前缀，版本换成上面获取到的版本</span></span><br><span class="line">kube-apiserver:v1.15.3</span><br><span class="line">kube-controller-manager:v1.15.3</span><br><span class="line">kube-scheduler:v1.15.3</span><br><span class="line">kube-proxy:v1.15.3</span><br><span class="line">pause:3.1</span><br><span class="line">etcd:3.3.10</span><br><span class="line">coredns:1.3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="token和ca-cert-hash">3. token和ca-cert-hash</h1><p>在master进行<code>kubeadm init</code>后会输出<code>token</code>和<code>ca-cert-hash</code>，这个要记住，如果忘记了虽然可以执行<code>kubeadm token list</code>获取<code>token</code>，但是<code>ca-cert-hash</code>是不会输出的，忘记<code>ca-cert-hash</code>只能重新执行<code>kubeadm token create</code>从输出中拿到。</p><h1 id="ip转发">4. ip转发</h1><p>在node主机执行<code>kubeadm join</code>的时候，报</p><pre><code>[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1`</code></pre><p>意思是没有开启ipv4转发，设置一下就好了：<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p><h1 id="时间同步">5. 时间同步</h1><p>在node主机执行<code>kubeadm join</code>的时候，一直卡住，加上<code>--v=2</code>可以输出详细信息，输出了一个信息</p><pre><code>I0824 21:58:46.950161   16866 token.go:146] [discovery] Failed to request cluster info, will try again: [Get https://192.168.0.113:6443/api/v1/namespaces/kube-public/configmaps/cluster-info: x509: certificate has expired or is not yet valid]`</code></pre><p>但是我的证书没过期呀，在一个issue里一位老哥说是不是几台机器时间没同步，我在node主机上执行<code>date</code>，果然时间和master差了好久，用于是ntp命令同步了一下时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ntpdate</span><br><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><h1 id="hostname">6. hostname</h1><p>在node主机执行<code>kubeadm join</code>的时候，要用<code>--node-name</code>指定节点名字，如果不指定，会用hostname，如果你和我一样主机是用vmware克隆出来的，几台机器的hostname都是一样的，就会执行<code>kubeadm join</code>成功，<code>kubectl get nodes</code>只有一台master(三台机hostname都是master)，<code>kubectl get pods --namespace kube-system</code>的pod也都只有一份。</p><h1 id="网桥地址重复">7. 网桥地址重复</h1><p><code>failed to set bridge addr: &quot;cni0&quot; already has an IP address different from 10.244.1.1/24</code>，执行<code>ip link delete cin0</code>删除<strong>cni0</strong>网桥</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;自己搭个k8s集群，踩了一些坑&lt;/p&gt;
&lt;h1 id=&quot;镜像&quot;&gt;2. 镜像&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kubeadm init&lt;/code&gt;命令会去&lt;code&gt;k8s.gcr.io&lt;/code&gt;拉镜像，这个地址是得挂代理才能上的（
      
    
    </summary>
    
      <category term="容器" scheme="https://htchz.cc/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://htchz.cc/tags/k8s/"/>
    
      <category term="部署" scheme="https://htchz.cc/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>[网络]在浏览器输入一个url到页面展现发生了什么</title>
    <link href="https://htchz.cc/334107480.html"/>
    <id>https://htchz.cc/334107480.html</id>
    <published>2019-08-20T17:01:46.000Z</published>
    <updated>2019-12-03T01:04:31.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>被问起的时候总是两三句话就结束了。这一次想好好总结，描述我所知道的流程。</p><h1 id="过程">2. 过程</h1><h2 id="DNS">2.1. DNS</h2><p>向DNS发起请求，通常是udp协议，获得域名对应的ip地址。</p><p>查找顺序是：浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; ISP的DNS缓存 -&gt; 根服务器</p><h2 id="ARP">2.2. ARP</h2><p>如果不是同一网络的地址，按照路由表找下一跳的ip，通过广播ARP请求获得下一跳mac地址，将报文发往此地址。</p><p>目标网络的网关接收到此报文后，同样发起ARP广播请求，寻找目标ip对应的mac地址，将报文发往此地址。</p><h2 id="TCP三次握手">2.3. TCP三次握手</h2><p>发送端随机选择一个端口和接收端端口之间发起三次握手，之后建立起TCP连接。</p><blockquote><p>Linux执行<code>sysctl -a|grep ip_local_port_range</code>可以看到随机端口选择范围</p></blockquote><h2 id="MSS协商与TCP分段">2.4. MSS协商与TCP分段</h2><p>MSS，Maximum Segment Size，TCP报文数据不能大于这个值，MSS = MTU - IP首部长度，20 - TCP首部长度，20</p><p>为了得出路径最小MSS，TCP一端设置IP报文DF标志（Don’t Fragment flag）告诉IP层不要分片，这样IP必须分片的时候，就会传回一个ICMP差错报文。</p><p>高级的ICMP差错报文会返回发生差错的MTU大小，如果ICMP差错报文没有带回MTU大小，需要发送端不断减少MSS并重发报文，得出合适的MSS。注意，一段时间后TCP会重新协商路径最小MSS，调整路径最小MSS。</p><p>将一个数据分组根据MSS拆成多个TCP报文，这就是<strong>TCP分段</strong>。</p><h2 id="HTTP">2.5. HTTP</h2><p>建立起连接之后，发送HTTP报文。HTTP由<strong>请求行</strong>、<strong>请求头</strong>、<strong>请求主体</strong>组成。</p><ul><li>请求行只有一行，由<strong>方法</strong>，<strong>path</strong>，<strong>协议版本</strong>，以一个<code>\r\n</code>结束。</li><li>请求头由多对<code>key-value</code>组织而成，以一个<code>\r\n</code>换行，以两个<code>\r\n</code>结束。</li><li>请求主体，包含请求的数据/响应数据。</li></ul><p>http1.1版本加入了<code>Connection:Keep-Alive</code>,使得一个TCP连接可以复用多次，而不是一个请求建立起一次连接。<br>http2版本加入TCP多路复用。虽然http1.1版本可以复用TCP连接，但是一次只能发一个HTTP请求报文，想要并行发起多个请求，追能多建立TCP连接，而浏览器一般会限制并发6～8个连接，其余请求只能排队。加入TCP多路复用之后，减少了连接；此外http2采用了二进制传输，头部压缩大幅提高了性能。虽然二进制传输在调试过程不是很方便，但是调试工具都会帮我们转成明文格式展示。</p><blockquote><p>更多信息http2可参见<a href="https://juejin.im/post/5c4e6d11e51d4534dc477f05" target="_blank" rel="noopener">再谈HTTP2性能提升之背后原理—HTTP2历史解剖</a>。本站也有启用http2。</p></blockquote><h2 id="HTTPS">2.6. HTTPS</h2><p>如果启用用HTTPS，客户端会校验服务端的证书，根据证书和服务器协商一个对称加密算法和一个密钥，这一部分是RSA非堆成加密，之后客户端和服务端会使用这个算法和密钥进行数据加密传输。HTTPS的原理出门左转<a href="https://zhuanlan.zhihu.com/p/26684050" target="_blank" rel="noopener">TLS完全指南（一）：TLS和安全通信</a>，这文章讲了HTTPS的部分内容，主要内容是证书方面的内容；还有一部分内容看<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a>，主要补充了用DH算法代替RSA进行密钥交换，避免了密钥在网络中传输。</p><h2 id="TCP拥塞控制">2.7. TCP拥塞控制</h2><p>TCP需要拥塞控制逻辑使用网络不好的情况，详见<a href="./3284953854.html">TCP拥塞控制那些事</a>。</p><h2 id="应用">2.8. 应用</h2><p>关于应用层面的就不说了。</p><h2 id="TCP四次挥手">2.9. TCP四次挥手</h2><p>发送端和接收端之间进行四次挥手断开连接，接着主动断开的端口进入<code>FIN_WAIT_1</code>，收到<strong>ACK报文</strong>后进入<code>FIN_WAIT_2</code>,收到接收端的<strong>FIN报文</strong>后最终会进入<code>TIME_WAIT</code>状态， 默认保持<code>2MSL</code>的不可用时间，防止<strong>相同五元组</strong>的连接建立后，收到上一代连接的重复报文，而产生混乱。被动断开的端口先进入<code>CLOSE_WAIT</code>，由服务器执行断开后发送<strong>FIN报文</strong>进入<code>LAST_ACK</code>状态，收到客户端<strong>ACK报文</strong>进入<code>CLOSED</code>状态。</p><h1 id="后记">3. 后记</h1><p>这个问题能反映出对计算机的网络的了解，其实算是一个能扯很久的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;被问起的时候总是两三句话就结束了。这一次想好好总结，描述我所知道的流程。&lt;/p&gt;
&lt;h1 id=&quot;过程&quot;&gt;2. 过程&lt;/h1&gt;&lt;h2 id=&quot;DNS&quot;&gt;2.1. DNS&lt;/h2&gt;&lt;p&gt;向DNS发起请求，通常是udp协议，获得域名对
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://htchz.cc/tags/TCP/"/>
    
      <category term="HTTP" scheme="https://htchz.cc/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>[分布式]Raft和ZAB的异同</title>
    <link href="https://htchz.cc/3841980432.html"/>
    <id>https://htchz.cc/3841980432.html</id>
    <published>2019-08-18T11:28:38.000Z</published>
    <updated>2019-10-03T08:30:45.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>为了学习<code>etcd</code>,先学习了解一下Raft协议，想总结一下Raft和zookeeper的ZAB协议协议的异同。</p><p>ZAB是对PAXOS算法的改进（没看过PASXOS，好像没有leader概念，我直接看的ZAB），增加了leader、follower、learner的角色。</p><p>Raft自称是比PAXOS更容易理解的一致性算法，和ZAB一样有leader、follower，而且一个强leader的算法。</p><h1 id="时间">2. 时间</h1><p>Raft：使用任期<code>term</code>表示一个选举轮次。  </p><p>ZAB：使用<code>electionEpoch</code>表示一个选举轮次。</p><h1 id="选举">3. 选举</h1><h2 id="投票">3.1. 投票</h2><p>Raft：忽略上一轮投票。选举过程只能进行一次投票，如果投过票了，收到投票请求就会无视。这样越早发起投票的人越有可能当leader；同时，也可能出现每个节点都没有收到majority的投票，出现投票被瓜分的情况。Raft采用设置随机的<strong>选举超时时间</strong>来解决投票被瓜分。  </p><p>ZAB：忽略上一轮投票。每次收到投票请求都会进行判定，然后若自己的投票有变，会重新通知所有节点。这样不会出现投票被瓜分，但是时间会比Raft多很多，导致<strong>服务可用性降低</strong>。</p><h2 id="投票pk">3.2. 投票pk</h2><p>Raft：term大的胜出，相同时<code>index</code>大的胜出</p><p>ZAB：<code>electionEpoch</code>大的胜出，相同时<code>zxid</code>大的胜出</p><h2 id="投票结果">3.3. 投票结果</h2><p>Raft：每个节点都只有自己的投票结果，如果发现自己投票过半，要通知所有节点，并发送心跳，<strong>心跳间隔</strong> &lt; <strong>选举超时时间</strong>.  </p><p>ZAB：每个节点保存所有节点的票根信息，每个节点收到投票请求后都会检查是否有过半的票根，如果有，会和leader建立起一个连接，leader会发送心跳。</p><h2 id="选举结束">3.4. 选举结束</h2><p>Raft：选举完可以立刻提供服务，对于节点不一致的问题，Raft靠接下来附加条目RPC来逐渐修复。按论文说的5台节点的集群，重新选举完成的时间平均是35ms，最长是150ms（选举超时时间配置为12-24ms）。  </p><p>ZAB：选举完得完成<strong>日志同步</strong>才能对外提供服务，而且ZAB的选举可能长达秒级的时间，导致<strong>服务可用性降低</strong>。</p><h1 id="分区容错性">4. 分区容错性</h1><p>当 可用节点 &gt; N/2，Raft和ZAB的集群都是可用的。</p><h1 id="客户端请求">5. 客户端请求</h1><h2 id="读（针对读请求落到follower的情况）">5.1. 读（针对读请求落到follower的情况）</h2><p>Raft：Raft的读其实有几个方案</p><ol><li><strong>强一致读</strong>：转发给leader；leader插入一个空日志获得readIndex；心跳广播(确认自己是leader，才能拥有最新日志)；等待状态机applyIndex经过readIndex（同步最新日志条目）；返回给follower；返回给客户端；</li><li><strong>在follower读</strong>：从leader获得readIndex；等待applyIndex经过readIndex；查询自身状态机；（从leader获得readIndex时，leader也要进行心跳广播）</li><li><strong>折中方案</strong>：leader在接受到majority心跳响应后一段时间内不广播，这是论文作者不推荐的，因为“响应后一段时间内”这个时间可能是不准确的。</li></ol><p>ZAB：follower直接返回，如果一个follower和leader未同步完成，follower返回的是脏数据，如果要保证数据最新，需要客户端调用<code>sync()</code>方法同步数据，正常情况下ZAB只保证最终一致性。</p><h2 id="写">5.2. 写</h2><h3 id="主要流程">5.2.1. 主要流程</h3><p>Raft:</p><ol><li>转发给leader;</li><li>leader将请求封装为entries，写入日志，得到在日志中的index，连同entries发送给followers，注意这可以是<strong>批量</strong>的</li><li>follower执行<strong>接收逻辑</strong>，如果成功写入文件，返回true</li><li>leader收到过半成功回复就更新<code>committIndex</code>，把entries应用到状态机中，回复客户端</li><li>leader下次心跳会带上<code>committIndex</code>的值用<code>leaderCommit</code>表示，followers发现<code>leaderCommit</code>大于自己维护的<code>committIndex</code>，就令 <code>commitIndex</code> 等于 <code>leaderCommit</code> 和 新日志条目索引值中较小的一个  </li></ol><p>ZAB：典型的两阶段提交</p><ol><li>转发给leader</li><li>leader封装为<strong>一个</strong><code>proposal</code>，写入日志，发送给followers</li><li>follower执行<strong>接收逻辑</strong>，如果成功写入文件，返回true</li><li>leader收到过半成功回复就提交<code>proposal</code>，同时广播一个<code>commit</code>消息，通知followers提交提议</li></ol><h3 id="接收逻辑">5.2.2. 接收逻辑</h3><p>Raft：如果<code>prevLogIndex</code>和<code>prevLogTerm</code>不匹配，返回false，由leader调整，从而达到在写请求再同步数据的目的  </p><p>ZAB：没有什么特别的，接收到<code>proposal</code>写入文件，接收到<code>commit</code>提交日志</p><h1 id="旧leader数据">6. 旧leader数据</h1><p>这个是指旧leader崩溃后，新leader对旧数据的处理</p><p>Raft：保守，过半或未过半日志都是未提交。只能提交当前term的日志，如果提交了当前日志，那么旧term的日志也会被一波提交（旧term的日志只能被间接提交）。允许出现未提交的数据被覆盖。</p><p>ZAB：激进，过半或未过半日志都被提交，由zookeeper选举完成后的数据同步完成。</p><h1 id="leader假死">7. leader假死</h1><p>Raft：leader和follower是没有连接的。旧leader假死后，新leader诞生，旧leader复活后发送带有<strong>旧term</strong>的RPCs，follower收到之后返回<strong>新term</strong>给旧leader，旧leader更新<code>term</code>，加入follower大军。 </p><p>ZAB：leader和follower存在连接。旧leader假死后，连接断开，旧leader进入LOOKING状态，从集群中学习投票结果/重新选举，最终找到leader建立起连接。</p><h1 id="请求异常">8. 请求异常</h1><p>Raft：重试，Raft要保证RPCs是幂等的。</p><p>ZAB：follower和leader断开连接，重新加入集群</p><h1 id="挂了的机器加入一个选举完成的集群（不是新加机器）">9. 挂了的机器加入一个选举完成的集群（不是新加机器）</h1><p>Raft：leader会对follower进行RPCs重试，所以恢复的follower会收到leader的心跳请求。</p><p>ZAB：恢复的follower会学习集群中的投票结果，可以识别到leader</p><h1 id="日志复制的顺序">10. 日志复制的顺序</h1><p>Raft：由leader维护log顺序。如果follower重启，不会阻塞leader写入请求，会按照leader顺序追赶日志；如果leader挂了，新leader也可以将旧term、新term日志按顺序提交。</p><p>ZAB：由leader维护log顺序。如果follower重启，会获取leader读锁，leader<strong>阻塞</strong>写入请求，接着追赶差异，获取leader已提交<code>proposal</code>和未提交<code>proposal</code>，然后再释放leader读锁；如果leader重启，新leader选举后会进行数据同步</p><h1 id="集群成员变更">11. 集群成员变更</h1><p>集群配置不能一下子全切换，否则同一个时期可能会出现两个leader。<br>Raft：使用两阶段变更。旧配置为<code>C-old</code>，新配置为<code>C-new</code>，<code>C-old-new</code>表示中间配置。配置变更命令由客户端发起，leader以log传播<code>C-old-new</code>，等<code>C-old-new</code>提交之后，再广播<code>C-new</code>配置，这时不在<code>C-new</code>里的机器就要自觉退出。Raft论文参与者后来还提出一个一阶段变更，提出限制<strong>一次变更只能添加或删除一个成员</strong>来简化问题，如果要变更多个成员，需要执行多次成员变更。</p><p>ZAB：3.5版本以前是停机的，但停机变更也有问题，3.5开始使用了动态变更成员，出门左转<a href="https://zhuanlan.zhihu.com/p/57128195" target="_blank" rel="noopener">Zab协议中的动态成员变更</a>，比Raft难理解😐，反正我是看不下去😐。</p><h1 id="总结">12. 总结</h1><p>Raft是在想解决PAXOS过于复杂的缺点的背景下提出来的一个一致性算法，之前也看过ZAB协议，感觉Raft可用性比ZAB高很多。</p><p>不过有个问题让我迷惑是，在两阶段成员变更方案里，如果提交了<code>C-old-new</code>后，还有旧的Server1，Server2没有复制到，Server1，Server2的配置还是<code>C-old</code><br><img src="../images/20190822194828.png" alt><br>这时候Server1，Server2发生了网络分区，那么这两台服务器还是可以产生基于<code>C-old</code>的leader，而Server3，Server4，Server5形成另一个<strong>majority</strong>，也可以产生一个leader，不一样还会出现双leader问题么？若使用一阶段成员变更，就可以阻止多个majority产生，杜绝这种情况吧。</p><p>很有兴趣实现一个Raft算法。</p><h1 id="参考">13. 参考</h1><ol><li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a>Raft论文汉化</li><li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm(Extended Version)</a>Raft论文原版</li><li><a href="https://mp.weixin.qq.com/s/8HkeYupmqeMjVlXGJDdlLg" target="_blank" rel="noopener">Raft对比ZAB协议</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;为了学习&lt;code&gt;etcd&lt;/code&gt;,先学习了解一下Raft协议，想总结一下Raft和zookeeper的ZAB协议协议的异同。&lt;/p&gt;
&lt;p&gt;ZAB是对PAXOS算法的改进（没看过PASXOS，好像没有leader概念，我
      
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="一致性算法" scheme="https://htchz.cc/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="raft" scheme="https://htchz.cc/tags/raft/"/>
    
      <category term="ZAB" scheme="https://htchz.cc/tags/ZAB/"/>
    
  </entry>
  
  <entry>
    <title>[网络]TCP拥塞控制那些事</title>
    <link href="https://htchz.cc/3284953854.html"/>
    <id>https://htchz.cc/3284953854.html</id>
    <published>2019-08-15T02:05:00.000Z</published>
    <updated>2019-08-22T06:21:52.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>看完了《TCP/IP详解 卷一》，对TCP/IP协议簇的认知多了一些。总结一下TCP窗口有关的慢启动、拥塞避免、快速重传、快速恢复的概念。</p><h1 id="TCP滑动窗口">2. TCP滑动窗口</h1><p>窗口有两种，通告窗口(Receiver Window,rwnd)和拥塞窗口(Congestion Window,cwnd)。  </p><ul><li>通告窗口：通告窗口表明了接收端当前的接受能力。TCP在发送端和接收端都是有缓冲区的，通告窗口声明了当前接收端的缓冲区还能接收的字节大小。这个数值会在TCP报文里携带。</li><li>拥塞窗口：拥塞窗口不被TCP报文传输，是发送端基于拥塞避免算法算出来的一个窗口。这个窗口限制了发送方的发送速率避免网络拥塞。</li></ul><p>两个窗口共同组成了一个滑动窗口。简单来说，通告窗口是强制限制，拥塞窗口是自发限制。</p><p>有一点要注意的是，窗口的单位用字节表示，但是拥塞窗口的调整总是以一个MSS的倍数来调整。</p><p>这里用书上的图描述滑动窗口，<br><img src="/images/pasted-178.png" alt="upload successful"><br>当一个TCP发送方发送数据的时候就会查看可用窗口能否发送（如果启用了Nagle算法，可用窗口必须大于等于一个MSS，发送方才发送数据）</p><p><img src="/images/pasted-177.png" alt="upload successful"><br>上面是抓包得到的一个报文，Win=2027是一个通告窗口，表示服务器的缓冲区还能接受2027字节的数据。</p><h1 id="拥塞控制">3. 拥塞控制</h1><p><img src="/images/pasted-183.png" alt="upload successful"><br>上图是一个tcp刚开始传输数据时的速率变化走向。</p><p>拥塞避免、慢启动、快速重传、快速恢复这四个词其实并不能单独分开讲。当一个连接的网络情况不好的时候，就会<strong>丢包</strong>或<strong>超时</strong>，这时就要降低发送方的发送速率防止恶化，这种就是拥塞控制。</p><p>这种机制涉及到cwnd和ssthresh两个指标，ssthresh是一个区分慢启动和拥塞避免的阈值，当拥塞发生时，分两种情况<br>超时：ssthresh = cwnd / 2（最小为2MSS），cwnd = 1MSS，进入慢启动<br>丢包：ssthresh = cwnd / 2（最小为2MSS），cwnd = ssthresh + 3MSS，进入快速重传</p><h1 id="慢启动">4. 慢启动</h1><p>慢启动其实是发送速率重新计算，cwnd 初始值为一个数据报大小，ssthresh初始值为65535，是一个然后在到达阈值之前，每接收到一个新的ACK，cwnd就会增加一个报文段的大小，这样子慢启动其实是以指数增加网络传</p><h1 id="拥塞控制-1">5. 拥塞控制</h1><p><img src="/images/pasted-185.png" alt="upload successful"><br>上图是一个tcp刚开始传输数据时的速率变化走向。</p><p>拥塞避免、慢启动、快速重传、快速恢复这四个词其实并不能单独分开讲。当一个连接的网络情况不好的时候，就会<strong>丢包</strong>或<strong>超时</strong>，这时就要降低发送方的发送速率防止恶化，这种就是拥塞控制。</p><p>这种机制涉及到cwnd和ssthresh两个指标，ssthresh是一个区分慢启动和拥塞避免的阈值，当拥塞发生时，分两种情况<br>超时：ssthresh = cwnd / 2（最小为2MSS），cwnd = 1MSS，进入慢启动<br>丢包：进入快速重传</p><h2 id="慢启动-1">5.1. 慢启动</h2><p>慢启动其实是发送速率重新计算，cwnd 初始值为一个数据报大小，ssthresh初始值为65535，是一个然后在到达阈值之前，每接收到一个新的ACK，cwnd就会增加一个报文段的大小，这样子慢启动其实是以指数增加网速到一个比较平衡的水平。</p><h2 id="拥塞避免">5.2. 拥塞避免</h2><p>当cwnd大于等于ssthresh时进入拥塞避免状态，在一个RTT内无论收到多少ACK都只将cwnd增加一个报文大小，从时间上来看网速线性增加。</p><h2 id="快速重传和快速恢复">5.3. 快速重传和快速恢复</h2><p>快速重传指，当收到重复的3个ACK报文时（duplicate ack），设置<code>ssthresh = cwnd / 2（最小为2MSS），cwnd = ssthresh + 3MSS</code>，然后进入快速恢复阶段。</p><p>暂停发送新的报文，重传丢失报文。</p><p>接下来每收到重复的ACK时，将cwnd增加一个报文大小。如果cwnd大于未确认报文大小（报文丢失后我们还在发新的报文，未确认报文指丢失报文到最后一个报文之间报文总大小），可以发送新报文。</p><p>接下来如果收到新的ACK报文，将cwnd设置为ssthresh，也就是网速降为一半，并进入拥塞避免阶段。</p><p>总的来说，网速一直处于一个动态调整的过程，一个连接上cwnd随时间的变化如图所示</p><p><img src="/images/pasted-182.png" alt="upload successful"></p><p>还有一点，上面关于cwnd的比较其实还要考虑rwnd的值，如果rwnd&gt;cwnd，应取rwnd去比较，毕竟两者决定了可用窗口大小。</p><h1 id="后记">6. 后记</h1><p>TCP拥塞控制其实还有很多改进未去了解。比如当收到重复的3个ACK报文时，其实不一定只丢了一个报文，所以网速可能指数下降，不能达到快速恢复的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;看完了《TCP/IP详解 卷一》，对TCP/IP协议簇的认知多了一些。总结一下TCP窗口有关的慢启动、拥塞避免、快速重传、快速恢复的概念。&lt;/p&gt;
&lt;h1 id=&quot;TCP滑动窗口&quot;&gt;2. TCP滑动窗口&lt;/h1&gt;&lt;p&gt;窗口有两种，
      
    
    </summary>
    
      <category term="网络" scheme="https://htchz.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://htchz.cc/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]给机器加个监控</title>
    <link href="https://htchz.cc/3663317463.html"/>
    <id>https://htchz.cc/3663317463.html</id>
    <published>2019-07-20T05:49:00.000Z</published>
    <updated>2019-07-20T12:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>明明只有一台破机器，却要装成用不起的样子</p><p><img src="/images/pasted-176.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;明明只有一台破机器，却要装成用不起的样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-176.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="碎碎念" scheme="https://htchz.cc/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>[FCM]用FCM做一个跨设备消息同步工具</title>
    <link href="https://htchz.cc/2379284348.html"/>
    <id>https://htchz.cc/2379284348.html</id>
    <published>2019-05-18T03:00:00.000Z</published>
    <updated>2019-05-20T07:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Fcm真是个好东西，希望你也有。</p><a id="more"></a><h1 id="需求背景">1. 需求背景</h1><p>作为一个穷人，手持不了iPhone(滑稽)，当同时使用着macOS、windows、安卓三个平台时，我面临着几个问题：</p><ol><li>传文件。对于传文件，有许多方案，我偏向于用Feem或者共享文件夹，都是局域网传输，又快又不用经过第三方服务器。</li><li>复制文本。iPhone和mac之间有通用剪切板，win10和iPhone、安卓之间有微软小娜。</li><li>通知同步。主要是手机通知，上班工作时，听到手机推送的声音想知道时什么东西又懒得去看手机。</li><li>短信验证码。电脑上用短信验证码场景并不是很多，不过我们公司的线上服务器登录时需要短信验证码的二次验证，这时候去解锁手机、看验证码、一个一个输入终端。。。妈蛋很烦。</li></ol><p>于是找了一堆，AirDroid、Pushbullet等等，在到处讲隐私的今天，我觉得把自己的剪切板、短信、通知就这么发送给人家总是有点不安（不过用fcm也是把数据给号称‘不作恶’口号的谷歌）。偶然看到了剪纸云，是个收费软件，不过看了简介说是用FCM做的，找了下FCM的接入指北，自己做一个同步工具。</p><h1 id="整体流程">2. 整体流程</h1><p><img src="/images/pasted-174.png" alt="upload successful"></p><p>数据的流向如图，终端把要同步的数据发到自己的应用服务器，应用服务器载把数据发到FCM，交由FCM推送到设备组。</p><p>对于每一台设备，当应用与FCM建立起连接后可以得到一个fcm token，这个token就是这台设备这个应用的id了。</p><p>至于设备组id，我是用Firebase-Auth的userId作为设备组id的。</p><p>程序主要流程是：</p><ol><li>客户端启动时获取fcm token，持久化存储（这个fcm token除非把应用删了和我不知道的情况，否则万年不更新一次，当然fcm sdk提供了更新的回调，我们要实现这个方法。）</li><li>客户端登录，拉起谷歌的OAuth2.0授权（Chrome插件用的clientId模式），登录成功后获取到firebase-auth的userId，持久化存储</li><li>登录成功后把userId和fcm token发送到应用服务器保存，维护双向关系，完成注册。</li><li>客户端每次发送同步数据时，带上时间戳、同步类型、fcm token等内容。</li><li>客户端接受到fcm推送时，见机行事。</li></ol><p>同步数据的数据结构</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>短信、通知、剪切板</td></tr><tr><td>time</td><td>毫秒时间戳，也作为分片id（其实是偷懒）</td></tr><tr><td>text</td><td>文本内容</td></tr><tr><td>head</td><td>额外内容，主要是为了存通知的通知标题</td></tr><tr><td>fcm_token</td><td>设备id</td></tr><tr><td>mark</td><td>分片的标识，8位整数，高位起第一位表示是否分片，第二位表示是否还有分片，余下6位表示分片顺序</td></tr></tbody></table><h1 id="服务端">3. 服务端</h1><p>服务端用go写的，框架使用gin，数据库用redis。</p><p>主要维护两个关系。</p><ol><li>设备id到设备组id的关系</li><li>设备组id到所有设备id的关系</li></ol><p>第一个直接用redis的kv模型，第二个用redis的哈希模型。</p><p>当服务器接收到客户端的同步请求时，推送到fcm有两种方式。</p><ol><li>使用fcm的设备组管理，fcm设备组管理需要新建设备组，把fcm token添加到设备组，发送同步数据时，带上fcm设备组id，fcm就会把同步数据推送到所有组。对于已经失效的fcm token，fcm设备组管理会自己清理。</li><li>自己维护设备组，遍历设备组的设备，一个个带上fcm token推到fcm。如果接收到fcm token无效的响应，就从redis把fcm token的kv关系、哈希关系删除。</li></ol><p>使用fcm的设备组管理的好处是只需要维护设备id到设备组id的关系，对于一些无效的fcm token由fcm自己去管理，不足的是目前fcm设备组管理没有提供API获取设备组的设备组列表，而且一发就是发全部，客户端发消息出去，待会又收到自己的消息。此外，fcm设备组管理在go没有sdk。。。</p><p>所以我决定自己管理设备组。</p><p>这里有一个☝️剪切板的问题，当发送到fcm的payload大于4kb的时候，会返回</p><pre><code>400; reason: request contains an invalid argument; code: invalid-argument; details: Request contains an invalid argument.</code></pre><p>也就是说，我们要控制好数据大小。作为ctrl cv工程师，如果要从mac往windows复制1000行代码怎么办？答案是分片。</p><p>正如ip分片和tcp分段为了解决报文的大小限制，我们要在应用层进行分片重组。不过这个由于是应用层的分片要简单的多。</p><ol><li>应用服务器接收到同步数据后，如果text文本大于4kb，则进行分片，mark高位第一位置0，否则置1直接推到FCM。</li><li>第二步，由于json是个文本协议，我们分片的时候有两种方案，第一种转换为字节分片，第二种转换为rune分片（rune是go的数据类型，可以表示一个utf8字符），一个rune的大小是4个字节，为了防止达到限制，rune分片大小应为1000个rune，不过这样就可能会导致一次payload利用率不高，毕竟1000个汉字是1000个rune，至少占3000字节，1000个字母也是1000个rune，占1000个字节；好处是在客户端可以直接使用。如果使用字节分片，客户端接收到分片后需要转换为字节数组，组合字节数组，再将字节数组转换为字符串，炒鸡麻烦。</li><li>接下来在分片mark高位起低6位设置好分片顺序，只要简单的0，1，2..这样就好了（不同于ip分片，ip分片使用的是数据偏移量作为位置索引）。如果是最后一片分片，mark高位起第二位要置1表示没有更多分片。</li></ol><p>接下来利用sdk推送到fcm就好了。应用服务器的接入fcm有多种方式，文档真是傻瓜式教程。</p><h1 id="客户端">4. 客户端</h1><p>客户端写Chrome拓展和android。<br>主要流程是</p><ol><li>根据接收到的数据类型处理，<br>（1）通知直接显示，<br>（2）短信显示并且检验有没有验证码，有则将验证码提取放入剪切板，<br>（3）剪切板进行分片判断</li><li>如果不是分片，直接放入剪切板，否则进行重组。</li></ol><p>重组需要一个全局哈希表，key为时间戳，也是分片id（这里用时间戳是偷懒，毕竟一个人1毫秒内也不能复制两次叭）；value是维护分片的数据结构FragHold，如下</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>整型</td></tr><tr><td>length</td><td>整型</td></tr><tr><td>text</td><td>数组</td></tr></tbody></table><p>当第一个分片到来时，将分片time作为key，初始化一个FragHold。每次到达一个分片，FragHold.count加1，当最后一个分片到来，FragHold.length可以确定。如果FragHold的count == length，那么分片重组完成，直接对数组一个join操作得到一篇完整的千字文，又可以愉快地ctrl cv了。</p><p>此外起一个定时任务，不断将全局哈希表里过期的FragHold剔除，毕竟这个是没有超时重传的，一旦丢了就再复制一次呗。</p><h1 id="结语">5. 结语</h1><p>这里要说一下在设备组管理遇到的问题，一开始我也是用fcm的设备组管理，导致发送方会接收到自己发送的消息。这个本来无所谓，根据消息的fcm_token判断一下，如果等于自己的fcm_token，就不处理。但是js客户端是用service worker来处理，当service worker重新唤醒时，因为查询indexedDB和调用fcm接口都要在第二轮事件循环才能拿到自己的fcm_token, 而service worker被唤醒后的第一个事件循环就要处理消息了，所以第一次被唤醒时是不知道自己fcm_token的。</p><p>还有一点，fcm js要求你必须对收到的push弹窗，否则他会帮你弹窗，有知道怎么解决的告诉我一下。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fcm真是个好东西，希望你也有。&lt;/p&gt;
    
    </summary>
    
      <category term="Firebase" scheme="https://htchz.cc/categories/Firebase/"/>
    
    
      <category term="数据分片" scheme="https://htchz.cc/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>[Dubbo]Dubbo SPI 机制</title>
    <link href="https://htchz.cc/2436052280.html"/>
    <id>https://htchz.cc/2436052280.html</id>
    <published>2019-03-25T03:44:00.000Z</published>
    <updated>2019-03-25T09:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>之前一篇<a href="./754409717.html">[Java基础]Java的SPI机制</a>讲到Java spi的缺陷是在查找所需实现的时候，会实例化无关的实现，那么这篇看看Dubbo是怎么规避这个问题的。</p><h1 id="Dubbo-spi的特点">2. Dubbo spi的特点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * default extension name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于配置文件是以key-value配置的，这里可以为SPI接口指定一个默认实现的key</p><p><strong>Dubbo spi有以下特点</strong></p><ol><li>不需要遍历所有实例化所有实现类</li><li>增加了对扩展点IoC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。</li></ol><h1 id="Demo">3. Demo</h1><p>接口,需要加上<code>org.apache.dubbo.common.extension.SPI</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRunner</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm a DefaultRunner"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcitedRunner</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm a ExcitedRunner!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在资源目录<code>META-INF/dubbo</code>下创建文件<code>com.htc.learning.api.Runner</code></p><p><img src="/images/pasted-172.png" alt="upload successful"></p><p>内容是一行一行的键值对，value是实现类，我们只要通过key就能直接拿到所需类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>=com.htc.learning.api.impl.DefaultRunner</span><br><span class="line">excited=com.htc.learning.api.impl.ExcitedRunner</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dubboSpiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;Runner&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Runner.class);</span><br><span class="line">    Runner defaultRunner = extensionLoader.getExtension(<span class="string">"default"</span>);</span><br><span class="line">    defaultRunner.run(<span class="string">"htc"</span>);</span><br><span class="line">    Runner excitedRunner = extensionLoader.getExtension(<span class="string">"excited"</span>);</span><br><span class="line">    excitedRunner.run(<span class="string">"htc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><pre><code>2019-03-23 12:20:50.681  INFO   --- [           main] com.htc.learning.api.impl.DefaultRunner  : I&apos;m a DefaultRunner2019-03-23 12:20:50.681  INFO   --- [           main] com.htc.learning.api.impl.ExcitedRunner  : I&apos;m a ExcitedRunner!</code></pre><h1 id="原理">4. 原理</h1><h2 id="getExtensionLoader">4.1. getExtensionLoader</h2><p>Dubbo spi与java spi的<code>ServiceLoader</code>对应的，是<code>ExtensionLoader</code>。不同于<code>ServiceLoader</code>的<code>load</code>方法每次返回都要实例化一个对象，<code>ExtensionLoader</code>每次<code>getExtensionLoader</code>会进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type + <span class="string">") is not interface!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type +</span><br><span class="line">                <span class="string">") is not extension, because WITHOUT @"</span> + SPI.class.getSimpleName() + <span class="string">" Annotation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExtensionLoader</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>objectFactory</code>是一个接口,与IOC相关，该接口根据type和name找到一个bean，这个bean可以是Spring的bean，也可以是一个dubbo spi实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get extension.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这是也是一个SPI接口，接下来调用的<code>getExtensionLoader</code>逻辑就是通过他实现的。</p><h2 id="getExtension">4.2. getExtension</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Holder，顾名思义，用于持有目标对象</span></span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建拓展实例</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                <span class="comment">// 设置实例到 holder 中</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射创建实例</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环创建 Wrapper 实例</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span></span><br><span class="line">                <span class="comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span></span><br><span class="line">                instance = injectExtension(</span><br><span class="line">                    (T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里按逻辑可以拆分成四步</p><ol><li><code>getExtensionClasses()</code>获取接口的所有实现类。这个方法会在很多地方被调用，保证所有类被获取到。由于多次调用缓存也是必须的。</li><li>实例化目标类的对象。</li><li>IOC注入。注入其他SPI实现。</li><li>AOP实现。如果需要，把对象实例包裹在Wrapper中。</li></ol><h3 id="getExtensionClasses">4.2.1. getExtensionClasses</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取已加载的拓展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载拓展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的双重校验，这里的缓存key是实现类的key，值就是实现类了。如果缓存为<code>null</code>，调用<code>loadExtensionClasses</code>初始化缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized in getExtensionClasses</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了默认实现，就缓存以下这个默认实现的key</span></span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"more than 1 default extension name on extension "</span> + type.getName()</span><br><span class="line">                        + <span class="string">": "</span> + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">                cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java spi的配置只能放在一个目录<code>META-INF/services/</code>,dubbo spi的配置可以放在三个目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br></pre></td></tr></table></figure><p>这里的依赖我用的是apache-dubbo，相对于alibaba-dubbo三个目录，估计为了兼容，apache-dubbo版本的<code>loadDirectory</code>方法进行了一个包名的替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fileName = 文件夹路径 + type 全限定名 </span></span><br><span class="line">    String fileName = dir + type.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        <span class="comment">// 根据文件名加载所有的同名文件</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载资源</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来“真·读取配置文件”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, </span></span></span><br><span class="line"><span class="function"><span class="params">ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 定位 # 字符</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 截取 # 之前的字符串，# 之后的内容为注释，需要忽略</span></span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以等于号 = 为界，截取键与值</span></span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载类，并通过 loadClass 方法对类进行缓存</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, </span><br><span class="line">                                      Class.forName(line, <span class="keyword">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Exception when load extension class..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读完配置文件，下面不单是对类进行加载，而且还对<code>Adaptive</code>、<code>Wrapper</code>类进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只能有一个自适应实现类</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line">                com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class="line">                <span class="keyword">if</span> (oldActivate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cachedActivates.put(names[<span class="number">0</span>], oldActivate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                <span class="comment">// 实现类重复报错</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的几点：</p><ol><li><code>@Adaptive</code>注解是标明一个SPI实现类是属于自适应类，一个SPI接口只能有一个自适应实现，这从代码逻辑可以看出来，如果<code>!cachedAdaptiveClass.equals(clazz)</code>则报错。具体这个自适应类可以做什么，下面会说。</li><li><code>Wrapper</code>类是AOP类</li><li>这里还有一个<code>@Active</code>注解，标明实现类的激活条件，是一种条件机制。</li></ol><h3 id="IOC">4.2.2. IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo的IOC目前只对setter方法支持，如果set的方法参数只有一个，那么就拿参数类型<code>pt</code>和setProperty的<code>property</code>去<code>objectFactory</code>找。<code>objectFactory</code>是<code>ExtensionFactory</code>接口，有两个实现，</p><p>上面提到<code>ExtensionLoader</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>getAdaptiveExtension()</code>是什么？</p><h3 id="Adaptive">4.2.3. @Adaptive</h3><p><code>getAdaptiveExtension()</code>的实现如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo的Adaptive机制如下</p><ol><li>如果一个SPI接口实现类存在自适应实现，那么直接拿这个类；</li><li>否则动态创建自适应类(手动拼接代码字符，并转为字节码，加载到jvm中)，由于dubbo是以url为协议的，所以创建的自适应代码是根据url中的内容决定使用那种实现。</li></ol><p>下面是alibaba dubbo 的中文注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从&#123;<span class="doctag">@link</span> URL&#125;的Key名，对应的Value作为要Adapt成的Extension名。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果&#123;<span class="doctag">@link</span> URL&#125;这些Key都没有Value，使用 用 缺省的扩展（在接口的&#123;<span class="doctag">@link</span> SPI&#125;中设定的值）。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 比如，&lt;code&gt;String[] &#123;"key1", "key2"&#125;&lt;/code&gt;，表示</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;先在URL上找key1的Value作为要Adapt成的Extension名；</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;key1没有Value，则使用key2的Value作为要Adapt成的Extension名。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;key2没有Value，使用缺省的扩展。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;如果没有设定缺省扩展，则方法调用会抛出&#123;<span class="doctag">@link</span> IllegalStateException&#125;。</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果不设置则缺省使用Extension接口类名的点分隔小写字串。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 即对于Extension接口&#123;<span class="doctag">@code</span> com.alibaba.dubbo.xxx.YyyInvokerWrapper&#125;的缺省值为&lt;code&gt;String[] &#123;"yyy.invoker.wrapper"&#125;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> SPI#value()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果@Adaptive上的key从url获取不到，就以@SPI上的默认扩展值作为key去url找，如果@SPI都没默认值，就将接口类名用<code>.</code>分隔，作为接口缺省值（这么奇怪的key吗 =。=）</p><p>以下面代码为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>这里会返回一个<code>Protocol$Adaptive</code>类，因为<code>Protocol</code>没有一个自适应实现类，所以dubbo动态生成了一个自适应类，通过debug得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        <span class="comment">// 这里默认使用dubbo</span></span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        <span class="comment">// 这里默认使用dubbo</span></span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>Protocol$Adaptive</code>代码里，如果接口方法没有设置<code>@Adaptive</code>注解，以抛异常处理。</p><p>在生成的方法中，以<code>protocol</code>为key去url里查找这个key的值，如果url里没有设置，就以<code>Protocol</code>接口上的@SPI注解默认值——“dubbo”作为自适应类要找的扩展的name。</p><blockquote><p>创建code代码太长，不贴。</p></blockquote><p>拿<code>ExtensionFactory</code>来说，他有三个实现（有一个废弃的）</p><p><img src="/images/pasted-173.png" alt="upload successful"></p><p>一个自适应实现类，以<code>@Adaptive</code>标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用于获取dubbo Spi实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是用于获取Spring的bean，代码太长不贴</p><h3 id="Active">4.2.4. @Active</h3><p>@Active注解用于实现类上，表示一些激活条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Activate the current extension when one of the groups matches. The group passed into</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; will be used for matching.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> group names to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Activate the current extension when the specified keys appear in the URL's parameters.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * For example, given &lt;code&gt;<span class="doctag">@Activate</span>("cache, validation")&lt;/code&gt;, the current extension will be return only when</span></span><br><span class="line"><span class="comment">     * there's either &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;validation&lt;/code&gt; key appeared in the URL's parameters.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> URL parameter keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br><span class="line"><span class="comment">     * Deprecated since 2.7.0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put before the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br><span class="line"><span class="comment">     * Deprecated since 2.7.0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put after the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Absolute ordering info, optional</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> absolute ordering info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样由于dubbo是面向url的协议，所以这些激活条件需要通过url匹配。</p><p>在加载类的时候，有这么几行代码，以扩展名字为key，以扩展上的注解为值进行map缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.dubbo.common.extension.ExtensionLoader#loadClass</span></span><br><span class="line">Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line"><span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line">    com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class="line">    <span class="keyword">if</span> (oldActivate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedActivates.put(names[<span class="number">0</span>], oldActivate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取激活的的扩展可以通过以下方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getActivateExtension(url, key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is equivalent to &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     getActivateExtension(url, values, null);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url    url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values extension point names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> extension list which are activated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActivateExtension(com.alibaba.dubbo.common.URL, String[], String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getActivateExtension(url, values, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is equivalent to &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     getActivateExtension(url, url.getParameter(key).split(","), null);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url   url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key   url parameter key which used to get extension point names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> extension list which are activated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActivateExtension(com.alibaba.dubbo.common.URL, String[], String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key, String group)</span> </span>&#123;</span><br><span class="line">    String value = url.getParameter(key);</span><br><span class="line">    <span class="keyword">return</span> getActivateExtension(url, value == <span class="keyword">null</span> || value.length() == <span class="number">0</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(value), group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法的具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get activate extensions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url    url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values extension point names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group  group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> extension list which are activated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">    <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            Activate activate = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                <span class="keyword">if</span> (!names.contains(name)</span><br><span class="line">                        &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                        &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">                    exts.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// order 值越小越靠前</span></span><br><span class="line">        Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">        String name = names.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                    usrs.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                usrs.add(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        exts.addAll(usrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">(String[] keys, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keys.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两次for循环</span></span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : url.getParameters().entrySet()) &#123;</span><br><span class="line">            String k = entry.getKey();</span><br><span class="line">            String v = entry.getValue();</span><br><span class="line">            <span class="comment">// 如果key存在且对应的value不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((k.equals(key) || k.endsWith(<span class="string">"."</span> + key))</span><br><span class="line">                    &amp;&amp; ConfigUtils.isNotEmpty(v)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配条件的逻辑是，先匹配组，再匹配键，键只要都存在值，那么即匹配成功。当注解上order值越小，这个实现类的排序越靠前。</p><p>关于排序，这里的一个具体例子是Dubbo服务的过滤器往往加上了@Active注解，这时候如果要设置过滤器的处理顺序，就可以通过该注解上的order属性设置。</p><h1 id="结束语">5. 结束语</h1><p>还差Wrapper机制没看。。关于下面那段话我也没看到具体的例子。</p><blockquote><p>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK标准的ScriptEngine，通过getName();获取脚本类型的名称，但如果RubyScriptEngine因为所依赖的jruby.jar不存在，导致RubyScriptEngine类加载失败，这个失败原因被吃掉了，和ruby对应不起来，当用户执行ruby脚本时，会报不支持ruby，而不是真正失败的原因。</p></blockquote><h1 id="参考">6. 参考</h1><ol><li><a href="https://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">Apache Dubbo SPI</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;之前一篇&lt;a href=&quot;./754409717.html&quot;&gt;[Java基础]Java的SPI机制&lt;/a&gt;讲到Java spi的缺陷是在查找所需实现的时候，会实例化无关的实现，那么这篇看看Dubbo是怎么规避这个问题的。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Dubbo" scheme="https://htchz.cc/categories/Dubbo/"/>
    
    
      <category term="OOP" scheme="https://htchz.cc/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>[Java代理]Cglib代理</title>
    <link href="https://htchz.cc/3922793788.html"/>
    <id>https://htchz.cc/3922793788.html</id>
    <published>2019-03-10T06:03:00.000Z</published>
    <updated>2019-08-15T16:08:49.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cglib">1. Cglib</h1><blockquote><p>CGLIB是一个强大的高性能的代码生成包。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p></blockquote><h1 id="Demo">2. Demo</h1><p>直接上Demo～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 目标类</span><br><span class="line"> */</span><br><span class="line">public class RunnerDefault implements Runner &#123;</span><br><span class="line">    private Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String name) &#123;</span><br><span class="line">        log.info(&quot;run: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定Callback的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CglibCallbackFilter implements CallbackFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int accept(Method method) &#123;</span><br><span class="line">        if (&quot;toString&quot;.equals(method.getName())) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理逻辑及生成代理的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 拦截所有方法</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Enhancer enhancer = new Enhancer();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        objects[0] = &quot;cglib &quot; + objects[0];</span><br><span class="line">        return methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newProxy(Class klass) &#123;</span><br><span class="line">        enhancer.setSuperclass(klass);</span><br><span class="line">        enhancer.setCallbackFilter(new CglibCallbackFilter());</span><br><span class="line">        enhancer.setCallbacks(new Callback[]&#123;new CglibProxy(), new CglibStringProxy()&#125;);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了拦截toString方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibStringProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"toString hijacked"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成class文件</span></span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./"</span>);</span><br><span class="line">    CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    RunnerDefault runner = (RunnerDefault) cglibProxy.newProxy(RunnerDefault.class);</span><br><span class="line">    runner.run(<span class="string">"proxy"</span>);</span><br><span class="line">    runner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><pre><code>2019-03-07 16:48:44.248  INFO   --- [           main] RunnerDefault$$EnhancerByCGLIB$$5b557d48 : run: cglib proxy2019-03-07 16:48:44.254  INFO   --- [           main] com.htc.learning.proxy.CglibStringProxy  : toString hijacked</code></pre><blockquote><p>也可以不配置CallbackFilter，只能配一个Callback，Enhancer会把单个的Callback转为数组,并且把CallbackFilter设置为ALL_ZERO，固定返回0</p></blockquote><p>下面是上面test执行过程中生成的文件</p><p><img src="/images/pasted-169.png" alt="upload successful"></p><h1 id="NamingPolicy">3. NamingPolicy</h1><p>上面的<strong>RunnerDefault$$EnhancerByCGLIB$$16487fc</strong>是cglib命名而来的，默认实现类是<code>net.sf.cglib.core.DefaultNamingPolicy</code>命名规则如下：</p><pre><code>目标ClassName + &quot;$$&quot; + 使用cglib处理的ClassName + &quot;ByCGLIB&quot; + &quot;$$&quot; + key的hashcode</code></pre><h1 id="Key和缓存">4. Key和缓存</h1><h2 id="KeyFactory">4.1. KeyFactory</h2><p>先看<code>KeyFactory</code>，这个类可以生成一个代理类，这个代理类对于给定的参数，每次调用返回的对象的<code>equals</code>、<code>hashcode</code>方法都是返回相同的值。由于cglib的配置项比较多，所以使用这个类用于生成缓存key的。</p><blockquote><p>目标类需要提供一个<code>public Object newInstance(...)</code>的声明，参数数量类型随意。</p></blockquote><p>下面是cglib</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span>[] b, String d)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 源码没有这一行，加上这一行，cglib的debug模式打开，就可以输出生成代理类的class文件了。</span></span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"./"</span>);</span><br><span class="line">        </span><br><span class="line">        MyFactory f = (MyFactory)KeyFactory.create(MyFactory.class);</span><br><span class="line">        Object key1 = f.newInstance(<span class="number">20</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123; <span class="string">'a'</span>, <span class="string">'b'</span> &#125;, <span class="string">"hello"</span>);</span><br><span class="line">        Object key2 = f.newInstance(<span class="number">20</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123; <span class="string">'a'</span>, <span class="string">'b'</span> &#125;, <span class="string">"hello"</span>);</span><br><span class="line">        Object key3 = f.newInstance(<span class="number">20</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123; <span class="string">'a'</span>, <span class="string">'_'</span> &#125;, <span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(key1.equals(key2));<span class="comment">// true</span></span><br><span class="line">        System.out.println(key2.equals(key3));<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-168.png" alt="upload successful"><br>三次生成的是不同对象。<br>key1和key2是相等的，key2和key3是不等的。追踪代码可以看到<code>KeyFactory</code>重写了代理类的<code>equals</code>、<code>hashcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.sf.cglib.core.KeyFactory.Generator#generateClass</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// hash code</span></span><br><span class="line">e = ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">int</span> hc = (constant != <span class="number">0</span>) ? constant : PRIMES[(<span class="keyword">int</span>)(Math.abs(seed) % PRIMES.length)];</span><br><span class="line"><span class="keyword">int</span> hm = (multiplier != <span class="number">0</span>) ? multiplier : PRIMES[(<span class="keyword">int</span>)(Math.abs(seed * <span class="number">13</span>) % PRIMES.length)];</span><br><span class="line">e.push(hc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">    e.load_this();</span><br><span class="line">    e.getfield(getFieldName(i));</span><br><span class="line">    EmitUtils.hash_code(e, parameterTypes[i], hm, customizers);</span><br><span class="line">&#125;</span><br><span class="line">e.return_value();</span><br><span class="line">e.end_method();</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line">e = ce.begin_method(Constants.ACC_PUBLIC, EQUALS, <span class="keyword">null</span>);</span><br><span class="line">Label fail = e.make_label();</span><br><span class="line">e.load_arg(<span class="number">0</span>);</span><br><span class="line">e.instance_of_this();</span><br><span class="line">e.if_jump(e.EQ, fail);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">    e.load_this();</span><br><span class="line">    e.getfield(getFieldName(i));</span><br><span class="line">    e.load_arg(<span class="number">0</span>);</span><br><span class="line">    e.checkcast_this();</span><br><span class="line">    e.getfield(getFieldName(i));</span><br><span class="line">    EmitUtils.not_equals(e, parameterTypes[i], fail, customizers);</span><br><span class="line">&#125;</span><br><span class="line">e.push(<span class="number">1</span>);</span><br><span class="line">e.return_value();</span><br><span class="line">e.mark(fail);</span><br><span class="line">e.push(<span class="number">0</span>);</span><br><span class="line">e.return_value();</span><br><span class="line">e.end_method();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="代理缓存">4.2. 代理缓存</h2><p>所有cglib代理类的缓存都存在于<code>net.sf.cglib.core.AbstractClassGenerator</code>的<code>static</code>变量里，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Map&lt;ClassLoader, ClassLoaderData&gt; CACHE = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_USE_CACHE =        Boolean.parseBoolean(System.getProperty(<span class="string">"cglib.useCache"</span>, <span class="string">"true"</span>));</span><br></pre></td></tr></table></figure><p>这个缓存是一个<code>WeakHashMap</code>，key和jdk代理一样，也是以<code>ClassLoader为</code>为key，至于<code>ClassLoaderData</code>是一个关于<code>interfaces</code>的封装，到最底层其实是一个<code>ConcurrentHashMap</code>。看<code>net.sf.cglib.core.AbstractClassGenerator#create</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        ClassLoaderData data = cache.get(loader);</span><br><span class="line">        <span class="comment">// 维护多线程</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = cache.get(loader);</span><br><span class="line">                <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    data = <span class="keyword">new</span> ClassLoaderData(loader);</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="comment">// 这里发生了二级缓存的put操作</span></span><br><span class="line">        Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>net.sf.cglib.core.AbstractClassGenerator.ClassLoaderData#get</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不使用缓存直接生成</span></span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 底层是去ConcurrentHashMap拿</span></span><br><span class="line">      Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">      <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说到二级缓存其实是<code>ConcurrentHashMap</code>,那么key，value分别是什么？key是<code>AbstractClassGenerator</code>子类决定的，比如<code>KeyFactory</code>使用的是目标类名；至于value又有jdk代理的味道——value值不是固定的，可能是生成的代理类，也可能是一个<code>FutureTask</code>，多个线程下多个<code>FutureTask</code>调用<code>get()</code>只会有一个在执行，避免了重复生成字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> V <span class="title">createEntry</span><span class="params">(<span class="keyword">final</span> K key, KK cacheKey, Object v)</span> </span>&#123;</span><br><span class="line">    FutureTask&lt;V&gt; task;</span><br><span class="line">    <span class="keyword">boolean</span> creator = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Another thread is already loading an instance</span></span><br><span class="line">        task = (FutureTask&lt;V&gt;) v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task = <span class="keyword">new</span> FutureTask&lt;V&gt;(<span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> loader.apply(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Object prevTask = map.putIfAbsent(cacheKey, task);</span><br><span class="line">        <span class="keyword">if</span> (prevTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// creator does the load</span></span><br><span class="line">            creator = <span class="keyword">true</span>;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevTask <span class="keyword">instanceof</span> FutureTask) &#123;</span><br><span class="line">            task = (FutureTask&lt;V&gt;) prevTask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) prevTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = task.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Interrupted while loading cache item"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ((RuntimeException) cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load cache item"</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (creator) &#123;</span><br><span class="line">        map.put(cacheKey, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Enhancer">5. Enhancer</h1><p><code>Enhancer</code>是CGLib中的一个字节码增强器，一般我们都用这个来进行生成cglib代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class[] interfaces;</span><br><span class="line"><span class="keyword">private</span> CallbackFilter filter;</span><br><span class="line"><span class="keyword">private</span> Callback[] callbacks;</span><br><span class="line"><span class="comment">// 回调逻辑的类型，包括 MethodInterceptor|NoOp|LazyLoader|Dispatcher|InvocationHandler|FixedValue</span></span><br><span class="line"><span class="keyword">private</span> Type[] callbackTypes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validateCallbackTypes;</span><br><span class="line"><span class="comment">// create()是否只生成代理类,而不是返回一个对象,如果只生成代理类，callback不能设置，会报错</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> classOnly;</span><br><span class="line"><span class="keyword">private</span> Class superclass;</span><br><span class="line"><span class="keyword">private</span> Class[] argumentTypes;</span><br><span class="line"><span class="keyword">private</span> Object[] arguments;</span><br><span class="line"><span class="comment">// 是否使用工厂类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useFactory = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> Long serialVersionUID;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> interceptDuringConstruction = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>下面是创建逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里进行一些配置校验，比如设置了多个Callback但是没有设置filter</span></span><br><span class="line">    preValidate();</span><br><span class="line">    <span class="comment">// 这里KEY_FACTORY是KeyFactory实例</span></span><br><span class="line">    Object key = KEY_FACTORY.newInstance((superclass != <span class="keyword">null</span>) ? superclass.getName() : <span class="keyword">null</span>,</span><br><span class="line">            ReflectUtils.getNames(interfaces),</span><br><span class="line">            filter == ALL_ZERO ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),</span><br><span class="line">            callbackTypes,</span><br><span class="line">            useFactory,</span><br><span class="line">            interceptDuringConstruction,</span><br><span class="line">            serialVersionUID);</span><br><span class="line">    <span class="keyword">this</span>.currentKey = key;</span><br><span class="line">    Object result = <span class="keyword">super</span>.create(key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object result = super.create(key);</code>又是跳到上面提到过的<code>net.sf.cglib.core.AbstractClassGenerator#create</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        ClassLoaderData data = cache.get(loader);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = cache.get(loader);</span><br><span class="line">                <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    data = <span class="keyword">new</span> ClassLoaderData(loader);</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上一小节提到，这里面是有缓存的。</p><h2 id="代理主流程">5.1. 代理主流程</h2><p><code>net.sf.cglib.proxy.Enhancer#generateClass</code>方法负责生成代理，主要是通过<code>CallbackFilter</code>为不同的<code>Method</code>提供不同的<code>Callback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateClass</span><span class="params">(ClassVisitor v)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class sc = (superclass == <span class="keyword">null</span>) ? Object.class : superclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot subclass final class "</span> + sc.getName());</span><br><span class="line">    List constructors = <span class="keyword">new</span> ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">    filterConstructors(sc, constructors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Order is very important: must add superclass, then</span></span><br><span class="line">    <span class="comment">// its superclass chain, then each interface and</span></span><br><span class="line">    <span class="comment">// its superinterfaces.</span></span><br><span class="line">    List actualMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List interfaceMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">final</span> Set forcePublic = <span class="keyword">new</span> HashSet();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看下面代码</span></span><br><span class="line">    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line">    <span class="comment">// 这里把actualMethods中，非abstract,非native,非synchronized方法的修饰符全部变成final，将转化后的方法信息MethodInfo列表 记录在methods中</span></span><br><span class="line">    List methods = CollectionUtils.transform(actualMethods, <span class="keyword">new</span> Transformer() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            Method method = (Method)value;</span><br><span class="line">            <span class="keyword">int</span> modifiers = Constants.ACC_FINAL</span><br><span class="line">                | (method.getModifiers()</span><br><span class="line">                   &amp; ~Constants.ACC_ABSTRACT</span><br><span class="line">                   &amp; ~Constants.ACC_NATIVE</span><br><span class="line">                   &amp; ~Constants.ACC_SYNCHRONIZED);</span><br><span class="line">            <span class="keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ClassEmitter e = <span class="keyword">new</span> ClassEmitter(v);</span><br><span class="line">    <span class="comment">// 这个currentData不知道是干嘛的</span></span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.begin_class(Constants.V1_2,</span><br><span class="line">                  Constants.ACC_PUBLIC,</span><br><span class="line">                  getClassName(),</span><br><span class="line">                  Type.getType(sc),</span><br><span class="line">                  (useFactory ?</span><br><span class="line">                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :</span><br><span class="line">                   TypeUtils.getTypes(interfaces)),</span><br><span class="line">                  Constants.SOURCE_FILE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.begin_class(Constants.V1_2,</span><br><span class="line">                Constants.ACC_PUBLIC,</span><br><span class="line">                getClassName(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> Type[]&#123;FACTORY&#125;,</span><br><span class="line">                Constants.SOURCE_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line"></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!interceptDuringConstruction) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (serialVersionUID != <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据callbackTypes增加属性，名字为CGLIB$CALLBACK_xx(xx是序号)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbackTypes.length; i++) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is declared private to avoid "public field" pollution</span></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为目标方法配置Callback</span></span><br><span class="line">        emitMethods(e, methods, actualMethods);</span><br><span class="line">        emitConstructors(e, constructorInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        emitDefaultConstructor(e);</span><br><span class="line">    &#125;</span><br><span class="line">    emitSetThreadCallbacks(e);</span><br><span class="line">    emitSetStaticCallbacks(e);</span><br><span class="line">    emitBindCallbacks(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useFactory || currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] keys = getCallbackKeys();</span><br><span class="line">        emitNewInstanceCallbacks(e);</span><br><span class="line">        emitNewInstanceCallback(e);</span><br><span class="line">        emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">        emitGetCallback(e, keys);</span><br><span class="line">        emitSetCallback(e, keys);</span><br><span class="line">        emitGetCallbacks(e);</span><br><span class="line">        emitSetCallbacks(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.end_class();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取要代理的方法">5.2. 获取要代理的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一坨是把目标类的方法，接口方法的信息（类型是 MethodInfo）都加入到methods列表里</span></span><br><span class="line">    ReflectUtils.addAllMethods(superclass, methods);</span><br><span class="line">    List target = (interfaceMethods != <span class="keyword">null</span>) ? interfaceMethods : methods;</span><br><span class="line">    <span class="keyword">if</span> (interfaces != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interfaces[i] != Factory.class) &#123;</span><br><span class="line">                ReflectUtils.addAllMethods(interfaces[i], target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interfaceMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forcePublic != <span class="keyword">null</span>) &#123;</span><br><span class="line">            forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));</span><br><span class="line">        &#125;</span><br><span class="line">        methods.addAll(interfaceMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤static方法</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> RejectModifierPredicate(Constants.ACC_STATIC));</span><br><span class="line">    <span class="comment">// 根据布尔值决定是否过滤protected的方法，过滤private方法</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> VisibilityPredicate(superclass, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 过滤重复</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> DuplicatesPredicate(methods));</span><br><span class="line">    <span class="comment">// 过滤final方法</span></span><br><span class="line">    CollectionUtils.filter(methods, <span class="keyword">new</span> RejectModifierPredicate(Constants.ACC_FINAL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对demo的<code>RunnerDefault</code>，获取到的最终方法为</p><p><img src="/images/pasted-170.png" alt="upload successful"></p><h2 id="为目标方法配置Callback">5.3. 为目标方法配置Callback</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods的类型是MethodInfo，主要是改了原方法的modifiers</span></span><br><span class="line"><span class="comment">// actualMethods的类型Method</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitMethods</span><span class="params">(<span class="keyword">final</span> ClassEmitter ce, List methods, List actualMethods)</span> </span>&#123;</span><br><span class="line">    CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);</span><br><span class="line"></span><br><span class="line">    Map groups = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> Map indexes = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> Map originalModifiers = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> Map positions = CollectionUtils.getIndexMap(methods);</span><br><span class="line">    <span class="keyword">final</span> Map declToBridge = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    Iterator it1 = methods.iterator();</span><br><span class="line">    Iterator it2 = (actualMethods != <span class="keyword">null</span>) ? actualMethods.iterator() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it1.hasNext()) &#123;</span><br><span class="line">        MethodInfo method = (MethodInfo)it1.next();</span><br><span class="line">        Method actualMethod = (it2 != <span class="keyword">null</span>) ? (Method)it2.next() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取 index</span></span><br><span class="line">        <span class="keyword">int</span> index = filter.accept(actualMethod);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= callbackTypes.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callback filter returned an index that is too large: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        originalModifiers.put(method, <span class="keyword">new</span> Integer((actualMethod != <span class="keyword">null</span>) ? actualMethod.getModifiers() : method.getModifiers()));</span><br><span class="line">        <span class="comment">// 把index放入map</span></span><br><span class="line">        indexes.put(method, <span class="keyword">new</span> Integer(index));</span><br><span class="line">        List group = (List)groups.get(generators[index]);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            groups.put(generators[index], group = <span class="keyword">new</span> ArrayList(methods.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        group.add(method);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Optimization: build up a map of Class -&gt; bridge methods in class</span></span><br><span class="line">        <span class="comment">// so that we can look up all the bridge methods in one pass for a class.</span></span><br><span class="line">        <span class="keyword">if</span> (TypeUtils.isBridge(actualMethod.getModifiers())) &#123;</span><br><span class="line">        Set bridges = (Set)declToBridge.get(actualMethod.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (bridges == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bridges = <span class="keyword">new</span> HashSet();</span><br><span class="line">            declToBridge.put(actualMethod.getDeclaringClass(), bridges);</span><br><span class="line">        &#125;</span><br><span class="line">        bridges.add(method.getSignature());            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Map bridgeToTarget = <span class="keyword">new</span> BridgeMethodResolver(declToBridge, getClassLoader()).resolveAll();</span><br><span class="line"></span><br><span class="line">    Set seenGen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    CodeEmitter se = ce.getStaticHook();</span><br><span class="line">    se.new_instance(THREAD_LOCAL);</span><br><span class="line">    se.dup();</span><br><span class="line">    se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);</span><br><span class="line">    se.putfield(THREAD_CALLBACKS_FIELD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] state = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    CallbackGenerator.Context context = <span class="keyword">new</span> CallbackGenerator.Context() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Enhancer.<span class="keyword">this</span>.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOriginalModifiers</span><span class="params">(MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)originalModifiers.get(method)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)indexes.get(method)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据index获取对应的Callback（从DeclaredField获取）</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitCallback</span><span class="params">(CodeEmitter e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            emitCurrentCallback(e, index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Signature <span class="title">getImplSignature</span><span class="params">(MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rename(method.getSignature(), ((Integer)positions.get(method)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitLoadArgsAndInvoke</span><span class="params">(CodeEmitter e, MethodInfo method)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// If this is a bridge and we know the target was called from invokespecial,</span></span><br><span class="line">            <span class="comment">// then we need to invoke_virtual w/ the bridge target instead of doing</span></span><br><span class="line">            <span class="comment">// a super, because super may itself be using super, which would bypass</span></span><br><span class="line">            <span class="comment">// any proxies on the target.</span></span><br><span class="line">            Signature bridgeTarget = (Signature)bridgeToTarget.get(method.getSignature());</span><br><span class="line">            <span class="keyword">if</span> (bridgeTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// checkcast each argument against the target's argument types</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bridgeTarget.getArgumentTypes().length; i++) &#123;</span><br><span class="line">                    e.load_arg(i);</span><br><span class="line">                    Type target = bridgeTarget.getArgumentTypes()[i];</span><br><span class="line">                    <span class="keyword">if</span> (!target.equals(method.getSignature().getArgumentTypes()[i])) &#123;</span><br><span class="line">                        e.checkcast(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                e.invoke_virtual_this(bridgeTarget);</span><br><span class="line">                </span><br><span class="line">                Type retType = method.getSignature().getReturnType();                    </span><br><span class="line">                <span class="comment">// Not necessary to cast if the target &amp; bridge have</span></span><br><span class="line">                <span class="comment">// the same return type. </span></span><br><span class="line">                <span class="comment">// (This conveniently includes void and primitive types,</span></span><br><span class="line">                <span class="comment">// which would fail if casted.  It's not possible to </span></span><br><span class="line">                <span class="comment">// covariant from boxed to unbox (or vice versa), so no having</span></span><br><span class="line">                <span class="comment">// to box/unbox for bridges).</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> It also isn't necessary to checkcast if the return is</span></span><br><span class="line">                <span class="comment">// assignable from the target.  (This would happen if a subclass</span></span><br><span class="line">                <span class="comment">// used covariant returns to narrow the return type within a bridge</span></span><br><span class="line">                <span class="comment">// method.)</span></span><br><span class="line">                <span class="keyword">if</span> (!retType.equals(bridgeTarget.getReturnType())) &#123;</span><br><span class="line">                    e.checkcast(retType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e.load_args();</span><br><span class="line">                e.super_invoke(method.getSignature());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> CodeEmitter <span class="title">beginMethod</span><span class="params">(ClassEmitter ce, MethodInfo method)</span> </span>&#123;</span><br><span class="line">            CodeEmitter e = EmitUtils.begin_method(ce, method);</span><br><span class="line">            <span class="keyword">if</span> (!interceptDuringConstruction &amp;&amp;</span><br><span class="line">                !TypeUtils.isAbstract(method.getModifiers())) &#123;</span><br><span class="line">                Label constructed = e.make_label();</span><br><span class="line">                e.load_this();</span><br><span class="line">                e.getfield(CONSTRUCTED_FIELD);</span><br><span class="line">                e.if_jump(e.NE, constructed);</span><br><span class="line">                e.load_this();</span><br><span class="line">                e.load_args();</span><br><span class="line">                e.super_invoke();</span><br><span class="line">                e.return_value();</span><br><span class="line">                e.mark(constructed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbackTypes.length; i++) &#123;</span><br><span class="line">        CallbackGenerator gen = generators[i];</span><br><span class="line">        <span class="keyword">if</span> (!seenGen.contains(gen)) &#123;</span><br><span class="line">            seenGen.add(gen);</span><br><span class="line">            <span class="keyword">final</span> List fmethods = (List)groups.get(gen);</span><br><span class="line">            <span class="keyword">if</span> (fmethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    gen.generate(ce, context, fmethods);</span><br><span class="line">                    gen.generateStatic(se, context, fmethods);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    se.return_value();</span><br><span class="line">    se.end_method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码没有看的很细，了解了大概。</p><blockquote><p>一个方法只会有一个<code>Callback</code>。</p></blockquote><p>这一节，最后看一下代理出来的类的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$run$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$run$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CGLIB$run$0$Method </span></span><br><span class="line">Method CGLIB$run$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"run"</span>, <span class="string">"(Ljava/lang/String;)V"</span>&#125;, (var1 = Class.forName(<span class="string">"com.htc.learning.api.impl.RunnerDefault"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// CGLIB$run$0$Proxy</span></span><br><span class="line">MethodProxy CGLIB$run$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"run"</span>, <span class="string">"CGLIB$run$0"</span>);</span><br></pre></td></tr></table></figure><p>所以逻辑是这样的，代理类将调用转发给一个<code>Callback</code>，在<code>Callback</code>里，如果要执行目标类的目标方法，即调用<code>net.sf.cglib.proxy.MethodProxy#invokeSuper</code></p><p>等等，<code>MethodProxy</code>是什么</p><p>此外从生成的类里，我们可以看除了Enhancer和KeyFactory的增强类之外，还生成了三个类</p><p><img src="/images/pasted-171.png" alt="upload successful"><br>第二个是我们的代理类，那么其余两个是干嘛的，<code>FastClass</code>又是什么?</p><h1 id="MethodProxy与Fastclass">6. MethodProxy与Fastclass</h1><h2 id="为什么要有MethodProxy、Fastclass">6.1. 为什么要有MethodProxy、Fastclass</h2><p>我们配置代理的时候，并没有传入一个目标类实例，而是传入目标类的class，这时我们要去调用目标方法的时候，如果每次都靠反射，那就没有直接调用一个对象来的快。</p><blockquote><p>没错每次都靠反射说的就是你jdk代理。</p></blockquote><h2 id="MethodProxy">6.2. MethodProxy</h2><p><code>MethodProxy</code>表明了一个方法到另一个方法的映射，我们看一下代理类run方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// CGLIB$run$0$Proxy 即是 MethodProxy</span></span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$run$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$run$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.run(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class var0 = Class.forName(<span class="string">"com.htc.learning.api.impl.RunnerDefault$$EnhancerByCGLIB$$5b557d48"</span>);  </span><br><span class="line">Class var1 = Class.forName(<span class="string">"com.htc.learning.api.impl.RunnerDefault"</span>)</span><br><span class="line">CGLIB$run$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"run"</span>, <span class="string">"CGLIB$run$0"</span>);</span><br></pre></td></tr></table></figure><p>再其中，<code>&quot;CGLIB$run$0&quot;</code>是Enhancer代理类里的一个已经生成的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> CGLIB$run$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="keyword">super</span>.run(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MethodProxy</code>的<code>create</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> </span>&#123;</span><br><span class="line">    MethodProxy proxy = <span class="keyword">new</span> MethodProxy();</span><br><span class="line">    proxy.sig1 = <span class="keyword">new</span> Signature(name1, desc);</span><br><span class="line">    proxy.sig2 = <span class="keyword">new</span> Signature(name2, desc);</span><br><span class="line">    proxy.createInfo = <span class="keyword">new</span> MethodProxy.CreateInfo(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段就是说<code>c1</code>的方法<code>name1</code>,对应的代理方法是实现类<code>c2</code>的方法<code>name2</code>。再具体一点，<code>RunnerDefault</code>的<code>run</code>方法，对应的就是<code>com.htc.learning.api.impl.RunnerDefault$$EnhancerByCGLIB$$5b557d48</code>的<code>CGLIB$run$0</code>方法，这两个签名没有依赖，MethodProxy利用这两个签名，提供两种不同的目标方法调用，</p><h2 id="FastClass">6.3. FastClass</h2><p>上面只是创建了一个关联关系，接下来看<code>net.sf.cglib.proxy.MethodProxy#invokeSuper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">        <span class="comment">// f2是Enhancer代理类，i2是配置好的可以调用到目标方法的索引，invoke根据索引，使用switch块直接调用方法，而不是利用反射</span></span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例模式，防止重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.initLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                MethodProxy.CreateInfo ci = <span class="keyword">this</span>.createInfo;</span><br><span class="line">                MethodProxy.FastClassInfo fci = <span class="keyword">new</span> MethodProxy.FastClassInfo();</span><br><span class="line">                fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                fci.i1 = fci.f1.getIndex(<span class="keyword">this</span>.sig1);</span><br><span class="line">                fci.i2 = fci.f2.getIndex(<span class="keyword">this</span>.sig2);</span><br><span class="line">                <span class="keyword">this</span>.fastClassInfo = fci;</span><br><span class="line">                <span class="keyword">this</span>.createInfo = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FastClass <span class="title">helper</span><span class="params">(MethodProxy.CreateInfo ci, Class type)</span> </span>&#123;</span><br><span class="line">    Generator g = <span class="keyword">new</span> Generator();</span><br><span class="line">    g.setType(type);</span><br><span class="line">    g.setClassLoader(ci.c2.getClassLoader());</span><br><span class="line">    g.setNamingPolicy(ci.namingPolicy);</span><br><span class="line">    g.setStrategy(ci.strategy);</span><br><span class="line">    g.setAttemptLoad(ci.attemptLoad);</span><br><span class="line">    <span class="comment">// 进去代码后可以看到使用了缓存，所以不会重复生成FastClass</span></span><br><span class="line">    <span class="keyword">return</span> g.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span> </span>&#123;</span><br><span class="line">    FastClass f1;</span><br><span class="line">    FastClass f2;</span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line">    <span class="keyword">int</span> i2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FastClassInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数命令实在有点难懂，梳理一下，针对<code>run</code>方法，</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>c1</td><td><code>RunnerDefault</code></td></tr><tr><td>f1</td><td><code>RunnerDefault$$FastClassByCGLIB$$a60a67a3</code></td></tr><tr><td>i1</td><td>目标类<code>run</code>的索引</td></tr><tr><td>c2</td><td><code>RunnerDefault$$EnhancerByCGLIB$$5b557d48</code> (<code>Enhancer</code>代理类)</td></tr><tr><td>f2</td><td><code>RunnerDefault$$EnhancerByCGLIB$$5b557d48$$FastClassByCGLIB$$9f176e41</code>（<code>Enhancer</code>代理类的一个快速查找类）</td></tr><tr><td>i2</td><td><code>Enhancer</code>代理类调用<code>run</code>的索引</td></tr></tbody></table><p>下面是<code>RunnerDefault$$FastClassByCGLIB$$a60a67a3</code>的部分代码(如果是<code>RunnerDefault$$EnhancerByCGLIB$$5b557d48$$FastClassByCGLIB$$9f176e41</code>switch块会更大，因为<code>RunnerDefault$$EnhancerByCGLIB$$5b557d48</code>的方法更多)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Signature var1)</span> </span>&#123;</span><br><span class="line">    String var10000 = var1.toString();</span><br><span class="line">    <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1717138348</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"run(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这的var2是Enhancer代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    RunnerDefault var10000 = (RunnerDefault)var2;</span><br><span class="line">    <span class="keyword">int</span> var10001 = var1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(var10001) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.run((String)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Boolean(var10000.equals(var3[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.toString();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(var10000.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot find matching method/constructor"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StackOverflowError">6.4. StackOverflowError</h2><p>如果我们写Callback的时候，把<code>invokeSuper</code>写成<code>invoke</code>会怎么样，答案是：<strong>栈溢出</strong>。<br><code>MethodProxy</code>的<code>invoke</code>方法是这样的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f1.invoke(fci.i1, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>obj</code>是Enhancer代理类，而<code>f1</code>是<code>RunnerDefault$$FastClassByCGLIB$$a60a67a3</code>，所以又会索引到<code>Enhancer代理类</code>的代理<code>run</code>方法，接着又执行上面的<code>invoke</code>,balabala…陷入死循环。</p><h2 id="invoke与invokeSuper">6.5. invoke与invokeSuper</h2><p>那是不是<code>invoke</code>不能被调用了？不是，上面说到<strong>MethodProxy利用这两个签名，提供两种不同的目标方法调用，</strong>所以，<code>invoke</code>是另一种调用目标方法的姿势。</p><p>写<code>Callback</code>的时候，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        objects[<span class="number">0</span>] = <span class="string">"cglib "</span> + objects[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>传入的<code>Object o</code>是<code>Enhancer</code>代理类，而我们不能执行<code>methodProxy.invoke(o, objects)</code>陷入死循环，所以我们在<code>Callback</code>需要保存一个目标类实例的引用<code>target</code>，然后<code>methodProxy.invoke(target, objects)</code>。</p><h2 id="总结">6.6. 总结</h2><p><code>MethodProxy</code>与<code>Fastclass</code>提供了一个  <strong>Signature -&gt; index -&gt; invoke</strong>的机制。</p><h1 id="缺陷">7. 缺陷</h1><p>如果理解了<code>FastClass</code>，那么很容猜测<code>cglib</code>的性能瓶颈在于，当目标类的方法很多的时候，<code>switch</code>块就是一个很慢的查找，这个查找是有优化空间的。此外，<code>cglib</code>代理的创建时间会比<code>jdk</code>代理的创建更耗时间，不过我觉得这都不是事。</p><h1 id="参考">8. 参考</h1><ol><li><a href="https://www.jianshu.com/p/20203286ccd9" target="_blank" rel="noopener">cglib demo以及Enhancer源码解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cglib&quot;&gt;1. Cglib&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CGLIB是一个强大的高性能的代码生成包。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell
      
    
    </summary>
    
      <category term="Proxy" scheme="https://htchz.cc/categories/Proxy/"/>
    
    
      <category term="AOP" scheme="https://htchz.cc/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>[Java代理]Jdk代理</title>
    <link href="https://htchz.cc/68869360.html"/>
    <id>https://htchz.cc/68869360.html</id>
    <published>2019-03-04T16:16:00.000Z</published>
    <updated>2019-08-15T16:08:49.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>相比静态代理需要手动写代理类，动态代理可以通过抽象代码完成对一定规则的类的代理，生成的代理类直接以字节码的形式存在于内存中。Spring里Aop的实现使用了两种动态代理方案，一种是jdk代理，一种是<code>cglib</code>代理。</p><p>jdk代理是从目标类的接口生成实现类，cglib是继承目标类生成子类。</p><h1 id="Demo">2. Demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口实现类</span></span><br><span class="line"><span class="comment"> * created by Huang.Zhen on 2019-02-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerDefault</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"run: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> * created by Huang Zhen on 2019-02-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存目标类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxyHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对newProxyInstance方法的封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">"jdk "</span> + args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用下面的代码获取代理类并运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runner runner = (Runner) <span class="keyword">new</span> JdkProxyHandler(<span class="keyword">new</span> RunnerDefault()).getProxy();</span><br><span class="line">    runner.run(<span class="string">"proxy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 </p><pre><code>2019-03-01 16:02:17.623  INFO   --- [           main] com.htc.learning.api.impl.RunnerDefault  : run: jdk proxy</code></pre><h1 id="原理">3. 原理</h1><h2 id="怎么生成代理类class文件">3.1. 怎么生成代理类class文件</h2><p>直捣<code>Proxy.newProxyInstance</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br></pre></td></tr></table></figure><p>进入<code>getProxyClass0</code>，从<code>proxyClassCache</code>字面上理解，jdk代理是有缓存的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line"><span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line"><span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line"><span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br></pre></td></tr></table></figure><p>进入get方法。可以看到出现了jdk8级别的代码，说明jdk8里jdk代理又被优化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line"><span class="comment">// subKey from valuesMap</span></span><br><span class="line"><span class="comment">// subKeyFactory 其实是 java.lang.reflect.Proxy.ProxyClassFactory</span></span><br><span class="line">Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">...</span><br><span class="line">V value = supplier.get();</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>进入<code>java.lang.reflect.Proxy.ProxyClassFactory#apply</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">    proxyName, interfaces, accessFlags);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">    ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">    <span class="comment">// 生成字节码的方法，不想看</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">    <span class="comment">// 这里可以通过命令行参数设置要不要存储生成的class文件</span></span><br><span class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                        Files.createDirectories(var3);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以往都是说jdk代理比cglib性能差，其实优化到现在都没差多少了，更多的时候是从两者的特性按需求采取不同的。</p></blockquote><h2 id="缓存">3.2. 缓存</h2><p>jdk代理获取Class的时候使用了缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxyClassCache</code>的声明是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a cache of proxy classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>主要的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;K&gt; refQueue</span><br><span class="line">    = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="comment">// 缓存本存</span></span><br><span class="line"><span class="comment">// the key type is Object for supporting null key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">    = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 反向索引，用来快速判断一个对象是否存在缓存里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap</span><br><span class="line">    = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 两个二元运算方法</span></span><br><span class="line"><span class="comment">// subKeyFactory = new KeyFactory()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line"><span class="comment">// valueFactory = new ProxyClassFactory()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br></pre></td></tr></table></figure><p>这里里的缓存<code>map</code>的value又是一个<code>ConcurrentMap</code>,说明这个缓存是一个二级缓存。</p><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>一级缓存key</td><td>一个CacheKey类型的对象，以ClassLoader作为hash</td></tr><tr><td>一级缓存value</td><td>一级缓存</td></tr></tbody></table><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>二级缓存key</td><td>以interfaces为key</td></tr><tr><td>二级缓存value</td><td>Supplier接口，可能是CacheValue 或者 代理工厂对象</td></tr></tbody></table><p>看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Proxy类的代码中，key是ClassLoader，parameter是interface数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    <span class="comment">// 初始化二级缓存，用了双重校验，保证所有线程拿到的是同一个实例</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">    <span class="comment">// subKey from valuesMap</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lazily construct a Factory</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的代码主要是维护<code>Map.put</code>操作多线程下的一些同步，防止重复实例化。虽然<code>map</code>是<code>ConcurrentHashMap</code>,但重复put还是得避免的。</li><li>二级缓存<code>Map</code>的<code>value</code>为<code>Supplier</code>类型，第一次访问是 <code>Factory</code>对象，第二次访问就可能是<code>CacheValue</code>，因为<code>Factory</code>存有二级缓存map的引用，会把<code>value</code>从<code>this</code>（<code>Factory</code>本身）替换为<code>CacheValue</code></li></ul><blockquote><p>其实不太明白这种机制,可能为了提高并发性能？先返回值，再为值构造缓存。</p></blockquote><h2 id="缓存过期机制">3.3. 缓存过期机制</h2><p><code>CacheKey</code>是一个<code>WeakReference</code>，当gc时就会被清理掉引用的对象，这时需要把<code>CacheKey</code>从<code>Map</code>里<code>remove</code>，下面这个方法在<code>WeakCache</code>执行读操作的时候会执行一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheKey&lt;K&gt; cacheKey;</span><br><span class="line">    <span class="keyword">while</span> ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cacheKey.expungeFrom(map, reverseMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>CacheValue</code>也是虚引用。</p></blockquote><h2 id="InvocationHandler注入">3.4. InvocationHandler注入</h2><p>代理类已经生成了，我们写的<code>InvocationHandler</code>还没有注入，所以生成代理类的时候是不包含代理逻辑的。</p><p>我们回到<code>Proxy.newProxyInstance</code>方法，这时已经获取到<code>class</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"><span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure><p><code>InvocationHandler</code>是通过构造参数注入的。</p><h2 id="代理class文件的内容">3.5. 代理class文件的内容</h2><p>我们生成基本的class文件只需要给一个自定义类名和一个目标类就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveJdkProxyClass</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       String path = <span class="string">"./$Proxy0.class"</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy0"</span>, RunnerDefault.class.getInterfaces());</span><br><span class="line">       FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">           out.write(classFile);</span><br><span class="line">           out.flush();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">               out.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.htc.learning.api.Runner;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.htc.learning.api.Runner"</span>).getMethod(<span class="string">"run"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么cglib方案的代理类class文件又要怎么获取呢，下篇再说。</p></blockquote><p>可以看到字节码里每个目标方法都有一个同名的代理方法包着，代理逻辑已经写在<code>InvocationHandler</code>，代理方法直接调用<code>InvocationHandler</code>就可以了。</p><h1 id="从代理类获取原始对象的Class">4. 从代理类获取原始对象的Class</h1><p>在Spring里，bean被代理是很常见的，假如我们要获取目标bean上的注解，这时候我们拿到的如果是代理类，是获取不到的目标bean上的注解的。所以这时我们得从代理类获取原始对象，再获得对应的Class。</p><h2 id="我的做法">4.1. 我的做法</h2><p>在<code>InvocationHandler</code>实现类里，把目标类对象放入了一个<code>target</code>成员变量，然后当我们拿到代理类后，通过调用<code>java.lang.reflect.Proxy#getInvocationHandler</code>方法，再通过反射即可获取到原始对象<code>target</code>。</p><h2 id="Spring的做法">4.2. Spring的做法</h2><p>Spring有一个AopProxyUtils的工具，其中有个方法可以获取到jdk代理或cglib代理的原始对象。关于这个工具更多使用参考<a href="https://www.jianshu.com/p/273d8e2bb992" target="_blank" rel="noopener">AopProxyUtils详解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// candidate即传入的代理类实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; ultimateTargetClass(Object candidate) &#123;</span><br><span class="line">Assert.notNull(candidate, <span class="string">"Candidate object must not be null"</span>);</span><br><span class="line">Object current = candidate;</span><br><span class="line">Class&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// Spring的代理类都实现了 TargetClassAware，调用getTargetClass()可获取到目标对象，注意，这里不一定是原始对象，因为可能切面切了很多次，生成了很多层的代理类，这也是为什么需要一个while循环</span></span><br><span class="line"><span class="keyword">while</span> (current <span class="keyword">instanceof</span> TargetClassAware) &#123;</span><br><span class="line">result = ((TargetClassAware) current).getTargetClass();</span><br><span class="line">current = getSingletonTarget(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果是cglib代理，则获取对象父类，否则是jdk代理，直接获取对象类型</span></span><br><span class="line">result = (AopUtils.isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSingletonTarget</span><span class="params">(Object candidate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">TargetSource targetSource = ((Advised) candidate).getTargetSource();</span><br><span class="line"><span class="keyword">if</span> (targetSource <span class="keyword">instanceof</span> SingletonTargetSource) &#123;</span><br><span class="line"><span class="keyword">return</span> ((SingletonTargetSource) targetSource).getTarget();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑看起来不难，但是涉及了Spring Aop的接口概念，所以具体调用我也不太懂是干嘛的。</p><blockquote><p>Spring在代理逻辑中拦截了<code>getTargetClass()</code>等切面方法，将这些方法转发给<code>Advised</code>去执行。</p></blockquote><h1 id="缺陷">5. 缺陷</h1><p>从class文件看，由于代理类继承了<code>Proxy</code>类（其实这个类看起来也只有一个<code>java.lang.reflect.Proxy#getInvocationHandler</code>比较通用的方法，其实我觉得这个<code>InvocationHandler</code>可以通过反射拿到，不懂为什么非要继承这个类，喵？），导致jdk代理不能通过继承目标类来达到代理的目的。</p><h1 id="关于Spring">6. 关于Spring</h1><p>Spring有个属性是<code>proxy-target-class</code>，默认值是<code>false</code>，表示默认使用jdk代理，这时使用常常会发生类型转换的错误，因为最终bean的class已经不是最初的bean的类型。<br>在Springboot里，<code>proxy-target-class</code>使用<code>spring.aop.proxy-target-class</code>属性来配置，默认为<code>true</code>，即都使用<code>cglib</code>来代理。如果配置为<code>false</code>，Springboot会对实现接口的bean使用jdk代理，对于没有实现接口的类依旧使用<code>cglib</code>代理。</p><h1 id="参考">7. 参考</h1><ol><li><a href="https://www.jianshu.com/p/273d8e2bb992" target="_blank" rel="noopener">AopProxyUtils详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;相比静态代理需要手动写代理类，动态代理可以通过抽象代码完成对一定规则的类的代理，生成的代理类直接以字节码的形式存在于内存中。Spring里Aop的实现使用了两种动态代理方案，一种是jdk代理，一种是&lt;code&gt;cglib&lt;/cod
      
    
    </summary>
    
      <category term="Proxy" scheme="https://htchz.cc/categories/Proxy/"/>
    
    
      <category term="AOP" scheme="https://htchz.cc/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>[NIO]linux的I/O多路复用</title>
    <link href="https://htchz.cc/3010153098.html"/>
    <id>https://htchz.cc/3010153098.html</id>
    <published>2019-01-30T18:07:00.000Z</published>
    <updated>2019-02-01T05:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>上篇提到i/o多路复用，是通过单进程监听多个文件描述的状态，达到减少线程阻塞的目的。</p><blockquote><p>内核（kernel）利用文件描述符（file descriptor）来访问文件。 文件描述符是<strong>非负整数</strong>。 打开现存文件或新建文件时(包括socket被打开)，内核会返回一个文件描述符。 读写文件也需要使用文件描述符来指定待读写的文件。在linux环境下，进入<code>/proc</code>目录可以看到许多代表文件描述符的文件夹。</p></blockquote><p>linux i/o多路复用的系统调用接口有三种，分别是    <code>select</code>,<code>poll</code>,<code>epoll</code>。</p><h1 id="接口">2. 接口</h1><p>作为一个学java的，了解一下java底层调用的函数，还是挺有助于理解的。</p><h2 id="i-o多路复用原理">2.1. i/o多路复用原理</h2><p>linux(2.6+)内核的事件wakeup callback机制，是linux i/o多路复用的原理。内核管理一个process的睡眠队列，当socket事件发生的时候，唤醒队列的process，调用callback函数完成通知。总体上会涉及两大逻辑：（1）睡眠等待逻辑；（2）唤醒逻辑。</p><p>1.睡眠等待逻辑：涉及select、poll、epoll_wait的阻塞等待逻辑</p><ul><li>select、poll、epoll_wait陷入内核，判断监控的socket是否有关心的事件发生了，如果没，则为当前process构建一个wait_entry节点，然后插入到监控socket的sleep_list</li><li>进入循环的schedule直到关心的事件发生了</li><li>关心的事件发生后，将当前process的wait_entry节点从socket的sleep_list中删除。</li></ul><p>2.唤醒逻辑。</p><ul><li>socket的事件发生了，然后socket顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数</li><li>直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止。</li><li>一般情况下callback包含两个逻辑：1.wait_entry自定义的私有逻辑；2.唤醒的公共逻辑，主要用于将该wait_entry的process放入CPU的就绪队列，让CPU随后可以调度其执行。</li></ul><h2 id="select">2.2. select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> max_fd, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout)</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>   <span class="comment">//清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">//将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>  <span class="comment">//将给定的描述符从文件中删除  </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">//判断指定描述符是否在集合中</span></span></span><br></pre></td></tr></table></figure><p>select 方法的第一个参数max_fd指待测试的fd（fd即文件描述符，一个socket会有一个文件描述符）个数，它的值是待测试的最大文件描述符加1，文件描述符从0开始到max_fd-1都将被测试。中间三个参数readset、writeset和exceptset指定要让内核测试读、写和异常条件的fd集合，如果不需要测试的可以设置为NULL。</p><p>select被调用的时候，被监控的<code>readset</code>(假设对socket的读事件感兴趣)会从用户空间复制到内核空间，然后遍历监听的socket，如果在超时或者有一个或多个socket产生了读事件，那么select唤醒线程，注意这里只是<strong>唤醒</strong>，并没有返回就绪的fd，接下来线程要再次遍历<code>readset</code>，收集可读事件。</p><p><code>select</code>的问题是：</p><ul><li>监听的socket数量有限，为了减少fd拷贝的性能损耗，限定了1024个文件描述符</li><li>线程被唤醒的时候，需要<strong>再次</strong>遍历fd列表。</li></ul><h2 id="poll">2.3. poll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fd;                         <span class="comment">// 需要被检测或选择的文件描述符</span></span><br><span class="line">        <span class="keyword">short</span> events;                   <span class="comment">// 对文件描述符fd上感兴趣的事件</span></span><br><span class="line">        <span class="keyword">short</span> revents;                  <span class="comment">// 文件描述符fd上当前实际发生的事件*/</span></span><br><span class="line">&#125; <span class="keyword">pollfd_t</span>;</span><br></pre></td></tr></table></figure><p><code>poll</code>换了个数据结构，解决了<code>select</code>其中一个问题：监听的数量有限。但实际上并有解决拷贝的性能损耗和需要再次遍历fd列表获取就绪事件。</p><h2 id="epoll">2.4. epoll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll不是一个方法，而是由三个函数组成;</p><ol><li><code>epoll_create</code>创建了一个epoll的fd，参数size表明内核要监听的描述符数量</li><li><code>epoll_ctl</code>用来对fd集合进行修改，参照<code>select</code>，<code>poll</code>每次调用都是将所有fd集合复制，鉴于fd集合的变化不频繁，其实每次全量复制过去是没必要的。</li><li><code>epoll_wait</code>相当于前两种i/o多路复用调用，该函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0，events指针指向了就绪的集合。</li></ol><blockquote><p>epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。</p></blockquote><p>epoll解决了select、poll的主要问题：</p><ol><li>没有最大并发连接的限制，能打开的fd上限远大于1024</li><li>采用回调的方式，效率提升。只有活跃可用的fd才会调用callback函数，也就是说 epoll 只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。</li></ol><p>epoll对文件描述符的操作有两种模式：LT(level trigger，水平触发)和ET(Edge trigger，边缘触发)。</p><p>LT:这次事件没处理，下次还告诉你。<br>ET:这次事件没处理，下次不告诉你。</p><h1 id="java-nio">3. java nio</h1><p>在linux环境下，java nio 底层调用是epoll，这里有个博主写了一个<a href="https://github.com/code4wt/toyhttpd/blob/master/epoll_multiprocess_server.c" target="_blank" rel="noopener">基于epoll实现的web服务器</a>，在linux下编译完成后，可以浏览器访问8080端口，观察输出。</p><p>另外，java使用的模式是水平触发。<a href="https://www.zhihu.com/question/22524908" target="_blank" rel="noopener">传送门</a></p><h1 id="结束语">4. 结束语</h1><p>作为linux门外汉，了解的不是很深入。</p><h1 id="参考">5. 参考</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="noopener">大话 Select、Poll、Epoll</a></li><li><a href="http://www.tianxiaobo.com/2018/03/02/%E5%9F%BA%E4%BA%8Eepoll%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">基于epoll实现简单的web服务器</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;上篇提到i/o多路复用，是通过单进程监听多个文件描述的状态，达到减少线程阻塞的目的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内核（kernel）利用文件描述符（file descriptor）来访问文件。 文件描述符是&lt;stro
      
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="NIO" scheme="https://htchz.cc/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>[NIO]五个I/O模型</title>
    <link href="https://htchz.cc/2990610001.html"/>
    <id>https://htchz.cc/2990610001.html</id>
    <published>2019-01-27T14:35:00.000Z</published>
    <updated>2019-01-31T07:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">1. 前言</h1><p>不先了解一下Linux的IO模型，看java的nio真是一脸懵逼。。</p><h1 id="linux的io模型">2. linux的io模型</h1><h2 id="Blocking-I-O阻塞IO模型">2.1. Blocking (I/O阻塞IO模型)</h2><p><img src="/images/pasted-161.png" alt="upload successful"><br>刚学java的时候想必学的都是阻塞IO传输，底层调用就是上面的图锁展示的过程，进程调用<code>recvfrom</code>，进入阻塞状态，然后系统将数据从网卡/硬盘读取到内核，由从内核复制到用户态，最终返回给进程，进程继续运行。</p><blockquote><p>这是比较耗时和浪费CPU的做法，需要阻塞<strong>数据到达</strong>，<strong>数据复制</strong></p></blockquote><h2 id="Nonblocking-I-O（非阻塞IO模型）">2.2. Nonblocking I/O（非阻塞IO模型）</h2><p><img src="/images/pasted-162.png" alt="upload successful"><br>底层轮询调用<code>recvfrom</code>，系统会立刻返回读取结果，如果读取不到数据，则开启下一次调用，直到数据返回。</p><blockquote><p>这种模式不用阻塞<strong>数据到达</strong>，需要阻塞<strong>数据复制</strong>。但是处于轮询状态的进程又是另一种意义上的阻塞，所以其实效率没有提高多少。</p></blockquote><h2 id="I-O-Multiplexing-多路复用">2.3. I/O Multiplexing(多路复用)</h2><p>Unix/Linux 环境下的 I/O 复用模型包含三组系统调用，分别是 select、poll 和 epoll，在历史上依次出现。<br><img src="/images/pasted-163.png" alt="upload successful"><br>select 有三个文件描述符集（readfds），分别是可读文件描述符集（writefds）、可写文件描述符集和异常文件描述符集（exceptfds）。进程将文件描述符（socket也有文件描述符表示）注册到感兴趣的文件描述符集中，</p><p>在这种模式下，<code>select</code>先被调用，进程处于阻塞状态，直至<strong>一个或多个</strong>事件返回。然后使用<code>recvfrom</code>读取数据。</p><blockquote><p>这种模式需要阻塞<strong>数据到达</strong>，<strong>数据复制</strong>。但是BIO由于一次只等待一个<strong>数据到达</strong>，所以性能上多路复用更优。</p></blockquote><h2 id="Signal-Driven-I-O（信号驱动I-O）">2.4. Signal-Driven I/O（信号驱动I/O）</h2><p>进程告诉内核，某个socket 的某个事件发生时，向进程发送信号。接收到信号后，对应的函数回去处理事件。<br><img src="/images/pasted-165.png" alt="upload successful"></p><blockquote><p>这种模式不用阻塞<strong>数据到达</strong>，需要阻塞<strong>数据复制</strong></p></blockquote><p>想想，如果<strong>数据复制</strong>完再通知进程，不就不用阻塞了。于是有下面的异步IO的模型出现。</p><h2 id="Asynchronous-I-O-（异步I-O）">2.5. Asynchronous I/O （异步I/O）</h2><p><img src="/images/pasted-166.png" alt="upload successful"><br>这就是信号驱动I/O的升级版，完全异步，进程无阻塞。对于大部分平台来说，底层利用的还是非异步模型结合回调函数来实现。</p><blockquote><p>遗憾的是，linux的网络IO中是不存在异步IO的，linux的网络IO处理的第二阶段总是阻塞等待数据copy完成的。真正意义上的网络异步IO是Windows下的IOCP（IO完成端口）模型。</p></blockquote><h1 id="对比">3. 对比</h1><p><img src="/images/pasted-167.png" alt="upload successful"></p><h1 id="总结">4. 总结</h1><blockquote><p>Unix网络编程」中说道，按照POSIX标准中的术语，同步指的是I/O动作会导致用户进程阻塞，异步则刚好相反。按照这种分类，上边5种I/O模型中，只有AIO一种是异步的，其他都是同步的。</p></blockquote><p>但是这些只是相对的，程序往往是多线程运行，拿Java来说，主线程调用select操作是阻塞的，但是<strong>数据复制</strong>这个阻塞过程放到子线程中，对主线程来说没有影响。这也是为什么java的NIO称为同步非阻塞IO。</p><h1 id="参考">5. 参考</h1><ul><li><a href="https://www.kancloud.cn/digest/unix-fzyz-sb/168128" target="_blank" rel="noopener">IO复用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;1. 前言&lt;/h1&gt;&lt;p&gt;不先了解一下Linux的IO模型，看java的nio真是一脸懵逼。。&lt;/p&gt;
&lt;h1 id=&quot;linux的io模型&quot;&gt;2. linux的io模型&lt;/h1&gt;&lt;h2 id=&quot;Blocking-I-O阻塞IO模型&quot;&gt;2.1. Block
      
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="NIO" scheme="https://htchz.cc/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>[Java基础]SimpleDateFormat线程安全的问题</title>
    <link href="https://htchz.cc/3683368056.html"/>
    <id>https://htchz.cc/3683368056.html</id>
    <published>2018-12-25T10:19:00.000Z</published>
    <updated>2019-08-15T16:08:49.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天把<code>SimpleDateFormat</code>设置为<code>static</code>，老哥说你错了，你真的错了。</p></blockquote><a id="more"></a><h1 id="前言">1. 前言</h1><p><code>SimpleDateFormat</code>是个线程不安全的类，不可以在多线程里面使用。</p><h1 id="代码">2. 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(num);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, num).parallel().forEach(a -&gt; executorService.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(simpleDateFormat.parse(<span class="string">"2017-12-13 15:17:27"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    executorService.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会这么报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">at java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1890</span>)</span><br><span class="line">at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.base/java.lang.Double.parseDouble(Double.java:<span class="number">543</span>)</span><br><span class="line">at java.base/java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2128</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2240</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1541</span>)</span><br><span class="line">at java.base/java.text.DateFormat.parse(DateFormat.java:<span class="number">393</span>)</span><br><span class="line">at com.htc.learning.main.SimpleDateFormatTest.lambda$main$<span class="number">0</span>(SimpleDateFormatTest.java:<span class="number">18</span>)</span><br><span class="line">at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">515</span>)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">264</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1128</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">628</span>)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">at java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1890</span>)</span><br><span class="line">at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.base/java.lang.Double.parseDouble(Double.java:<span class="number">543</span>)</span><br><span class="line">at java.base/java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2128</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2240</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1541</span>)</span><br><span class="line">at java.base/java.text.DateFormat.parse(DateFormat.java:<span class="number">393</span>)</span><br><span class="line">at com.htc.learning.main.SimpleDateFormatTest.lambda$main$<span class="number">0</span>(SimpleDateFormatTest.java:<span class="number">18</span>)</span><br><span class="line">at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">515</span>)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">264</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1128</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">628</span>)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br><span class="line">Wed Dec <span class="number">13</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">27</span> CST <span class="number">2017</span></span><br><span class="line">Tue Dec <span class="number">13</span> <span class="number">15</span>:<span class="number">17</span>:<span class="number">27</span> CST <span class="number">12</span></span><br></pre></td></tr></table></figure><p>这段代码有时报错，有时能正常输出，但也不是正确输出。</p><h1 id="SimpleDateFormat的类图结构">3. SimpleDateFormat的类图结构</h1><p><img src="/images/pasted-159.png" alt="upload successful"><br>可以看到内部维护了一个Calendar类，归根到底就是这个家伙线程不安全。</p><h1 id="源码">4. 源码</h1><p>看parse(String)方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String text, ParsePosition pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 解析字符串将每步的执行结果放入CalendarBuilder的实例calb中</span></span><br><span class="line">    ...</span><br><span class="line">    Date parsedDate;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedDate = calb.establish(calendar).getTime();</span><br><span class="line">        <span class="comment">// If the year value is ambiguous,</span></span><br><span class="line">        <span class="comment">// then the two-digit year == the default start year</span></span><br><span class="line">        <span class="keyword">if</span> (ambiguousYear[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parsedDate.before(defaultCenturyStart)) &#123;</span><br><span class="line">                parsedDate = calb.addYear(<span class="number">100</span>).establish(calendar).getTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An IllegalArgumentException will be thrown by Calendar.getTime()</span></span><br><span class="line">    <span class="comment">// if any fields are out of range, e.g., MONTH == 17.</span></span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parsedDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>calb.establish(calendar).getTime()</code>,这里传入的是一个成员变量，每个<code>SimpleDateFormat</code>使用一个<code>Calendar</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Calendar <span class="title">establish</span><span class="params">(Calendar cal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// reset日期对象cal的属性值</span></span><br><span class="line">    cal.clear();</span><br><span class="line">    <span class="comment">// 使用calb中中属性设置cal</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> cal;</span><br></pre></td></tr></table></figure><p>由于多个线程使用的是同一个<code>Calendar</code>，就会出现一些奇奇怪怪的错误。</p><p>那么<code>format()</code>呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                               FieldPosition pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pos.beginIndex = pos.endIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> format(date, toAppendTo, pos.getFieldDelegate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called from Format after creating a FieldDelegate</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                FieldDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Convert input date to time field list</span></span><br><span class="line">        calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> toAppendTo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要看这里<code>calendar.setTime(date);</code>,同样的原因，calendar被并发操作，最后多个线程会输出同样的值。</p><h1 id="解决方案">5. 解决方案</h1><ol><li>每个线程一个<code>SimpleDateFormat</code>实例，不过我觉得这样没必要。</li><li>使用Apache的<code>FastDateFormat</code>类，这是一个线程安全类</li></ol><p><code>FastDateFormat</code>也是依赖<code>Calendar</code>，不过每次方法调用都会实例化一次，避免多线程操作同一个<code>Calendar</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天把&lt;code&gt;SimpleDateFormat&lt;/code&gt;设置为&lt;code&gt;static&lt;/code&gt;，老哥说你错了，你真的错了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="multithread" scheme="https://htchz.cc/tags/multithread/"/>
    
  </entry>
  
  <entry>
    <title>[Java基础]Java的SPI机制</title>
    <link href="https://htchz.cc/754409717.html"/>
    <id>https://htchz.cc/754409717.html</id>
    <published>2018-11-29T08:04:00.000Z</published>
    <updated>2019-07-18T09:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要SPI">1. 为什么要SPI</h1><p>SPI, Service Provider Interface, 简单来说就是调用方提供接口，接入方提供实现。比如一个应用程序调用JDBC的接口，你要是使用mysql，就得提供mysql提供的jdbc实现。这和我们定义<strong>接口</strong>然后写<strong>实现类</strong>差不多，只不过<strong>实现类</strong>是可以在jar/war外提供。</p><h1 id="原理">2. 原理</h1><p>java的实现无非是读取文件，按类名加载。</p><h2 id="调用方定义接口">2.1. 调用方定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三方实现接口">2.2. 第三方实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtcName</span> <span class="keyword">implements</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"htc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultName</span> <span class="keyword">implements</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明第三方实现">2.3. 声明第三方实现</h2><p>在<code>CLASSPATH</code>下建<code>META-INF/services</code>,这个路径是java的代码写死的。<br>然后新建一个文件，文件名为接口名。</p><p><img src="/images/pasted-160.png" alt="upload successful"></p><p>文件的内容就是声明要加载的实现类。</p><pre><code>com.htc.learning.api.impl.DefaultNamecom.htc.learning.api.impl.HtcName</code></pre><h2 id="调用方加载实现类">2.4. 调用方加载实现类</h2><p>使用<code>ServiceLoader</code>类加载实现类，他会搜索<code>CLASSPATH</code>下的所有的”META-INF/services/com.htc.learning.api.Name”文件，获取所有声明一一加载。<strong>注意,类的实例化发生在遍历的时候</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Name&gt; serviceLoader = ServiceLoader.load(Name.class);</span><br><span class="line">        <span class="keyword">for</span> (Name name : serviceLoader) &#123;</span><br><span class="line">            System.out.println(name.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码">3. 源码</h1><p>看看<code>ServiceLoader.load(Name.class)</code>做了什么事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了线程上下文类加载器，因为内置Spi接口都是由Bootstrap类加载器加载，Bootstrap类加载器又加载不了第三方实现类，所以要使用线程上下文类加载器（默认是App类加载器）</p></blockquote><p>进入方法后，获取了<code>ClassLoader</code>,接下来继续进入<code>ServiceLoader.load(service, cl);</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ClassLoader loader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回了一个实例，那么查看他的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceLoader`(Class&lt;S&gt; svc, ClassLoader cl) &#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，完全没有任何实例化的代码。</p><p>前面说到是实例化发生在遍历的时候，在构造函数里也有实例化一个<code>LazyIterator</code>的类，我们转到<code>ServiceLoader</code>的<code>iterator()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是<code>hasNext()</code>,有一个<code>knownProviders</code>的变量，它从<code>providers</code>属性获得，这个属性是一个<code>LinkedHashMap&lt;String,S&gt;</code>，起到一个缓存的作用，保证实现类只被加载一次。我们可以不关注缓存，看<code>lookupIterator.hasNext()</code>。<code>lookupIterator</code>在上面<code>lookupIterator = new LazyIterator(service, loader);</code>被赋值了的，下面是<code>LazyIterator</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasNextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有java <code>SecurityManager</code>的管理，直接看<code>hasNextService()</code>的代码就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//nextName在上一次查询提前缓存实现类的名字，做到快速判断</span></span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的 PREFIX 就是  "META-INF/services/"</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提前缓存实现类的名字，下一次查询做到快速判断</span></span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看<code>next()</code>操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">        <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">    <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到<code>lookupIterator.next()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>nextService()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里会执行hasNextService()的判断</span></span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>nextService()</code>没参与遍历，实现类的遍历是交给了<code>hasNextService()</code>并把遍历到的<code>ClassName</code>存放到<code>nextName</code>属性，<code>nextService()</code>只负责把<code>nextName</code>实例化，并且放入缓存中。</p><h1 id="缺点">4. 缺点</h1><p>java的SPI是有缺点的，这也是dubbo为什么要实现自己的SPI机制。</p><p>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</p><h1 id="题外话">5. 题外话</h1><p>我们java程序加载数据库驱动的时候，利用的就是java的spi机制。如果我们引入了多个数据库的jdbc驱动jar，那么java怎么知道加载哪一个呢。</p><p>我们我的数据库驱动是由<code>java.sql.DriverManager</code>管理的，现在看他的一个<code>getDriver()</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Driver <span class="title">getDriver</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// who understands the given URL.</span></span><br><span class="line">    <span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 就是这一行！</span></span><br><span class="line">                <span class="keyword">if</span>(aDriver.driver.acceptsURL(url)) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">"getDriver returning "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="keyword">return</span> (aDriver.driver);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException sqe) &#123;</span><br><span class="line">                <span class="comment">// Drop through and try the next driver.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">"    skipping: "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>if(aDriver.driver.acceptsURL(url))</code>这一行，<code>DriverManager</code>用连接的url对每一个驱动进行尝试，尝试得通就是这个驱动没跑了。。。</p><h1 id="结束语">6. 结束语</h1><p>无。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要SPI&quot;&gt;1. 为什么要SPI&lt;/h1&gt;&lt;p&gt;SPI, Service Provider Interface, 简单来说就是调用方提供接口，接入方提供实现。比如一个应用程序调用JDBC的接口，你要是使用mysql，就得提供mysql提供的jdbc实现。这和
      
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OOP" scheme="https://htchz.cc/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>[Dubbo]探索dubbo2.6.3版本之前的一个问题</title>
    <link href="https://htchz.cc/1632594101.html"/>
    <id>https://htchz.cc/1632594101.html</id>
    <published>2018-10-20T02:55:00.000Z</published>
    <updated>2019-03-12T07:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于<code>dubbo</code>版本较低遇到了一个诡异的问题。</p></blockquote><a id="more"></a><h1 id="场景">1. 场景</h1><p><code>dubbo</code>的<code>RpcContext</code>存放了一个<code>attachments</code>属性，用于隐式传递参数，每次发起调用之后会<code>clear</code>清空。</p><p>使用了cat监控之后，可以在<code>dubbo</code>服务调用之间传递一个id作为链路跟踪。而这个参数就是在<code>Comsumer</code>发起请求前放入<code>attachments</code>，在<code>Provider</code>接收到请求后从<code>attachments</code>拿出。</p><p>测试环境调用某服务会出现这个id时有时无的情况，于是分析日志，发现没有这个id的情况下，dubbo协议走的是hessian协议。原来此服务提供了hessian访问，于是客户端会随机走dubbo或者hessian协议。</p><p>为什么hessian协议会丢<code>attachments</code>？这个id是通过实现<code>dubbo</code>的<code>Filter</code>塞进去的，理论上Filter应该是协议无关的。通过debug发现，在发送请求之前的<code>RpcContext.attachments</code>里也的确是有这个id。</p><h1 id="探索">2. 探索</h1><h2 id="dubbo协议">2.1. dubbo协议</h2><p>dubbo的consumer调用抽象为Invoker和Invocation，在Invoker执行invoke方法之前，需要执行负载均衡、重试计数、拦截器调用链，最后执行抽象类<code>AbstractInvoker.invoke</code>方法，继而调用不同协议的<code>doInvoke</code>方法</p><p>看看dubbo协议的doInvoke方法，</p><p><img src="/images/pasted-154.png" alt="upload successful"><br>可以看到请求是由一个<code>HeaderExchangeClient</code>去发起，<br><img src="/images/pasted-153.png" alt="upload successful"><br>这里的的channel是一个<code>nettyClient</code>，而<code>request</code>的内容如下：<br><img src="/images/pasted-155.png" alt="upload successful"><br>dubbo协议的实现是利用<code>socket长连接</code>，将整个<code>request</code>对象发送过去的,没有丢<code>attachments</code></p><h2 id="hessian协议">2.2. hessian协议</h2><p>hessian协议下是通过<code>com.caucho.hessian.client.HessianProxy#invoke</code>来发起请求，这个方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数不知道是干嘛的，第二个参数和第三个参数分别是调用服务的方法对象和参数。反正这个方法是没地方放<code>attchments</code>这种<strong>隐式参数</strong>含义的东西。</p><p>debug看他的调用栈，</p><p><img src="/images/pasted-156.png" alt="upload successful"></p><p>定位到这个<code>com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker#invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e.getTargetException());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从这里开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br></pre></td></tr></table></figure><p>就把invocation里的<code>attachments</code>丢了</p><p><img src="/images/pasted-157.png" alt="upload successful"></p><h1 id="解决方法">3. 解决方法</h1><p>dubbo版本至少升级直2.6.3，这个版本对提供了对hessian协议的<code>attachments</code>支持。</p><p><img src="/images/pasted-158.png" alt="upload successful"></p><p>下面是部分代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboHessianURLConnectionFactory</span> <span class="keyword">extends</span> <span class="title">HessianURLConnectionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HessianConnection <span class="title">open</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HessianConnection connection = <span class="keyword">super</span>.open(url);</span><br><span class="line">        RpcContext context = RpcContext.getContext();</span><br><span class="line">        <span class="keyword">for</span> (String key : context.getAttachments().keySet()) &#123;</span><br><span class="line">            connection.addHeader(Constants.DEFAULT_EXCHANGER + key, context.getAttachment(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo通过继承hessian库的类，在处理<code>URL</code>的时候把<code>attachments</code>放到header里去了，接收请求时再从header里拿出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于&lt;code&gt;dubbo&lt;/code&gt;版本较低遇到了一个诡异的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Dubbo" scheme="https://htchz.cc/categories/Dubbo/"/>
    
    
      <category term="碧油鸡" scheme="https://htchz.cc/tags/%E7%A2%A7%E6%B2%B9%E9%B8%A1/"/>
    
  </entry>
  
  <entry>
    <title>[Java基础]正确使用CompletableFuture</title>
    <link href="https://htchz.cc/1193009570.html"/>
    <id>https://htchz.cc/1193009570.html</id>
    <published>2018-10-12T05:36:00.000Z</published>
    <updated>2018-10-22T03:34:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用不好可就搞笑了哦</p></blockquote><a id="more"></a><h1 id="前言">1. 前言</h1><p>这个类是jdk8提供的类，在这个类之前的其他Future实现类，存在一些缺点，比如缺少一些任务完成的通知机制。  </p><p>于是<code>CompletableFuture</code>诞生了，他提供了任务回调的机制，还可以简洁的组合两个任务；更可以聚合n个任务，在任何一个任务完成的全部任务完成后进行某种操作。关于它的特性不多说。</p><p>jdk8里的<code>ParallelStream</code>和<code>CompletableFuture</code>的出现让java的异步编程变的更为自然灵活。</p><h1 id="线程池那些事">2. 线程池那些事</h1><p>jdk1.7老李设计了<code>ForkJoinPool</code>框架，核心就是任务窃取算法。<code>ForkJoinPool</code>有个通用线程池，他的工作线程数在多核环境下默认是<code>Runtime.getRuntime().availableProcessors() - 1</code>,也就“机器cpu的线程数 -  1“（减一可能是最佳实践吧），</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title">commonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert common != null : "static init error";</span></span><br><span class="line">    <span class="keyword">return</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParallelStream</code>新任务是只能提交到这个线程池的，而<code>CompletableFuture</code>默认使用这个线程池，但是也支持自己提供线程池。</p><p><img src="/images/pasted-152.png" alt="upload successful"></p><p>可以看到<code>runAsync</code>和<code>supplyAsync</code>有重载方法提供<code>Executor</code>。</p><p>那么我们什么时候要提供线程池呢，这里看《java8实战》的一段话，</p><blockquote><p><strong>并行——使用流还是CompletableFutures?</strong><br>集合进行并行计算有两种方式:要么将其转化为并行流，利用map<br>这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在CompletableFuture内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助你确保整体的计算不会因为线程都在等待I/O而发生阻塞。<br>我们对使用这些API的建议如下。 </p><ul><li><strong>如果你进行的是计算密集型的操作，并且没有I/O，</strong>那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的(如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程)。 </li><li><strong>如果你并行的工作单元还涉及等待I/O的操作(包括网络连接等待)</strong>，那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者 W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性(流的中间操作会在一起执行)会让我们很难判断到底什么时候触发了等待。</li></ul></blockquote><p>简单地说，<code>ForkJoinPool</code>通用线程池的线程数比较少，不适合用来进行需要I/O等待的任务。如果用<code>CompletableFuture</code>提交一些需要I/O等待的任务，需要提供一个自定义的<code>Executor</code>。</p><p>下面用程序演示一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Stopwatch stopwatch = Stopwatch.createUnstarted();</span><br><span class="line"></span><br><span class="line">        stopwatch.start();</span><br><span class="line">        <span class="comment">// 不提供Executor，Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS)模拟网络I/O 1秒</span></span><br><span class="line">        CompletableFuture.allOf(</span><br><span class="line">                IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed()</span><br><span class="line">                        .map(a -&gt; CompletableFuture.runAsync(() -&gt; Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS)))</span><br><span class="line">                        .toArray(CompletableFuture[]::<span class="keyword">new</span>))</span><br><span class="line">                .join();</span><br><span class="line">        System.out.println(<span class="string">"elapsed with ForkJoinPool:"</span> + stopwatch.stop().elapsed(TimeUnit.MILLISECONDS) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        stopwatch.reset().start();</span><br><span class="line">        <span class="comment">// 提供Executor</span></span><br><span class="line">        CompletableFuture.allOf(</span><br><span class="line">                IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed()</span><br><span class="line">                        .map(a -&gt; CompletableFuture.runAsync(() -&gt; Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS), service))</span><br><span class="line">                        .toArray(CompletableFuture[]::<span class="keyword">new</span>))</span><br><span class="line">                .join();</span><br><span class="line">        System.out.println(<span class="string">"elapsed with Executor:"</span> + stopwatch.stop().elapsed(TimeUnit.MILLISECONDS) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>elapsed with ForkJoinPool:15100 mselapsed with Executor:1019 ms</code></pre><p>我的电脑是8线程，那么<code>ForkJoinPool</code>通用线程池就是 (8 - 1 = 7 )个线程， 可以看到100个任务执行了15秒 ( 约等于 100 / 7)。所以使用<code>CompletableFuture</code>的时候要注意这点。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;用不好可就搞笑了哦&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="multithread" scheme="https://htchz.cc/tags/multithread/"/>
    
  </entry>
  
  <entry>
    <title>[分布式]接口限流</title>
    <link href="https://htchz.cc/2168043814.html"/>
    <id>https://htchz.cc/2168043814.html</id>
    <published>2018-09-29T07:51:00.000Z</published>
    <updated>2019-08-21T06:56:24.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试一下用lua脚本执行redis命令</p></blockquote><a id="more"></a><h1 id="前言">1. 前言</h1><p>对于应用内部的服务限流，熔断器Hystrix，作出很好的实践。最近开源的Sentinel也是一个不错的选择。<br>不过对于对外接口限流，好像没有什么框架。常用的限流算法就是：漏桶算法和令牌桶算法。<br>本文将利用redis和lua脚本实现令牌桶算法，同时通过spring来驱动脚本。<br>Guava提供了一个RateLimiter，我们也看一下。</p><blockquote><p>当然还可以用计数器方法，如设定一个计数key，一秒过期，一秒内达到n次就拒绝服务。</p></blockquote><h1 id="两个算法">2. 两个算法</h1><p>Google了十几个中文博客，每一篇都是一样的，都说两种算法能限制速率，但是漏桶算法不能应对突发流量而令牌桶可以，又没说为什么。在我看来，两种算法的算法不过是“一正一反”，本质是一样的。无奈英语渣看了一下维基百科”LeakyBucket”词条，<code>Overview</code>里提到，文献描述了两种版本的漏桶算法：</p><ol><li>as a meter（作为计量工具）</li><li>as a queue（作为调度队列）</li></ol><p>第一种版本是令牌桶算法的<strong>镜像实现</strong>，第二种是第一种的变种。也就是其实都差不多的。</p><h2 id="漏桶算法（LeakyBucket）">2.1. 漏桶算法（LeakyBucket）</h2><p><img src="/images/pasted-149.png" alt="upload successful"></p><p>漏桶算法指一定<strong>速率</strong>漏水，流量进来的时候是把水加入桶里，当水&gt; <strong>容量</strong>的时候拒绝服务（或者其他策略balabala）。</p><p>两个重要参数：</p><ol><li>漏水速率</li><li>桶容量</li></ol><p>对于桶满的情况下，对于新的流量有两种处理方式：</p><ol><li>Traffic Shaping: 暂时拦截住上方水的向下流动，等待桶中的一部分水漏走后，再放行上方水。也就是上面的<strong>as a queue</strong>。</li><li>Traffic Policing: 溢出的上方水直接抛弃，也就是上面的<strong>as a meter（作为计量工具）</strong></li></ol><p>可以看到这种算法提供一种机制控制接口被访问的速率，平滑突发的流量。</p><p>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">double rate; // leak rate in calls/s</span><br><span class="line">double burst; // bucket size in calls</span><br><span class="line">long refreshTime; // time for last water refresh</span><br><span class="line">double water; // water count at refreshTime</span><br><span class="line">refreshWater() &#123;</span><br><span class="line">    long now = getTimestamp();</span><br><span class="line">    //计算两次请求之间流失的水并相减</span><br><span class="line">    water = max(0, water- (now - refreshTime)*rate);</span><br><span class="line">    refreshTime = now;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">    refreshWater();</span><br><span class="line">    if (water &lt; burst) &#123; // 水桶还没满,继续加1</span><br><span class="line">        water ++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌桶算法（TokenBucket）">2.2. 令牌桶算法（TokenBucket）</h2><p><img src="/images/pasted-151.png" alt="upload successful"></p><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据字节数目，并允许突发数据的发送，用令牌数量代表字节数量。</p><p>两个重要参数：</p><ol><li>发牌速率</li><li>令牌桶容量</li></ol><p>对于令牌不足的情况，对流量可以进行三种方式的处理：</p><ol><li>丢弃数据包</li><li>放入等待队列直至令牌足够</li><li>进行标记，过载情况下可以进行丢弃</li></ol><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务(或者其他策略balabala)。从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。</p><blockquote><p>丢弃数据包的实现看楼下lua脚本</p></blockquote><p>Guava的<code>RateLimiter</code>就是使用了令牌桶算法。</p><h1 id="redis实现">3. redis实现</h1><p>redis在2.6之后内置了对lua脚本的支持。通过lua脚本我们可以执行一些复杂的逻辑操作，同时保证整个操作过程的原子性。</p><p>lua脚本写在客户端，下面是一个lua脚本，应该很容易理解</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--token_bucket.lua</span></span><br><span class="line"><span class="comment">--keys和argv都是数组</span></span><br><span class="line"><span class="comment">--tonumber()方法是转整数</span></span><br><span class="line"><span class="comment">--local表示本地变量，速度比全局变量快</span></span><br><span class="line"><span class="comment">--..表示拼接字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--local limit = tonumber(ARGV[1]);</span></span><br><span class="line"><span class="keyword">local</span> step = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">local</span> interval = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">local</span> nowTime = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lastClearTimeKey = <span class="string">'lastTimeOf'</span> .. key</span><br><span class="line"><span class="keyword">local</span> lastClearTime = redis.call(<span class="string">'GET'</span>, lastClearTimeKey);</span><br><span class="line"><span class="keyword">local</span> existKey = redis.call(<span class="string">'EXISTS'</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> existKey == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> diff = <span class="built_in">tonumber</span>(nowTime) - <span class="built_in">tonumber</span>(lastClearTime);</span><br><span class="line">    <span class="keyword">local</span> value = <span class="built_in">tonumber</span>(redis.call(<span class="string">'GET'</span>, key));</span><br><span class="line">    <span class="keyword">if</span> diff &gt; interval <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> maxValue = value + diff / interval * step;</span><br><span class="line">        <span class="keyword">if</span> maxValue &gt; step <span class="keyword">then</span></span><br><span class="line">            value = step;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            value = maxValue;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        redis.call(<span class="string">'SET'</span>, lastClearTimeKey, nowTime);</span><br><span class="line">        redis.call(<span class="string">'SET'</span>, key, <span class="built_in">math</span>.<span class="built_in">floor</span>(value));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        redis.call(<span class="string">'DECR'</span>, key);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">'SET'</span>, key, step - <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">'SET'</span>, lastClearTimeKey, nowTime);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="使用spring驱动">4. 使用spring驱动</h1><p>由于使用的是spring-boot，redis-server在本地，所以只要引入<code>spring-data-redis</code>和<code>jedis</code>,其他配置默认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>设置序列化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="comment">// 设置键的序列化器</span></span><br><span class="line">    redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    <span class="comment">// 默认Serializer,RedisTemplate在序列化key、反序列化返回值的时候找不到设置的Serializer会使用默认Serializer，而默认的默认Serializer是JdkSerializationRedisSerializer，这个会转成很难看的码可能导致lua执行出错</span></span><br><span class="line">    redisTemplate.setDefaultSerializer( <span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本的抽象类是<code>DefaultRedisScript</code>, 使用<code>RedisTemplate</code>调用。<br><code>keys</code>是<code>List</code>类型，<code>argvs</code>是数组类型，不可以搞混。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisScriptService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(RedisScriptService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">counterConsume</span><span class="params">(String key, <span class="keyword">int</span> limit, <span class="keyword">int</span> step, <span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; consumeRedisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        consumeRedisScript.setResultType(Long.class);</span><br><span class="line">        consumeRedisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">"script/token_bucket.lua"</span>)));<span class="comment">//加载lua脚本文件</span></span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; keyList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        keyList.add(key);<span class="comment">//通过KEYS[1]取值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"result:"</span> + redisTemplate.execute(consumeRedisScript, keyList, <span class="keyword">new</span> Object[]&#123;limit, step, interval, System.currentTimeMillis()&#125;).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2018-09-30 16:23:17.066  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.067  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.067  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.068  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.069  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.070  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.071  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.072  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.072  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.073  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:12018-09-30 16:23:17.074  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:02018-09-30 16:23:17.075  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:02018-09-30 16:23:17.076  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:02018-09-30 16:23:17.077  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:02018-09-30 16:23:17.078  INFO 18660 --- [           main] c.h.learning.service.RedisScriptService  : result:0</code></pre><p><code>result</code>的1是通过，0是不通过。</p><blockquote><p>键没有设置过期，可以优化。</p></blockquote><h1 id="Guava-RateLimiter">5. Guava RateLimiter</h1><p><code>Guava RateLimiter</code>实现了令牌桶算法。这里有一个中文版的官方文档：<a href="http://ifeve.com/guava-ratelimiter/" target="_blank" rel="noopener">Guava官方文档</a>，主要就是声明发牌速率，然后需要判断能否获取令牌，则调用<code>tryAcquire()</code>或<code>tryAcquire(int)</code>方法；需要阻塞直至令牌足够，则调用<code>acquire()</code>或<code>acquire(int)</code>。</p><h2 id="qps限制器">5.1. qps限制器</h2><p>假设我们要限制每秒处理task或者qps的值，代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">15</span>).forEach((a) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">5</span>) &#123;</span><br><span class="line">                SleepUtil.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(rateLimiter.acquire());</span><br><span class="line">            <span class="keyword">if</span> ((a + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>0.0// 0令牌，还不用阻塞0.1432130.1966860.1989480.1990560.0// 停了2秒，发了5个令牌0.00.00.00.00.0// 0令牌，还不用阻塞0.1995050.1987380.1976340.196273</code></pre><p>示例里先实例一个限流器，速率为1秒5次，通过<code>acquire()</code>阻塞获得令牌，总调用15次，并返回等待时间。第5次<code>acquire()</code>完的时候，挂起2秒。  </p><ul><li>从输出来看，第一次取得令牌是不用等待的。  </li><li>挂起2秒后，接下来的5次不用阻塞，再接下来的5次除了以第一次发生了阻塞(第一次)，也就是2秒内只发了5个令牌，不会累积。</li></ul><p>为什么看起来0令牌的情况下，第一次调用阻塞时间都是0呢？那是因为<code>RateLimiter</code>可以预消费（<code>acquire()</code>实际上是调用<code>acquire(1)</code>, 这和调用<code>acquire(1000)</code> 将得到相同的限制效果，如果存在这样的调用的话），但会影响下一次请求的，也就是说，如果一个高开销的任务抵达一个空闲的RateLimiter，它会被马上许可，但是下一个请求会经历额外的限制，从而来偿付高开销任务。</p><p>此外需注意：RateLimiter 并不提供公平性的保证，没有先来先得的概念。</p><p>这个类其实实现了<strong>令牌不足</strong>下多种应对策略</p><ul><li>require()属于流量整形的实现</li><li>tryRequire()属于服务限流的实现</li></ul><h1 id="后记">6. 后记</h1><p>除此之外，nginx也有限流模块，一种是限制连接数，一种是使用令牌桶算法，具体效果没实战。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;尝试一下用lua脚本执行redis命令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://htchz.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="服务限流" scheme="https://htchz.cc/tags/%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>[Golang基础]Goroutine调度</title>
    <link href="https://htchz.cc/2747343217.html"/>
    <id>https://htchz.cc/2747343217.html</id>
    <published>2018-09-28T06:48:00.000Z</published>
    <updated>2018-10-22T03:34:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘抄自小米运维</p></blockquote><a id="more"></a><h1 id="前言">1. 前言</h1><p>随着服务器硬件迭代升级，配置也越来越高。为充分利用服务器资源，并发编程也变的越来越重要。在开始之前，需要了解一下并发(concurrency)和并行(parallesim)的区别。</p><ul><li>并发:  逻辑上具有处理多个同时性任务的能力。</li><li>并行:   物理上同一时刻执行多个并发任务。</li></ul><p>通常所说的并发编程，也就是说它允许多个任务同时执行，但实际上并不一定在同一时刻被执行。在单核处理器上，通过多线程共享CPU时间片串行执行(并发非并行)。而并行则依赖于多核处理器等物理资源，让多个任务可以实现并行执行(并发且并行)。</p><p>多线程或多进程是并行的基本条件，但单线程也可以用协程(coroutine)做到并发。简单将Goroutine归纳为协程并不合适，因为它运行时会创建多个线程来执行并发任务，且任务单元可被调度到其它线程执行。这更像是多线程和协程的结合体，能最大限度提升执行效率，发挥多核处理器能力。</p><p>Go编写一个并发编程程序很简单，只需要在函数之前使用一个Go关键字就可以实现并发编程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"Hello,World!"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go调度器组成">2. Go调度器组成</h1><p>Go语言虽然使用一个 Go 关键字即可实现并发编程，但Goroutine被调度到后端之后，具体的实现比较复杂。先看看调度器有哪几部分组成。</p><ul><li>G</li><li>M</li><li>P</li></ul><h2 id="G">2.1. G</h2><p>G是 Go routine的缩写，相当于操作系统中的进程控制块，在这里就是Goroutine的控制结构，是对Goroutine的抽象。其中包括执行的函数指令及参数；G保存的任务对象；线程上下文切换，现场保护和现场恢复需要的寄存器(SP、IP)等信息。</p><blockquote><p>Go不同版本Goroutine默认栈大小不同。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go1.11版本默认stack大小为2KB</span></span><br><span class="line"></span><br><span class="line">_StackMin = <span class="number">2048</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个g对象,然后放到g队列</span></span><br><span class="line"><span class="comment">// 等待被执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    _g_.m.locks++</span><br><span class="line">    siz := narg</span><br><span class="line">    siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    newg := gfget(_p_)    </span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;        </span><br><span class="line">       <span class="comment">// 初始化g stack大小</span></span><br><span class="line">        newg = malg(_StackMin)</span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">        allgadd(newg)</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 以下省略&#125;</span></span><br></pre></td></tr></table></figure><h2 id="M">2.2. M</h2><p>M是一个线程或称为Machine，对应操作系统线程。所有M是有线程栈的。如果不对该线程栈提供内存的话，系统会给该线程栈提供内存(不同操作系统提供的线程栈大小不同)。当指定了线程栈，则M.stack→G.stack，M的PC寄存器指向G提供的函数，然后去执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.  所有调用栈的Goroutine,这是一个比较特殊的Goroutine。</span></span><br><span class="line"><span class="comment">        2.  普通的Goroutine栈是在Heap分配的可增长的stack,而g0的stack是M对应的线程栈。</span></span><br><span class="line"><span class="comment">        3.  所有调度相关代码,会先切换到该Goroutine的栈再执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    g0       *g</span><br><span class="line">    curg     *g         <span class="comment">// M当前绑定的结构体G</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SP、PC寄存器用于现场保护和现场恢复</span></span><br><span class="line">    vdsoSP <span class="keyword">uintptr</span></span><br><span class="line">    vdsoPC <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略…&#125;</span></span><br></pre></td></tr></table></figure><h2 id="P">2.3. P</h2><p>P(Processor)是一个抽象的概念，它存在的意义是为了限制并发任务的数量，并不是物理CPU的抽象。所以当P有任务时需要创建或者唤醒一个系统线程来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元。</p><p>P决定了同时可以并发任务的数量，可通过GOMAXPROCS限制同时执行用户级任务的操作系统线程。可以通过runtime.GOMAXPROCS进行指定。在Go1.5之后GOMAXPROCS被默认设置可用的核数，而之前则默认为1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义设置GOMAXPROCS数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.  GOMAXPROCS设置可执行的CPU的最大数量,同时返回之前的设置。</span></span><br><span class="line"><span class="comment">        2.  如果n &lt; 1,则不更改当前的值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret := <span class="keyword">int</span>(gomaxprocs)</span><br><span class="line"></span><br><span class="line">    stopTheWorld(<span class="string">"GOMAXPROCS"</span>)    </span><br><span class="line">    <span class="comment">// startTheWorld启动时,使用newprocs。</span></span><br><span class="line">    newprocs = <span class="keyword">int32</span>(n)</span><br><span class="line">    startTheWorld()    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认P被绑定到所有CPU核上</span></span><br><span class="line"><span class="comment">// P == cpu.cores</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getproccount</span><span class="params">()</span> <span class="title">int32</span></span> &#123;    </span><br><span class="line">    <span class="keyword">const</span> maxCPUs = <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">    <span class="keyword">var</span> buf [maxCPUs / <span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CPU Core</span></span><br><span class="line">    r := sched_getaffinity(<span class="number">0</span>, unsafe.Sizeof(buf), &amp;buf[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    n := <span class="keyword">int32</span>(<span class="number">0</span>)    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> buf[:r] &#123;        </span><br><span class="line">       <span class="keyword">for</span> v != <span class="number">0</span> &#123;</span><br><span class="line">            n += <span class="keyword">int32</span>(v &amp; <span class="number">1</span>)</span><br><span class="line">            v &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">       n = <span class="number">1</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个进程默认被绑定在所有CPU核上,返回所有CPU core。</span></span><br><span class="line"><span class="comment">// 获取进程的CPU亲和性掩码系统调用</span></span><br><span class="line"><span class="comment">// rax 204                          ; 系统调用码</span></span><br><span class="line"><span class="comment">// system_call sys_sched_getaffinity; 系统调用名称</span></span><br><span class="line"><span class="comment">// rid  pid                         ; 进程号</span></span><br><span class="line"><span class="comment">// rsi unsigned int len             </span></span><br><span class="line"><span class="comment">// rdx unsigned long *user_mask_ptr</span></span><br><span class="line">sys_linux_amd64.s:</span><br><span class="line">TEXT runtime·sched_getaffinity(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">    MOVQ    pid+<span class="number">0</span>(FP), DI</span><br><span class="line">    MOVQ    <span class="built_in">len</span>+<span class="number">8</span>(FP), SI</span><br><span class="line">    MOVQ    buf+<span class="number">16</span>(FP), DX</span><br><span class="line">    MOVL    $SYS_sched_getaffinity, AX</span><br><span class="line">    SYSCALL</span><br><span class="line">    MOVL    AX, ret+<span class="number">24</span>(FP)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><h1 id="调度过程">3. 调度过程</h1><p><img src="/images/pasted-148.png" alt="upload successful"><br>首先创建一个G对象，G对象保存到<strong>P本地队列或者是全局队列</strong>。P此时去唤醒一个M。P继续执行它的执行序。M寻找是否有空闲的P，如果有则将该G对象移动到它本身。接下来M执行一个调度循环(调用G对象-&gt;执行-&gt;清理线程→继续找新的Goroutine执行)。</p><p>M执行过程中，随时会发生上下文切换。当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go调度器M的栈保存在G对象上，只需要将M所需要的寄存器(SP、PC等)保存到G对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时G任务还没有执行完，M可以将任务重新丢到P的任务队列，等待下一次被调度执行。当再次被调度执行时，M通过访问G的vdsoSP、vdsoPC寄存器进行现场恢复(从上次中断位置继续执行)。</p><p>当M从队列中拿到一个可执行的G后，首先会去检查一下P队列中是否还有等待的G，如果还有等待的G，并且也还有空闲的P，此时就会通知runtime分配一个新的M（如果有在睡觉的OS线程，则直接唤醒它，没有的话则生成一个新的OS线程）来分担任务。</p><p>如果某个M发现队列为空之后，会首先从全局队列中取一个G来处理。如果全局队列也空了，则会随机从别的P那里直接截取一半的队列过来（偷窃任务），如果发现所有的P都没有可供偷窃的G了，该M就会陷入沉睡。</p><blockquote><p>这种协作调度回导致全剧队列会响应得慢一丢丢，但是在总体上这种调度将处理器的机器性能充分发挥。</p></blockquote><h2 id="P-队列">3.1. P 队列</h2><p>通过上图可以发现，P有两种队列：本地队列和全局队列。</p><ul><li>本地队列： 当前P的队列，本地队列是Lock-Free，没有数据竞争问题，无需加锁处理，可以提升处理速度。</li><li>全局队列： 全局队列为了保证多个P之间任务的平衡。所有M共享P全局队列，为保证数据竞争问题，需要加锁处理。相比本地队列处理速度要低于全局队列。</li></ul><h2 id="上线文切换">3.2. 上线文切换</h2><p>简单理解为当时的环境即可，环境可以包括当时程序状态以及变量状态。例如线程切换的时候在内核会发生上下文切换，这里的上下文就包括了当时寄存器的值，把寄存器的值保存起来，等下次该线程又得到cpu时间的时候再恢复寄存器的值，这样线程才能正确运行。</p><p>对于代码中某个值说，上下文是指这个值所在的局部(全局)作用域对象。相对于进程而言，上下文就是进程执行时的环境，具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存(堆栈)信息等。</p><h2 id="线程清理">3.3. 线程清理</h2><p>Goroutine被调度执行必须保证P/M进行绑定，所以线程清理只需要将P释放就可以实现线程的清理。什么时候P会释放，保证其它G可以被执行。P被释放主要有两种情况。</p><ul><li>主动释放： 最典型的例子是，当执行G任务时有系统调用，当发生系统调用时M会处于Block状态。调度器会设置一个超时时间，当超时时会将P释放。</li><li>被动释放： 如果发生系统调用，有一个专门监控程序，进行扫描当前处于阻塞的P/M组合。当超过系统程序设置的超时时间，会自动将P资源抢走。去执行队列的其它G任务。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘抄自小米运维&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang基础" scheme="https://htchz.cc/categories/Golang%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="goroutine" scheme="https://htchz.cc/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>[Java基础]ForkJoinPool</title>
    <link href="https://htchz.cc/2843017067.html"/>
    <id>https://htchz.cc/2843017067.html</id>
    <published>2018-09-20T09:01:00.000Z</published>
    <updated>2018-10-22T03:34:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jdk8的parallerStream的实现依赖这种线程池。这个类带上注释3478行，表示很慌。</p></blockquote><a id="more"></a><h1 id="前言">1. 前言</h1><p>设计这个线程池的原因不是为了取代<code>ThreadPoolExecutor</code>，ForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</p><h1 id="使用例子">2. 使用例子</h1><p>核心思想就是拆分任务，这很快排的原理是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.htc.learning.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).toArray();</span><br><span class="line">        fork(numbers);</span><br><span class="line">        forkAndJoin(numbers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fork</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line">        pool.invoke(<span class="keyword">new</span> PrintTask(<span class="number">0</span>, numbers.length -<span class="number">1</span> , numbers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkAndJoin</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line">        <span class="keyword">long</span> sum = pool.invoke(<span class="keyword">new</span> SumTask(<span class="number">0</span>, numbers.length - <span class="number">1</span>, numbers));</span><br><span class="line">        System.out.println(<span class="string">"sum is :"</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是没有join结果的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小任务的打印量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">long</span>[] List)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.list = List;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                System.out.print(list[i] + <span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            PrintTask leftTask = <span class="keyword">new</span> PrintTask(start, middle, list);</span><br><span class="line">            PrintTask rightTask = <span class="keyword">new</span> PrintTask(middle + <span class="number">1</span>, end, list);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是join结果的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 小任务的计算量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">long</span>[] list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += list[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            SumTask leftTask = <span class="keyword">new</span> SumTask(start, middle, list);</span><br><span class="line">            SumTask rightTask = <span class="keyword">new</span> SumTask(middle + <span class="number">1</span>, end, list);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/images/pasted-143.png" alt="upload successful"></p><p>结果很乱，可以看出<code>fork()</code>是异步的，如果使用<code>join()</code>阻塞的话，可以将计算变为同步。</p><h1 id="原理">3. 原理</h1><p>老李的<a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener">论文</a></p><ol><li>分治。这个从使用方式就可以看出来。</li><li>工作窃取（work-stealing）。</li><li>每个工作队列一个线程。</li></ol><p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为<strong>每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应</strong>，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><blockquote><p>据说ForkJoinPool在jdk7和jdk8的实现不一样。现在是jdk8的时代，我暂时不去看jdk7的实现啦。</p></blockquote><p><img src="/images/pasted-146.png" alt="upload successful"></p><ul><li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li><li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li><li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li><li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。（其实我不理解这句话，什么叫遇到join()时）</li><li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li></ul><p>那么<code>fork()</code>每次调用都会创建一个线程吗，答案并不是，对于<code>ForkJoinPool</code>构造函数给出线程数就创建多少线程。<br>那么<code>join()</code>也会阻塞吗，不一定，具体我们后面看源码实现。</p><h1 id="概念">4. 概念</h1><p><img src="/images/pasted-145.png" alt="upload successful"></p><ul><li><code>ForkJoinPool</code>: 用于执行<code>ForkJoinTask</code>任务的执行池,不再是传统执行池 <code>Worker+Queue</code> 的组合模式,而是维护了一个队列数组<code>WorkQueue</code>,这样在提交任务和线程任务的时候大幅度的减少碰撞。<br>]</li><li><code>WorkQueue</code>: <strong>双向</strong>列表,用于任务的有序执行,如果<code>WorkQueue</code>用于自己的执行线程<code>Thread</code>,线程默认将会从top端选取任务用来执行 - LIFO。因为只有owner的Thread才能从<code>top</code>端取任务,所以在设置变量时, <code>int top</code>; 不需要使用 <code>volatile</code>。</li><li><code>ForkJoinWorkThread</code>: 用于执行任务的线程,用于区别使用非<code>ForkJoinWorkThread</code>线程提交的task;启动一个该<code>Thread</code>,会自动注册一个<code>WorkQueue</code>到<code>Pool</code>,这里规定,<strong>拥有<code>Thread</code>的<code>WorkQueue</code>只能出现在<code>WorkQueue</code>数组的奇数位</strong></li><li><code>ForkJoinTask</code>: 任务, 它比传统的任务更加轻量，不再对是<code>RUNNABLE</code>的子类,提供<code>fork/join</code>方法用于分割任务以及聚合结果。</li><li>为了充分施展并行运算,该框架实现了复杂的 <code>worker steal</code>算法,当任务处于等待中,thread通过一定策略,不让自己挂起，充分利用资源，当然，它比其他语言的协程要重一些。</li></ul><h1 id="sun-misc-Contended">5. sun.misc.Contended</h1><p>打开ForkJoinPool，第一行就是这么个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>度娘一下，看到了一个叫<strong>缓存行</strong>的东西，这个注解就是为了解决缓存行的<strong>伪共享</strong><code>False Sharing</code></p><blockquote><p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p></blockquote><p>看图：<br><img src="/images/pasted-144.png" alt="upload successful"><br>在缓存行L3 Cache里有x，y，线程1想去修改x，线程2想去修改y，那么这行缓存行就会称谓竞争对象，竞争的过程就会产生性能的损耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// change  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayIndex;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里分别换成不同的类的数组，使用数组是为了内存连续</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong3[] longs = <span class="keyword">new</span> VolatileLong3[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;  </span><br><span class="line">            longs[i] = <span class="keyword">new</span> VolatileLong3();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();  </span><br><span class="line">        runTest();  </span><br><span class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;  </span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;  </span><br><span class="line">            t.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;  </span><br><span class="line">            t.join();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;  </span><br><span class="line">            longs[arrayIndex].value = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// long padding避免false sharing  </span></span><br><span class="line">    <span class="comment">// 按理说jdk7以后long padding应该被优化掉了，但是从测试结果看padding仍然起作用  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong2</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// jdk8新特性，Contended注解避免false sharing  </span></span><br><span class="line">    <span class="comment">// Restricted on user classpath  </span></span><br><span class="line">    <span class="comment">// Unlock: -XX:-RestrictContended  </span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong3</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换三种声明，测试结果如下</p><pre><code>VolatileLong: duration = 31605817365VolatileLong2:duration = 3725651254VolatileLong3:duration = 3762335746</code></pre><p>VolatileLong2的原理：<br>缓冲行有64字节，那么在属性<code>value</code>前面排列7个long，后面排列7个long，放到内存的时候，<code>value</code>无论如何都会和周围的long成员组成一个8个long，即64字节，从而避免缓存行的竞争。</p><p>而jdk8提供了<code>@sun.misc.Contended</code>注解后就不用写的这么麻烦了(也是填充了字节，具体看<a href="https://www.jianshu.com/p/c3c108c3dcfd" target="_blank" rel="noopener">Java8使用@sun.misc.Contended避免伪共享</a>)。</p><h1 id="基本说明">6. 基本说明</h1><h2 id="ForkJoinPool">6.1. ForkJoinPool</h2><p><code>ForkJoinPool</code>有超多的常量,下面是一部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bits and masks for field ctl, packed with 4 16 bit subfields:</span></span><br><span class="line"><span class="comment"> * AC: Number of active running workers minus target parallelism</span></span><br><span class="line"><span class="comment"> * TC: Number of total workers minus target parallelism</span></span><br><span class="line"><span class="comment"> * SS: version count and status of top waiting thread</span></span><br><span class="line"><span class="comment"> * ID: poolIndex of top of Treiber stack of waiters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When convenient, we can extract the lower 32 stack top bits</span></span><br><span class="line"><span class="comment"> * (including version bits) as sp=(int)ctl.  The offsets of counts</span></span><br><span class="line"><span class="comment"> * by the target parallelism and the positionings of fields makes</span></span><br><span class="line"><span class="comment"> * it possible to perform the most common checks via sign tests of</span></span><br><span class="line"><span class="comment"> * fields: When ac is negative, there are not enough active</span></span><br><span class="line"><span class="comment"> * workers, when tc is negative, there are not enough total</span></span><br><span class="line"><span class="comment"> * workers.  When sp is non-zero, there are waiting workers.  To</span></span><br><span class="line"><span class="comment"> * deal with possibly negative fields, we use casts in and out of</span></span><br><span class="line"><span class="comment"> * "short" and/or signed shifts to maintain signedness.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because it occupies uppermost bits, we can add one active count</span></span><br><span class="line"><span class="comment"> * using getAndAddLong of AC_UNIT, rather than CAS, when returning</span></span><br><span class="line"><span class="comment"> * from a blocked join.  Other updates entail multiple subfields</span></span><br><span class="line"><span class="comment"> * and masking, requiring CAS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Lower and upper word masks</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK    = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK    = ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Active counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  AC_SHIFT   = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK    = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Total counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TC_SHIFT   = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK    = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSLOCK     = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSIGNAL    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STARTED    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STOP       = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  SHUTDOWN   = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p><strong>runstate</strong>：如果执行 runState &amp; RSLOCK ==0 就能直接说明,目前的运行状态没有被锁住,其他情况一样。</p><p><strong>config</strong>：parallelism， mode。parallelism是构造函数的参数，表示并行等级，不等于工作队列的数量。需要注意一下它的界限，最大是0x7fff。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// max #workers - 1</span></span><br></pre></td></tr></table></figure><p><strong>ctl</strong>：ctl是Pool的状态变量,类型是long - 说明有64位,每个部分都有不同的作用。我们使用十六进制来标识ctl，依次说明不同部分的作用。（这和普通线程池一样）</p><p>以下是构造函数，可以看到<code>ctl</code>的初始化，我们把<code>ctl</code>标识为4部分，<br>0x xxxx-1  xxxx-2  xxxx-3  xxxx-4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters, without</span></span><br><span class="line"><span class="comment"> * any security checks or parameter validation.  Invoked directly by</span></span><br><span class="line"><span class="comment"> * makeCommonPool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1号16位，表示AC(Active counts)并行数的负数。当ctl变成正数的时候表示线程数达到阈值了。(为什么不能用正数，然后负数的时候就表示达到阈值？？)</li><li>2号16位，表示TC(Total counts)并行数。Total counts等于挂起的线程数+AC，(也是用负数表示)</li><li>3号16位，表示SS，后32位标识<strong>idle workers</strong> 前面16位第一位标识是<code>active</code>的还是<code>inactive</code>的,其他为是版本标识。</li><li>4号16位，表示ID(Index)，标识<strong>idle workers</strong>在<code>WorkQueue[]</code>数组中的<code>index</code>。这里需要说明的是,ctl的后32位其实只能表示一个idle workers，那么我们如果有很多个idle worker要怎么办呢？老李使用的是stack的概念来保存这些信息。后32位标识的是栈顶的那个,我们能从栈顶中的变量stackPred追踪到下一个idle worker</li></ul><h2 id="WorkQueue">6.2. WorkQueue</h2><p><code>WorkQueue</code>是一个双向列表,存放任务<code>task</code>。<br><code>WorkQueue</code>类也用了<code>@sun.misc.Contended</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Capacity of work-stealing queue array upon initialization.</span></span><br><span class="line"><span class="comment">         * Must be a power of two; at least 4, but should be larger to</span></span><br><span class="line"><span class="comment">         * reduce or eliminate cacheline sharing among queues.</span></span><br><span class="line"><span class="comment">         * Currently, it is much larger, as a partial workaround for</span></span><br><span class="line"><span class="comment">         * the fact that JVMs often place arrays in locations that</span></span><br><span class="line"><span class="comment">         * share GC bookkeeping (especially cardmarks) such that</span></span><br><span class="line"><span class="comment">         * per-write accesses encounter serious memory contention.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Maximum size for queue arrays. Must be a power of two less</span></span><br><span class="line"><span class="comment">         * than or equal to 1 &lt;&lt; (31 - width of array entry) to ensure</span></span><br><span class="line"><span class="comment">         * lack of wraparound of index calculations, but defined to a</span></span><br><span class="line"><span class="comment">         * value a bit less than this to help users trap runaway</span></span><br><span class="line"><span class="comment">         * programs before saturating systems.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instance fields</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line">        <span class="keyword">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor</span></span><br><span class="line">        <span class="keyword">int</span> nsteals;               <span class="comment">// number of steals</span></span><br><span class="line">        <span class="keyword">int</span> hint;                  <span class="comment">// randomization and stealer index hint</span></span><br><span class="line">        <span class="keyword">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line">        <span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line">        <span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line">        <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line">        <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br><span class="line"></span><br><span class="line">        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">            <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">            base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING     = <span class="number">1</span>;             <span class="comment">// false when running tasks</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE     = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br></pre></td></tr></table></figure><p><strong>scanState</strong>:负数表示inactive; 奇数表示scanning。如果WorkQueue没有属于自己的owner(下标为偶数的都没有),该值为 inactive 也就是一个负数。如果有自己的owner，该值的初始值为其在WorkQueue[]数组中的下标，也肯定是个奇数。<br>如果这个值，变成了偶数，说明该队列所属的Thread正在执行Task<br><strong>stackPred</strong>: 记录前任的 idle worker<br><strong>config</strong>：index | mode。 如果下标为偶数的WorkQueue,则其mode是共享类型。如果有自己的owner 默认是 LIFO。mode是由<code>ForkJoinPool</code>其中一个构造函数传进来的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism the parallelism level. For default value,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> java.lang.Runtime#availableProcessors&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory the factory for creating new threads. For default value,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> #defaultForkJoinWorkerThreadFactory&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler for internal worker threads that</span></span><br><span class="line"><span class="comment"> * terminate due to unrecoverable errors encountered while executing</span></span><br><span class="line"><span class="comment"> * tasks. For default value, use &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asyncMode if true,</span></span><br><span class="line"><span class="comment"> * establishes local first-in-first-out scheduling mode for forked</span></span><br><span class="line"><span class="comment"> * tasks that are never joined. This mode may be more appropriate</span></span><br><span class="line"><span class="comment"> * than default locally stack-based mode in applications in which</span></span><br><span class="line"><span class="comment"> * worker threads only process event-style asynchronous tasks.</span></span><br><span class="line"><span class="comment"> * For default value, use &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if parallelism less than or</span></span><br><span class="line"><span class="comment"> *         equal to zero, or greater than implementation limit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the factory is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment"> *         the caller is not permitted to modify threads</span></span><br><span class="line"><span class="comment"> *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> ("modifyThread")&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">         checkFactory(factory),</span><br><span class="line">         handler,</span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">         <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>英文不太ok，看了注释应该是，asyncMode下工作线程在处理本地任务时也使用 FIFO 顺序。这种模式下的 ForkJoinPool 更接近于是一个消息队列，而不是用来处理递归式的任务。<a href="https://stackoverflow.com/questions/5640046/what-is-forkjoinpool-async-mode" target="_blank" rel="noopener">stackoverflow</a>有个回答举了个例子，可以明显看到asyncMode的先进先出的执行方式。<br>我想你的ForkJoinPool不是私有的，那就设置成异步模式吧。</p></blockquote><p><strong>qlock</strong>：队列锁<br><strong>base</strong>：<code>worker steal</code>的偏移量,因为其他的线程都可以偷该队列的任务,所有base使用<code>volatile</code>标识。<br><strong>top</strong>:owner执行任务的偏移量。<br><strong>parker</strong>:如果 <code>owner</code> 挂起，则使用该变量做记录<br><strong>currentJoin</strong>:当前正在<code>join</code>等待结果的任务。<br><strong>currentSteal</strong>:当前执行的任务是steal过来的任务，该变量做记录。  </p><h2 id="ForkJoinTask">6.3. ForkJoinTask</h2><p>这是个抽象类,我们声明的任务是他的子类，下面是他的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The run status of this task */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status; <span class="comment">// accessed directly by pool and workers</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// mask out non-completion bits</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">// short bits for tags</span></span><br></pre></td></tr></table></figure><p>如果<code>status</code> &lt; 0，表示任务已经结束<br><code>((s &gt;&gt;&gt; 16) != 0)</code>表示需要signal其他线程</p><h2 id="ForkJoinWorkerThread">6.4. ForkJoinWorkerThread</h2><p>这就是工作线程的封装，继承自<code>Thread</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ForkJoinWorkerThreads are managed by ForkJoinPools and perform</span></span><br><span class="line"><span class="comment">     * ForkJoinTasks. For explanation, see the internal documentation</span></span><br><span class="line"><span class="comment">     * of class ForkJoinPool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This class just maintains links to its pool and WorkQueue.  The</span></span><br><span class="line"><span class="comment">     * pool field is set immediately upon construction, but the</span></span><br><span class="line"><span class="comment">     * workQueue field is not set until a call to registerWorker</span></span><br><span class="line"><span class="comment">     * completes. This leads to a visibility race, that is tolerated</span></span><br><span class="line"><span class="comment">     * by requiring that the workQueue field is only accessed by the</span></span><br><span class="line"><span class="comment">     * owning thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Support for (non-public) subclass InnocuousForkJoinWorkerThread</span></span><br><span class="line"><span class="comment">     * requires that we break quite a lot of encapsulation (via Unsafe)</span></span><br><span class="line"><span class="comment">     * both here and in the subclass to access and set Thread fields.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// the pool this thread works in</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// work-stealing mechanics</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以清楚地看到，ForkJoinWorkThread持有ForkJoinPool和ForkJoinPool.WorkQueue的引用，以表明该线程属于哪个线程池，它的工作队列是哪个</p><h1 id="重场戏">7. 重场戏</h1><h2 id="通用ForkJoinPool的初始化">7.1. 通用ForkJoinPool的初始化</h2><p><code>ForkJoinPool</code>类的static代码块初始化了一个全局通用的ForkJoinPool，这是老李推荐的使用方式，不用自己new new new。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title">commonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert common != null : "static init error";</span></span><br><span class="line">    <span class="keyword">return</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns the common pool, respecting user settings</span></span><br><span class="line"><span class="comment"> * specified via system properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing properties</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>);</span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span>);</span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">"ForkJoinPool.commonPool-worker-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个参数可以通过java -D指定，如果不指定，那么使用默认参数构造，并行数默认情况是<code>计算机处理器数-1</code></p><h2 id="任务提交">7.2. 任务提交</h2><p>我们提交的任务，不管是<code>Runnable</code>,<code>Callable</code>，<code>ForkJoinTask</code>，最终都会变成封装为<code>ForkJoinTask</code>。</p><p>由于实现了<code>ExecutorService</code>，自然实现了<code>submit(task)</code>、<code>execute(task)</code>方法，而他自己还又一个<code>invoke(task)</code>的方法，这么多个执行，什么时候用什么呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>execute(task)</code>和普通线程池一样无返回，<code>submit(task)</code>返回了一个<code>ForkJoinTask</code>,而<code>invoke(task)</code>返回直接调用<code>join()</code>阻塞，知道计算得出结果返回。</p><p>这几个都是调用<code>externalPush(task);</code>方法，和普通线程池一样，在提交任务的过程中会视情况增加工作线程，和普通线程池不一样的是还要同时增加工作队列。</p><blockquote><p>注意：工作线程和工作队列的不是一对一关系 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to add the given task to a submission queue at</span></span><br><span class="line"><span class="comment"> * submitter's current queue. Only the (vastly) most common path</span></span><br><span class="line"><span class="comment"> * is directly handled in this method, while screening for need</span></span><br><span class="line"><span class="comment"> * for externalSubmit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 取得一个随机探查数，可能为0也可能为其它数</span></span><br><span class="line">    <span class="comment">// 利用这个数提交到任务队列数组中的随机一个队列</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="comment">// 他喵的这个if有够复杂</span></span><br><span class="line">    <span class="comment">// SQMASK = 0x007e，也就是0000 0000 0111 1110，与这个数与出来的结果，只能是个偶数</span></span><br><span class="line">    <span class="comment">// 如果（（任务队列数组非空）且（数组长度&gt;=1）且（数组长度-1与随机数与0x007e得出来的下标处有工作队列）且（随机数!=0）且（线程池在运行）且（获取锁成功））</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;<span class="comment">// am=数组长度，n=top-base，s=top</span></span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// 感觉这个不为true的情况只能是==，不会&lt;</span></span><br><span class="line">            (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="comment">// ABASE是利用Unsafe得到的队列base属性内存地址，因为用Unsafe加入队列，所以要计算出top的内存地址</span></span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">// 以下三个原子操作首先是将task放入队列,</span></span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            <span class="comment">// 然后将“q”这个submission queue的top标记+1,记得queue的owner线程是默认从top拿的任务</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果条件成立，说明这时处于active的工作线程可能还不够，调用signalWork方法</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可能上面没有解锁，保证能解锁。</span></span><br><span class="line">        <span class="comment">// 这不会解锁了其他小偷吗 = =</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我注意到了这个方法<code>ThreadLocalRandom.getProbe()</code>，这是个一个包级别的方法，只有<code>concurrent</code>包才能用他。这个方法返回一个随机数，而且是固定的，但是如果没执行<code>ThreadLocalRandom.localInit();</code>，调用结果会是0。</p><blockquote><p>把他的源码复制出来后执行得出来的结论。</p></blockquote><p>也就是说，主线程执行<code>externalPush</code>的时候，由于<code>ThreadLocalRandom.getProbe();</code>返回一直0，是直接进入<code>externalSubmit(task)</code></p><p>那坨<code>if</code>块主要做的是按线程给的随机数随机放入<code>workqueue</code>数组中队列，随机方式是<code>m &amp; r &amp; SQMASK</code>，(数组大小-1)与随机数与<strong>偶数掩码</strong></p><p>入队的方式是放到随机队列的top位置，利用Unsafe来操作，真是🐂🍺，而队列owner拿的时候也是从top拿。</p><p><code>externalSubmit(task)</code>的代码很长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;                                    <span class="comment">// initialize caller's probe</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果条件成立，就说明当前ForkJoinPool类中，还没有任何队列，所以要进行队列初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                 ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                                           <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 方法的唯一出口</span></span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 即上面的队列==null且runstate没有被锁住</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            <span class="comment">// 重新获取一个随机数</span></span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>如果hash之后的队列已经存在  </p><ul><li>lock住队列,将数据塞到top位置。如果该队列任务很少(n &lt;= 1)也会调用<code>signalWork</code></li></ul></li><li><p>如果第一次提交(或者是hash之后的队列还未初始化),调用externalSubmit</p><ul><li>第一遍循环: (runState不是开始状态): 1.<code>lock</code>; 2.创建数组<code>WorkQueue[n]</code>，这里的n是根据<code>parallelism</code>初始化的; 3. <code>runState</code>设置为开始状态。</li><li>第二遍循环:(根据<code>ThreadLocalRandom.getProbe()</code>hash后的数组中相应位置的WorkQueue未初始化): 初始化<code>WorkQueue</code>,通过这种方式创立的<code>WorkQueue</code>均是<code>SUBMISSIONS_QUEUE</code>(<code>owner</code>为<code>null</code>),<code>scanState</code>为<code>INACTIVE</code></li><li>第三遍循环: 找到刚刚创建的WorkQueue,lock住队列,将数据塞到array<code>top</code>位置。如添加成功，就用调用接下来要摊开讲的重要的方法<code>signalWork</code>。</li></ul></li></ul><h3 id="parallelism初始化">7.2.1. parallelism初始化</h3><p>关于parallelism，我们浓缩一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// SMASK是一个常量，即 00000000 00000000 11111111 11111111</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK = <span class="number">0xffff</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 这是config的来源</span></span><br><span class="line"><span class="comment">// mode是ForkJoinPool构造函数中设定的asyncMode，如果为LIFO，则mode为0，否则为1&lt;&lt;16(FIFO_QUEUE),也就是说，config中低16位代表并行度</span></span><br><span class="line"><span class="comment">// parallelism 为技术人员设置的（或者程序自行设定的）并发等级</span></span><br><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// ensure at least 2 slots</span></span><br><span class="line"><span class="comment">// 取config的低16位</span></span><br><span class="line"><span class="keyword">int</span> p = config &amp; SMASK; </span><br><span class="line"><span class="comment">// n这个变量就是要计算的WorkQueue数组的大小</span></span><br><span class="line"><span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这么多位操作，在<code>java.util.HashMap#tableSizeFor</code>(本博客有)里也有出现过，<code>tableSizeFor</code>是为了计算出最接近且大于给定的构造容量的2幂数，而这里的位操作，比<code>tableSizeFor</code>多了一个<code>n = (n + 1) &lt;&lt; 1;</code>的计算，也就是计算出最接近且大于给定的构造容量的2幂数——然后在<code>*2</code>，ForkJoinPool中的这些WorkQueue和工作线程ForkJoinWorkerThread并不是一对一的关系，而是随时都有多余ForkJoinWorkerThread数量的WorkQueue元素。而这个ForkJoinPool中的WorkQueue数组中，索引位为非奇数的工作队列用于存储从外部提交到ForkJoinPool中的任务，也就是所谓的submissions queue；索引位为偶数的工作队列用于存储归并计算过程中等待处理的子任务，也就是task queue。<br><img src="/images/pasted-147.png" alt="upload successful"></p><p>我们看<code>signalWork(ws, q)</code>做了什么，这个会触发构造新队列和新线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to create or activate a worker if too few are active.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ws the worker array to use to find signallees</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q a WorkQueue --if non-null, don't retry if now empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line"><span class="comment">// c是ctl，sp是ctl低32位</span></span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要就是一个<code>while</code>循环循环，当<code>ctl</code>小于0的时候才要进行创建和激活新线程。</p><p>如果<code>sp</code>等于0，表示没有空闲线程。此时<code>(c &amp; ADD_WORKER) != 0L</code>即TC符号位是1，TC是个负数，表示<code>worker</code>还可以增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADD_WORKER是一个第48位为1，其余为0的64数，可以区分TC的符号位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign</span></span><br></pre></td></tr></table></figure><p>下面看<code>tryAddWorker(c)</code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// new ctl</span></span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先需要使用ctl来记录我们增加的线程, ctl编号-1的16位和编号-2的16位均需要加1,表示active的worker(AC)加一，总的worker(TC)加一。成功后我们将调用<code>createWorker</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跑到这里来要注销线程</span></span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>fac.newThread(this)</code>怎么实例化一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread(pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>pool.registerWorker(this);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>ForkJoinWorkerThreadFactory</code>来产生一个<code>ForkJoinWorkerThread</code>类型的线程，该线程将会把自己注册到Pool上,怎么注册的呢？实现在方法<code>registerWorker</code>,前文我们已经提及,拥有线程的WorkQueue只能出现在数组的奇数下标处。所以线程首先,创建一个新的WorkQueue，其次在数组WorkQueue[]寻找奇数下标尚未初始化的位置,如果循环的次数大于数组长度,还可能需要对数组进行扩容，然后，设置这个WorkQueue的 config 为 index | mode (下标和模式),<code>scanState</code>为 index (下标&gt;0)。最后启动这个线程。线程的处理我们接下来的章节介绍。</p><p>回到<code>signalWork</code>方法,如果<code>(sp = (int)c) == 0</code>不成立，表示又空闲线程，那么不用新增<code>worker</code>，直接唤醒工作队列的<code>owner</code></p><p>我们上文说过SP的高16位SS,标记inactive和版本控制,我们将SS设置为激活状态并且版本加一。ID的16位我们之前也说过,放置了挂起线程栈的index所以我们可以根据这个index拿到WorkQueue——意味着就是这个WorkQueue的Owner线程被挂起了。</p><blockquote><p>worker什么时候挂起？</p></blockquote><p>我们将要把栈顶挂起线程唤醒,意味着我们要讲下一个挂起的线程的信息记录到ctl上。前文也说在上一个挂起的线程的index信息在这个挂起的线程的stackPred。利用cas进行更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line"><span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line"><span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">    v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">    <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">        U.unpark(p);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作线程的运行">7.3. 工作线程的运行</h2><p>Thread添加完成之后，执行<code>wt.start();</code>，这个方法会使得<code>run()</code>方法开始运行。</p><p>看<code>ForkJoinWorkerThread</code>的<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            <span class="comment">// 看节里</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Top-level runloop for workers, called by ForkJoinWorkerThread.run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)</span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift 随机数算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程先尝试<code>scan</code>窃取任务并执行，否则执行<code>awaitWork()</code>，如果<code>awaitWork()</code>返回<code>false</code>，<code>break</code>结束死循环。</p><h3 id="scan">7.3.1. scan</h3><p>又是一个长长的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们的WorkQueue是有owner线程的队列，我们可以知道以下信息:</p><ul><li>config = index | mode</li><li>scanState = index &gt; 0<br>我们首先通过随机数<code>r</code>来寻找窃取队列。</li></ul><p>如果我们准备偷取的队列刚好有任务(也有可能是owner自己的那个队列)；</p><ul><li>从队列的队尾即base位置取到任务返回<ul><li>base + 1</li></ul></li><li>如果我们遍历了一圈<code>(((k = (k + 1) &amp; m) == origin))</code>都没有偷到,我们就认为当前的active线程过剩了,我们准备将当前的线程(即owner)挂起,我们首先 <code>index | INACTIVE</code> 形成 ctl的后32位;并行将AC减一。其次，将原来的挂起的栈顶的index记录到stackPred中。</li><li>继续遍历如果仍然一无所获,将跳出循环；如果偷到了一个任务,我们将使用tryRelease激活。</li></ul><h3 id="runTask">7.3.2. runTask</h3><p>获取到任务之后，执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        <span class="comment">// 执行窃取来的任务</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        <span class="comment">// 这里执行自己的线程的任务</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先scanState &amp;= ~SCANNING;标识该线程处于繁忙状态。</p><ul><li>执行偷取的Task。</li><li>调用execLocalTasks对线程所属的WorkQueue内的任务进行执行,按config设置的mode进行FIFO或者LIFO执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject</span><br><span class="line">                     (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="awaitWork">7.3.3. awaitWork</h3><p>scan不到任务的时候，就执行挂起，如果挂起返回false，表示线程池终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="keyword">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果ac还没到达阈值,但是<code>TC&gt;2</code>说明现在仍然运行中的线程和挂起的线程加一起处于过剩状态,我们将放弃该线程的挂起,直接让它执行结束，不再循环执行任务。</li><li>否则，我们计算一个挂起的时间，等到了时间之后(或者被外部唤醒),线程醒了之后,如果发现自己状态是active状态(<code>w.scanState &gt;= 0</code>),则线程继续回去scan任务，如果挂起时间结束，自己还是inactive状态,。线程也会执行结束，不再循环执行任务。</li></ul><h2 id="任务执行">7.4. 任务执行</h2><p>任务的执行是调用了<code>task.doExec()</code>方法，可以在<code>runTask(task)</code>方法看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>RecursiveTask</code>为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     result = compute();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用了我们重写的<code>compute()</code>方法。</p><h3 id="fork">7.4.1. fork</h3><p>fork()像叉子把新任务提交，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前线程是工作线程,直接push到自己所拥有的队列的top位置。</li><li>如果是非工作线程,就是一个提交到通用pool的过程。</li></ul><h3 id="join">7.4.2. join</h3><p>join是等待任务完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果得到的结果异常，则抛出异常；</li><li>如果得到的正常，则获取返回值。</li></ul><p>看<code>doJoin()</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) </span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helps and/or blocks until the given task is done or timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w caller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deadline for timed waits, if nonzero</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task status on exit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        <span class="comment">// 这里好像是jdk8什么不得了的东西，晚点再看</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">            (CountedCompleter&lt;?&gt;)task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)</span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))</span><br><span class="line">                helpStealer(w, task);</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;</span><br><span class="line">                task.internalWait(ms);</span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是status&lt;0,表示完成，直接返回</li><li>如果是工作线程，尝试把task从<code>top</code>位置弹出，成功则执行task</li><li>如果该任务不在top位置,则调用awaitJoin方法：<ul><li>设置<code>currentJoin</code>表明自己正在等待该任务；</li><li>如果发现 <code>w.base == w.top</code>(没任务) 或者  <code>tryRemoveAndExec</code>返回true说明自己所属的队列为空，也说明本线程的任务已经被别的线程偷走，该线程也不会闲着，将会<code>helpStealer</code>帮助帮助自己执行任务的线程执行任务(互惠互利,你来我往)</li><li>如果<code>tryCompensate</code>为 true,则阻塞本线程，等待任务执行结束的唤醒</li></ul></li><li>如果不是工作线程在join，则阻塞直到任务执行完毕。</li></ul><h4 id="tryRemoveAndExec">7.4.2.1. tryRemoveAndExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If present, removes from queue and executes the given task,</span></span><br><span class="line"><span class="comment"> * or any other cancelled task. Used only by awaitJoin.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if queue empty and task not known to be done</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;      <span class="comment">// traverse from s to b</span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;     <span class="comment">// shorter than expected</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;      <span class="comment">// pop</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (base == b)      <span class="comment">// replace with proxy</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                            a, j, task, <span class="keyword">new</span> EmptyTask());</span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        task.doExec();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>))</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// was cancelled</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果刚好在top位置，pop出来执行。</li><li>如果在队列中间,则使用EmptyTask来占位,将任务取出来执行。</li><li>如果执行的任务还没结束。则返回false，外部不进行<code>helpStealer</code>。</li></ul><h4 id="helpStealer">7.4.2.2. helpStealer</h4><ul><li><p>遍历<code>WorkQueue[]</code>的奇数下标，<code>WorkQueue</code>的<code>currentSteal</code>如果是自己在找的任务，说明这个队列A是小偷</p></li><li><p>如果A有任务，则从队尾<code>(base)</code>取出执行</p></li><li><p>如果A没有任务，则根据A的owner线程正在join的任务,在拓扑找到相关的队列B去偷取任务执行。（代码好鸡儿复杂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">    t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">&#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// 小于0表示任务结束</span></span><br><span class="line">         w.top != top &amp;&amp; <span class="comment">// top位置相同表示没fork新的子任务到自己queue上</span></span><br><span class="line">         (t = w.pop()) != <span class="keyword">null</span>); <span class="comment">// top位置不同，把子任务pop出来。</span></span><br></pre></td></tr></table></figure></li><li><p>帮忙执行任务完成后，如果发现自己的队列有任务了(w.base != w.top)，在不再帮助执行任务了。</p></li><li><p>否则在等待自己的join的那个任务结束之前，可以不断的偷取任务执行。</p></li></ul><h4 id="tryCompensate">7.4.2.3. tryCompensate</h4><p>如果自己等待的任务被偷走执行还没结束,自己的队列还有任务，我们需要做一些补偿</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to decrement active count (sometimes implicitly) and</span></span><br><span class="line"><span class="comment"> * possibly release or create a compensating worker in preparation</span></span><br><span class="line"><span class="comment"> * for blocking. Returns false (retryable by caller), on</span></span><br><span class="line"><span class="comment"> * contention, detected staleness, instability, or termination.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w caller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">long</span> c; <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">        (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">        (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>)(c &gt;&gt; TC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                       (~AC_MASK &amp; c));       <span class="comment">// uncompensated</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                 (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                <span class="string">"Thread limit exceeded replacing blocked worker"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>; <span class="keyword">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 ((sp = (int)(c = ctl)) != 0) 说明还有 idle worker则可以选择唤醒线程替代自己,挂起自己等待任务来唤醒自己。</li><li>如果没有idle worker 则额外创建一个新的工作线程替代自己,挂起自己等待任务来唤醒自己。</li></ul><h1 id="后记">8. 后记</h1><p>很多没细看，了解一下思路就没了 = = </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;jdk8的parallerStream的实现依赖这种线程池。这个类带上注释3478行，表示很慌。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://htchz.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="multithread" scheme="https://htchz.cc/tags/multithread/"/>
    
  </entry>
  
</feed>
