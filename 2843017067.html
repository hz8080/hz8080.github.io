<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>[Java基础]ForkJoinPool | 土川的自留地</title>
  <meta name="description" content="jdk8的parallerStream的实现依赖这种线程池。这个类带上注释3478行，表示很慌。">
<meta name="keywords" content="multithread">
<meta property="og:type" content="article">
<meta property="og:title" content="[Java基础]ForkJoinPool">
<meta property="og:url" content="https://htchz.cc/2843017067.html">
<meta property="og:site_name" content="土川的自留地">
<meta property="og:description" content="jdk8的parallerStream的实现依赖这种线程池。这个类带上注释3478行，表示很慌。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://htchz.cc/images/pasted-143.png">
<meta property="og:image" content="https://htchz.cc/images/pasted-146.png">
<meta property="og:image" content="https://htchz.cc/images/pasted-145.png">
<meta property="og:image" content="https://htchz.cc/images/pasted-144.png">
<meta property="og:image" content="https://htchz.cc/images/pasted-147.png">
<meta property="og:updated_time" content="2018-10-22T03:34:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Java基础]ForkJoinPool">
<meta name="twitter:description" content="jdk8的parallerStream的实现依赖这种线程池。这个类带上注释3478行，表示很慌。">
<meta name="twitter:image" content="https://htchz.cc/images/pasted-143.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://htchz.cc/2843017067.html">
  
    <link rel="alternate" href="/atom.xml" title="土川的自留地" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/unnamed.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/fennecs" target="_blank">
          <img class="img-circle img-rotate" src="/images/unnamed.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">土川</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">后端码农</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fennecs" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>碧油鸡!碧油鸡！</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DB/">DB</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Firebase/">Firebase</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang基础/">Golang基础</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a><span class="category-list-count">49</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Proxy/">Proxy</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器/">容器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/建站/">建站</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/碎碎念/">碎碎念</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/">AOP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BT/">BT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BUG/">BUG</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bean/">Bean</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Https/">Https</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/">Hystrix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/">IOC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java集合/">Java集合</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/">Json</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/">OOP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZAB/">ZAB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bbr/">bbr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deploy/">deploy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/goroutine/">goroutine</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/istio/">istio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8/">jdk8</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/">k8s</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multithread/">multithread</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/properties/">properties</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/">raft</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/一致性算法/">一致性算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位图/">位图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/坑/">坑</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据分片/">数据分片</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务限流/">服务限流</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AOP/" style="font-size: 13.29px;">AOP</a> <a href="/tags/BT/" style="font-size: 13px;">BT</a> <a href="/tags/BUG/" style="font-size: 13.43px;">BUG</a> <a href="/tags/Bean/" style="font-size: 13px;">Bean</a> <a href="/tags/GC/" style="font-size: 13.57px;">GC</a> <a href="/tags/HTTP/" style="font-size: 13px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 13px;">Hexo</a> <a href="/tags/Https/" style="font-size: 13px;">Https</a> <a href="/tags/Hystrix/" style="font-size: 13px;">Hystrix</a> <a href="/tags/IOC/" style="font-size: 13px;">IOC</a> <a href="/tags/JVM/" style="font-size: 13.71px;">JVM</a> <a href="/tags/Java集合/" style="font-size: 14px;">Java集合</a> <a href="/tags/Json/" style="font-size: 13px;">Json</a> <a href="/tags/Mysql/" style="font-size: 13.14px;">Mysql</a> <a href="/tags/NIO/" style="font-size: 13.14px;">NIO</a> <a href="/tags/Nginx/" style="font-size: 13px;">Nginx</a> <a href="/tags/OOP/" style="font-size: 13.29px;">OOP</a> <a href="/tags/TCP/" style="font-size: 13.14px;">TCP</a> <a href="/tags/ZAB/" style="font-size: 13px;">ZAB</a> <a href="/tags/bbr/" style="font-size: 13px;">bbr</a> <a href="/tags/deploy/" style="font-size: 13px;">deploy</a> <a href="/tags/goroutine/" style="font-size: 13.14px;">goroutine</a> <a href="/tags/istio/" style="font-size: 13px;">istio</a> <a href="/tags/jdk8/" style="font-size: 13.14px;">jdk8</a> <a href="/tags/k8s/" style="font-size: 13.14px;">k8s</a> <a href="/tags/multithread/" style="font-size: 13.86px;">multithread</a> <a href="/tags/properties/" style="font-size: 13px;">properties</a> <a href="/tags/raft/" style="font-size: 13.14px;">raft</a> <a href="/tags/一致性算法/" style="font-size: 13.14px;">一致性算法</a> <a href="/tags/位图/" style="font-size: 13px;">位图</a> <a href="/tags/位运算/" style="font-size: 13px;">位运算</a> <a href="/tags/坑/" style="font-size: 13px;">坑</a> <a href="/tags/数据分片/" style="font-size: 13px;">数据分片</a> <a href="/tags/服务限流/" style="font-size: 13.14px;">服务限流</a> <a href="/tags/正则/" style="font-size: 13px;">正则</a> <a href="/tags/运维/" style="font-size: 13px;">运维</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">38</span></li></ul>
    </div>
  </div>


    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse in" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用例子"><span class="toc-text">2. 使用例子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原理"><span class="toc-text">3. 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概念"><span class="toc-text">4. 概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sun-misc-Contended"><span class="toc-text">5. sun.misc.Contended</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本说明"><span class="toc-text">6. 基本说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinPool"><span class="toc-text">6.1. ForkJoinPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WorkQueue"><span class="toc-text">6.2. WorkQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinTask"><span class="toc-text">6.3. ForkJoinTask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinWorkerThread"><span class="toc-text">6.4. ForkJoinWorkerThread</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重场戏"><span class="toc-text">7. 重场戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通用ForkJoinPool的初始化"><span class="toc-text">7.1. 通用ForkJoinPool的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务提交"><span class="toc-text">7.2. 任务提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#parallelism初始化"><span class="toc-text">7.2.1. parallelism初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作线程的运行"><span class="toc-text">7.3. 工作线程的运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scan"><span class="toc-text">7.3.1. scan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runTask"><span class="toc-text">7.3.2. runTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitWork"><span class="toc-text">7.3.3. awaitWork</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务执行"><span class="toc-text">7.4. 任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-text">7.4.1. fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">7.4.2. join</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tryRemoveAndExec"><span class="toc-text">7.4.2.1. tryRemoveAndExec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#helpStealer"><span class="toc-text">7.4.2.2. helpStealer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryCompensate"><span class="toc-text">7.4.2.3. tryCompensate</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后记"><span class="toc-text">8. 后记</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Java基础-ForkJoinPool" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      [Java基础]ForkJoinPool
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2843017067.html" class="article-date">
	  <time datetime="2018-09-20T09:01:00.000Z" itemprop="datePublished">2018-09-20</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/multithread/">multithread</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2843017067.html#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.7k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 51(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <blockquote>
<p>jdk8的parallerStream的实现依赖这种线程池。这个类带上注释3478行，表示很慌。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1><p>设计这个线程池的原因不是为了取代<code>ThreadPoolExecutor</code>，ForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</p>
<h1 id="使用例子">2. 使用例子</h1><p>核心思想就是拆分任务，这很快排的原理是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.htc.learning.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).toArray();</span><br><span class="line">        fork(numbers);</span><br><span class="line">        forkAndJoin(numbers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fork</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line">        pool.invoke(<span class="keyword">new</span> PrintTask(<span class="number">0</span>, numbers.length -<span class="number">1</span> , numbers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkAndJoin</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line">        <span class="keyword">long</span> sum = pool.invoke(<span class="keyword">new</span> SumTask(<span class="number">0</span>, numbers.length - <span class="number">1</span>, numbers));</span><br><span class="line">        System.out.println(<span class="string">"sum is :"</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是没有join结果的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小任务的打印量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">long</span>[] List)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.list = List;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                System.out.print(list[i] + <span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            PrintTask leftTask = <span class="keyword">new</span> PrintTask(start, middle, list);</span><br><span class="line">            PrintTask rightTask = <span class="keyword">new</span> PrintTask(middle + <span class="number">1</span>, end, list);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是join结果的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 小任务的计算量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">long</span>[] list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += list[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            SumTask leftTask = <span class="keyword">new</span> SumTask(start, middle, list);</span><br><span class="line">            SumTask rightTask = <span class="keyword">new</span> SumTask(middle + <span class="number">1</span>, end, list);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果<br><img src="/images/pasted-143.png" alt="upload successful"></p>
<p>结果很乱，可以看出<code>fork()</code>是异步的，如果使用<code>join()</code>阻塞的话，可以将计算变为同步。</p>
<h1 id="原理">3. 原理</h1><p>老李的<a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener">论文</a></p>
<ol>
<li>分治。这个从使用方式就可以看出来。</li>
<li>工作窃取（work-stealing）。</li>
<li>每个工作队列一个线程。</li>
</ol>
<p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为<strong>每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应</strong>，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<blockquote>
<p>据说ForkJoinPool在jdk7和jdk8的实现不一样。现在是jdk8的时代，我暂时不去看jdk7的实现啦。</p>
</blockquote>
<p><img src="/images/pasted-146.png" alt="upload successful"></p>
<ul>
<li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li>
<li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li>
<li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li>
<li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。（其实我不理解这句话，什么叫遇到join()时）</li>
<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li>
</ul>
<p>那么<code>fork()</code>每次调用都会创建一个线程吗，答案并不是，对于<code>ForkJoinPool</code>构造函数给出线程数就创建多少线程。<br>那么<code>join()</code>也会阻塞吗，不一定，具体我们后面看源码实现。</p>
<h1 id="概念">4. 概念</h1><p><img src="/images/pasted-145.png" alt="upload successful"></p>
<ul>
<li><code>ForkJoinPool</code>: 用于执行<code>ForkJoinTask</code>任务的执行池,不再是传统执行池 <code>Worker+Queue</code> 的组合模式,而是维护了一个队列数组<code>WorkQueue</code>,这样在提交任务和线程任务的时候大幅度的减少碰撞。<br>]</li>
<li><code>WorkQueue</code>: <strong>双向</strong>列表,用于任务的有序执行,如果<code>WorkQueue</code>用于自己的执行线程<code>Thread</code>,线程默认将会从top端选取任务用来执行 - LIFO。因为只有owner的Thread才能从<code>top</code>端取任务,所以在设置变量时, <code>int top</code>; 不需要使用 <code>volatile</code>。</li>
<li><code>ForkJoinWorkThread</code>: 用于执行任务的线程,用于区别使用非<code>ForkJoinWorkThread</code>线程提交的task;启动一个该<code>Thread</code>,会自动注册一个<code>WorkQueue</code>到<code>Pool</code>,这里规定,<strong>拥有<code>Thread</code>的<code>WorkQueue</code>只能出现在<code>WorkQueue</code>数组的奇数位</strong></li>
<li><code>ForkJoinTask</code>: 任务, 它比传统的任务更加轻量，不再对是<code>RUNNABLE</code>的子类,提供<code>fork/join</code>方法用于分割任务以及聚合结果。</li>
<li>为了充分施展并行运算,该框架实现了复杂的 <code>worker steal</code>算法,当任务处于等待中,thread通过一定策略,不让自己挂起，充分利用资源，当然，它比其他语言的协程要重一些。</li>
</ul>
<h1 id="sun-misc-Contended">5. sun.misc.Contended</h1><p>打开ForkJoinPool，第一行就是这么个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>度娘一下，看到了一个叫<strong>缓存行</strong>的东西，这个注解就是为了解决缓存行的<strong>伪共享</strong><code>False Sharing</code></p>
<blockquote>
<p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p>
</blockquote>
<p>看图：<br><img src="/images/pasted-144.png" alt="upload successful"><br>在缓存行L3 Cache里有x，y，线程1想去修改x，线程2想去修改y，那么这行缓存行就会称谓竞争对象，竞争的过程就会产生性能的损耗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// change  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayIndex;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里分别换成不同的类的数组，使用数组是为了内存连续</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong3[] longs = <span class="keyword">new</span> VolatileLong3[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;  </span><br><span class="line">            longs[i] = <span class="keyword">new</span> VolatileLong3();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();  </span><br><span class="line">        runTest();  </span><br><span class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;  </span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;  </span><br><span class="line">            t.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;  </span><br><span class="line">            t.join();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;  </span><br><span class="line">            longs[arrayIndex].value = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// long padding避免false sharing  </span></span><br><span class="line">    <span class="comment">// 按理说jdk7以后long padding应该被优化掉了，但是从测试结果看padding仍然起作用  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong2</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// jdk8新特性，Contended注解避免false sharing  </span></span><br><span class="line">    <span class="comment">// Restricted on user classpath  </span></span><br><span class="line">    <span class="comment">// Unlock: -XX:-RestrictContended  </span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong3</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换三种声明，测试结果如下</p>
<pre><code>VolatileLong: duration = 31605817365
VolatileLong2:duration = 3725651254
VolatileLong3:duration = 3762335746</code></pre><p>VolatileLong2的原理：<br>缓冲行有64字节，那么在属性<code>value</code>前面排列7个long，后面排列7个long，放到内存的时候，<code>value</code>无论如何都会和周围的long成员组成一个8个long，即64字节，从而避免缓存行的竞争。</p>
<p>而jdk8提供了<code>@sun.misc.Contended</code>注解后就不用写的这么麻烦了(也是填充了字节，具体看<a href="https://www.jianshu.com/p/c3c108c3dcfd" target="_blank" rel="noopener">Java8使用@sun.misc.Contended避免伪共享</a>)。</p>
<h1 id="基本说明">6. 基本说明</h1><h2 id="ForkJoinPool">6.1. ForkJoinPool</h2><p><code>ForkJoinPool</code>有超多的常量,下面是一部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bits and masks for field ctl, packed with 4 16 bit subfields:</span></span><br><span class="line"><span class="comment"> * AC: Number of active running workers minus target parallelism</span></span><br><span class="line"><span class="comment"> * TC: Number of total workers minus target parallelism</span></span><br><span class="line"><span class="comment"> * SS: version count and status of top waiting thread</span></span><br><span class="line"><span class="comment"> * ID: poolIndex of top of Treiber stack of waiters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When convenient, we can extract the lower 32 stack top bits</span></span><br><span class="line"><span class="comment"> * (including version bits) as sp=(int)ctl.  The offsets of counts</span></span><br><span class="line"><span class="comment"> * by the target parallelism and the positionings of fields makes</span></span><br><span class="line"><span class="comment"> * it possible to perform the most common checks via sign tests of</span></span><br><span class="line"><span class="comment"> * fields: When ac is negative, there are not enough active</span></span><br><span class="line"><span class="comment"> * workers, when tc is negative, there are not enough total</span></span><br><span class="line"><span class="comment"> * workers.  When sp is non-zero, there are waiting workers.  To</span></span><br><span class="line"><span class="comment"> * deal with possibly negative fields, we use casts in and out of</span></span><br><span class="line"><span class="comment"> * "short" and/or signed shifts to maintain signedness.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because it occupies uppermost bits, we can add one active count</span></span><br><span class="line"><span class="comment"> * using getAndAddLong of AC_UNIT, rather than CAS, when returning</span></span><br><span class="line"><span class="comment"> * from a blocked join.  Other updates entail multiple subfields</span></span><br><span class="line"><span class="comment"> * and masking, requiring CAS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Lower and upper word masks</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK    = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK    = ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Active counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  AC_SHIFT   = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK    = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Total counts</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TC_SHIFT   = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK    = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSLOCK     = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSIGNAL    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STARTED    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STOP       = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  SHUTDOWN   = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<p><strong>runstate</strong>：如果执行 runState &amp; RSLOCK ==0 就能直接说明,目前的运行状态没有被锁住,其他情况一样。</p>
<p><strong>config</strong>：parallelism， mode。parallelism是构造函数的参数，表示并行等级，不等于工作队列的数量。需要注意一下它的界限，最大是0x7fff。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// max #workers - 1</span></span><br></pre></td></tr></table></figure>

<p><strong>ctl</strong>：ctl是Pool的状态变量,类型是long - 说明有64位,每个部分都有不同的作用。我们使用十六进制来标识ctl，依次说明不同部分的作用。（这和普通线程池一样）</p>
<p>以下是构造函数，可以看到<code>ctl</code>的初始化，我们把<code>ctl</code>标识为4部分，<br>0x xxxx-1  xxxx-2  xxxx-3  xxxx-4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters, without</span></span><br><span class="line"><span class="comment"> * any security checks or parameter validation.  Invoked directly by</span></span><br><span class="line"><span class="comment"> * makeCommonPool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1号16位，表示AC(Active counts)并行数的负数。当ctl变成正数的时候表示线程数达到阈值了。(为什么不能用正数，然后负数的时候就表示达到阈值？？)</li>
<li>2号16位，表示TC(Total counts)并行数。Total counts等于挂起的线程数+AC，(也是用负数表示)</li>
<li>3号16位，表示SS，后32位标识<strong>idle workers</strong> 前面16位第一位标识是<code>active</code>的还是<code>inactive</code>的,其他为是版本标识。</li>
<li>4号16位，表示ID(Index)，标识<strong>idle workers</strong>在<code>WorkQueue[]</code>数组中的<code>index</code>。这里需要说明的是,ctl的后32位其实只能表示一个idle workers，那么我们如果有很多个idle worker要怎么办呢？老李使用的是stack的概念来保存这些信息。后32位标识的是栈顶的那个,我们能从栈顶中的变量stackPred追踪到下一个idle worker</li>
</ul>
<h2 id="WorkQueue">6.2. WorkQueue</h2><p><code>WorkQueue</code>是一个双向列表,存放任务<code>task</code>。<br><code>WorkQueue</code>类也用了<code>@sun.misc.Contended</code>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Capacity of work-stealing queue array upon initialization.</span></span><br><span class="line"><span class="comment">         * Must be a power of two; at least 4, but should be larger to</span></span><br><span class="line"><span class="comment">         * reduce or eliminate cacheline sharing among queues.</span></span><br><span class="line"><span class="comment">         * Currently, it is much larger, as a partial workaround for</span></span><br><span class="line"><span class="comment">         * the fact that JVMs often place arrays in locations that</span></span><br><span class="line"><span class="comment">         * share GC bookkeeping (especially cardmarks) such that</span></span><br><span class="line"><span class="comment">         * per-write accesses encounter serious memory contention.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Maximum size for queue arrays. Must be a power of two less</span></span><br><span class="line"><span class="comment">         * than or equal to 1 &lt;&lt; (31 - width of array entry) to ensure</span></span><br><span class="line"><span class="comment">         * lack of wraparound of index calculations, but defined to a</span></span><br><span class="line"><span class="comment">         * value a bit less than this to help users trap runaway</span></span><br><span class="line"><span class="comment">         * programs before saturating systems.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instance fields</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line">        <span class="keyword">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor</span></span><br><span class="line">        <span class="keyword">int</span> nsteals;               <span class="comment">// number of steals</span></span><br><span class="line">        <span class="keyword">int</span> hint;                  <span class="comment">// randomization and stealer index hint</span></span><br><span class="line">        <span class="keyword">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line">        <span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line">        <span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line">        <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line">        <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br><span class="line"></span><br><span class="line">        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">            <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">            base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING     = <span class="number">1</span>;             <span class="comment">// false when running tasks</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE     = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br></pre></td></tr></table></figure>

<p><strong>scanState</strong>:负数表示inactive; 奇数表示scanning。如果WorkQueue没有属于自己的owner(下标为偶数的都没有),该值为 inactive 也就是一个负数。如果有自己的owner，该值的初始值为其在WorkQueue[]数组中的下标，也肯定是个奇数。<br>如果这个值，变成了偶数，说明该队列所属的Thread正在执行Task<br><strong>stackPred</strong>: 记录前任的 idle worker<br><strong>config</strong>：index | mode。 如果下标为偶数的WorkQueue,则其mode是共享类型。如果有自己的owner 默认是 LIFO。mode是由<code>ForkJoinPool</code>其中一个构造函数传进来的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism the parallelism level. For default value,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> java.lang.Runtime#availableProcessors&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory the factory for creating new threads. For default value,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> #defaultForkJoinWorkerThreadFactory&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler for internal worker threads that</span></span><br><span class="line"><span class="comment"> * terminate due to unrecoverable errors encountered while executing</span></span><br><span class="line"><span class="comment"> * tasks. For default value, use &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asyncMode if true,</span></span><br><span class="line"><span class="comment"> * establishes local first-in-first-out scheduling mode for forked</span></span><br><span class="line"><span class="comment"> * tasks that are never joined. This mode may be more appropriate</span></span><br><span class="line"><span class="comment"> * than default locally stack-based mode in applications in which</span></span><br><span class="line"><span class="comment"> * worker threads only process event-style asynchronous tasks.</span></span><br><span class="line"><span class="comment"> * For default value, use &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if parallelism less than or</span></span><br><span class="line"><span class="comment"> *         equal to zero, or greater than implementation limit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the factory is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment"> *         the caller is not permitted to modify threads</span></span><br><span class="line"><span class="comment"> *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> ("modifyThread")&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">         checkFactory(factory),</span><br><span class="line">         handler,</span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">         <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>英文不太ok，看了注释应该是，asyncMode下工作线程在处理本地任务时也使用 FIFO 顺序。这种模式下的 ForkJoinPool 更接近于是一个消息队列，而不是用来处理递归式的任务。<a href="https://stackoverflow.com/questions/5640046/what-is-forkjoinpool-async-mode" target="_blank" rel="noopener">stackoverflow</a>有个回答举了个例子，可以明显看到asyncMode的先进先出的执行方式。<br>我想你的ForkJoinPool不是私有的，那就设置成异步模式吧。</p>
</blockquote>
<p><strong>qlock</strong>：队列锁<br><strong>base</strong>：<code>worker steal</code>的偏移量,因为其他的线程都可以偷该队列的任务,所有base使用<code>volatile</code>标识。<br><strong>top</strong>:owner执行任务的偏移量。<br><strong>parker</strong>:如果 <code>owner</code> 挂起，则使用该变量做记录<br><strong>currentJoin</strong>:当前正在<code>join</code>等待结果的任务。<br><strong>currentSteal</strong>:当前执行的任务是steal过来的任务，该变量做记录。  </p>
<h2 id="ForkJoinTask">6.3. ForkJoinTask</h2><p>这是个抽象类,我们声明的任务是他的子类，下面是他的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The run status of this task */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status; <span class="comment">// accessed directly by pool and workers</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// mask out non-completion bits</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">// short bits for tags</span></span><br></pre></td></tr></table></figure>

<p>如果<code>status</code> &lt; 0，表示任务已经结束<br><code>((s &gt;&gt;&gt; 16) != 0)</code>表示需要signal其他线程</p>
<h2 id="ForkJoinWorkerThread">6.4. ForkJoinWorkerThread</h2><p>这就是工作线程的封装，继承自<code>Thread</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ForkJoinWorkerThreads are managed by ForkJoinPools and perform</span></span><br><span class="line"><span class="comment">     * ForkJoinTasks. For explanation, see the internal documentation</span></span><br><span class="line"><span class="comment">     * of class ForkJoinPool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This class just maintains links to its pool and WorkQueue.  The</span></span><br><span class="line"><span class="comment">     * pool field is set immediately upon construction, but the</span></span><br><span class="line"><span class="comment">     * workQueue field is not set until a call to registerWorker</span></span><br><span class="line"><span class="comment">     * completes. This leads to a visibility race, that is tolerated</span></span><br><span class="line"><span class="comment">     * by requiring that the workQueue field is only accessed by the</span></span><br><span class="line"><span class="comment">     * owning thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Support for (non-public) subclass InnocuousForkJoinWorkerThread</span></span><br><span class="line"><span class="comment">     * requires that we break quite a lot of encapsulation (via Unsafe)</span></span><br><span class="line"><span class="comment">     * both here and in the subclass to access and set Thread fields.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// the pool this thread works in</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// work-stealing mechanics</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以清楚地看到，ForkJoinWorkThread持有ForkJoinPool和ForkJoinPool.WorkQueue的引用，以表明该线程属于哪个线程池，它的工作队列是哪个</p>
<h1 id="重场戏">7. 重场戏</h1><h2 id="通用ForkJoinPool的初始化">7.1. 通用ForkJoinPool的初始化</h2><p><code>ForkJoinPool</code>类的static代码块初始化了一个全局通用的ForkJoinPool，这是老李推荐的使用方式，不用自己new new new。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title">commonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert common != null : "static init error";</span></span><br><span class="line">    <span class="keyword">return</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns the common pool, respecting user settings</span></span><br><span class="line"><span class="comment"> * specified via system properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing properties</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>);</span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span>);</span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">"ForkJoinPool.commonPool-worker-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几个参数可以通过java -D指定，如果不指定，那么使用默认参数构造，并行数默认情况是<code>计算机处理器数-1</code></p>
<h2 id="任务提交">7.2. 任务提交</h2><p>我们提交的任务，不管是<code>Runnable</code>,<code>Callable</code>，<code>ForkJoinTask</code>，最终都会变成封装为<code>ForkJoinTask</code>。</p>
<p>由于实现了<code>ExecutorService</code>，自然实现了<code>submit(task)</code>、<code>execute(task)</code>方法，而他自己还又一个<code>invoke(task)</code>的方法，这么多个执行，什么时候用什么呢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>execute(task)</code>和普通线程池一样无返回，<code>submit(task)</code>返回了一个<code>ForkJoinTask</code>,而<code>invoke(task)</code>返回直接调用<code>join()</code>阻塞，知道计算得出结果返回。</p>
<p>这几个都是调用<code>externalPush(task);</code>方法，和普通线程池一样，在提交任务的过程中会视情况增加工作线程，和普通线程池不一样的是还要同时增加工作队列。</p>
<blockquote>
<p>注意：工作线程和工作队列的不是一对一关系 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to add the given task to a submission queue at</span></span><br><span class="line"><span class="comment"> * submitter's current queue. Only the (vastly) most common path</span></span><br><span class="line"><span class="comment"> * is directly handled in this method, while screening for need</span></span><br><span class="line"><span class="comment"> * for externalSubmit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 取得一个随机探查数，可能为0也可能为其它数</span></span><br><span class="line">    <span class="comment">// 利用这个数提交到任务队列数组中的随机一个队列</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="comment">// 他喵的这个if有够复杂</span></span><br><span class="line">    <span class="comment">// SQMASK = 0x007e，也就是0000 0000 0111 1110，与这个数与出来的结果，只能是个偶数</span></span><br><span class="line">    <span class="comment">// 如果（（任务队列数组非空）且（数组长度&gt;=1）且（数组长度-1与随机数与0x007e得出来的下标处有工作队列）且（随机数!=0）且（线程池在运行）且（获取锁成功））</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;<span class="comment">// am=数组长度，n=top-base，s=top</span></span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// 感觉这个不为true的情况只能是==，不会&lt;</span></span><br><span class="line">            (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="comment">// ABASE是利用Unsafe得到的队列base属性内存地址，因为用Unsafe加入队列，所以要计算出top的内存地址</span></span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="comment">// 以下三个原子操作首先是将task放入队列,</span></span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            <span class="comment">// 然后将“q”这个submission queue的top标记+1,记得queue的owner线程是默认从top拿的任务</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果条件成立，说明这时处于active的工作线程可能还不够，调用signalWork方法</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可能上面没有解锁，保证能解锁。</span></span><br><span class="line">        <span class="comment">// 这不会解锁了其他小偷吗 = =</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我注意到了这个方法<code>ThreadLocalRandom.getProbe()</code>，这是个一个包级别的方法，只有<code>concurrent</code>包才能用他。这个方法返回一个随机数，而且是固定的，但是如果没执行<code>ThreadLocalRandom.localInit();</code>，调用结果会是0。</p>
<blockquote>
<p>把他的源码复制出来后执行得出来的结论。</p>
</blockquote>
<p>也就是说，主线程执行<code>externalPush</code>的时候，由于<code>ThreadLocalRandom.getProbe();</code>返回一直0，是直接进入<code>externalSubmit(task)</code></p>
<p>那坨<code>if</code>块主要做的是按线程给的随机数随机放入<code>workqueue</code>数组中队列，随机方式是<code>m &amp; r &amp; SQMASK</code>，(数组大小-1)与随机数与<strong>偶数掩码</strong></p>
<p>入队的方式是放到随机队列的top位置，利用Unsafe来操作，真是🐂🍺，而队列owner拿的时候也是从top拿。</p>
<p><code>externalSubmit(task)</code>的代码很长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;                                    <span class="comment">// initialize caller's probe</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果条件成立，就说明当前ForkJoinPool类中，还没有任何队列，所以要进行队列初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                 ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                                           <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 方法的唯一出口</span></span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 即上面的队列==null且runstate没有被锁住</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            <span class="comment">// 重新获取一个随机数</span></span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>如果hash之后的队列已经存在  </p>
<ul>
<li>lock住队列,将数据塞到top位置。如果该队列任务很少(n &lt;= 1)也会调用<code>signalWork</code></li>
</ul>
</li>
<li><p>如果第一次提交(或者是hash之后的队列还未初始化),调用externalSubmit</p>
<ul>
<li>第一遍循环: (runState不是开始状态): 1.<code>lock</code>; 2.创建数组<code>WorkQueue[n]</code>，这里的n是根据<code>parallelism</code>初始化的; 3. <code>runState</code>设置为开始状态。</li>
<li>第二遍循环:(根据<code>ThreadLocalRandom.getProbe()</code>hash后的数组中相应位置的WorkQueue未初始化): 初始化<code>WorkQueue</code>,通过这种方式创立的<code>WorkQueue</code>均是<code>SUBMISSIONS_QUEUE</code>(<code>owner</code>为<code>null</code>),<code>scanState</code>为<code>INACTIVE</code></li>
<li>第三遍循环: 找到刚刚创建的WorkQueue,lock住队列,将数据塞到array<code>top</code>位置。如添加成功，就用调用接下来要摊开讲的重要的方法<code>signalWork</code>。</li>
</ul>
</li>
</ul>
<h3 id="parallelism初始化">7.2.1. parallelism初始化</h3><p>关于parallelism，我们浓缩一下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// SMASK是一个常量，即 00000000 00000000 11111111 11111111</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK = <span class="number">0xffff</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 这是config的来源</span></span><br><span class="line"><span class="comment">// mode是ForkJoinPool构造函数中设定的asyncMode，如果为LIFO，则mode为0，否则为1&lt;&lt;16(FIFO_QUEUE),也就是说，config中低16位代表并行度</span></span><br><span class="line"><span class="comment">// parallelism 为技术人员设置的（或者程序自行设定的）并发等级</span></span><br><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// ensure at least 2 slots</span></span><br><span class="line"><span class="comment">// 取config的低16位</span></span><br><span class="line"><span class="keyword">int</span> p = config &amp; SMASK; </span><br><span class="line"><span class="comment">// n这个变量就是要计算的WorkQueue数组的大小</span></span><br><span class="line"><span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这么多位操作，在<code>java.util.HashMap#tableSizeFor</code>(本博客有)里也有出现过，<code>tableSizeFor</code>是为了计算出最接近且大于给定的构造容量的2幂数，而这里的位操作，比<code>tableSizeFor</code>多了一个<code>n = (n + 1) &lt;&lt; 1;</code>的计算，也就是计算出最接近且大于给定的构造容量的2幂数——然后在<code>*2</code>，ForkJoinPool中的这些WorkQueue和工作线程ForkJoinWorkerThread并不是一对一的关系，而是随时都有多余ForkJoinWorkerThread数量的WorkQueue元素。而这个ForkJoinPool中的WorkQueue数组中，索引位为非奇数的工作队列用于存储从外部提交到ForkJoinPool中的任务，也就是所谓的submissions queue；索引位为偶数的工作队列用于存储归并计算过程中等待处理的子任务，也就是task queue。<br><img src="/images/pasted-147.png" alt="upload successful"></p>
<p>我们看<code>signalWork(ws, q)</code>做了什么，这个会触发构造新队列和新线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to create or activate a worker if too few are active.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ws the worker array to use to find signallees</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q a WorkQueue --if non-null, don't retry if now empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// c是ctl，sp是ctl低32位</span></span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是一个<code>while</code>循环循环，当<code>ctl</code>小于0的时候才要进行创建和激活新线程。</p>
<p>如果<code>sp</code>等于0，表示没有空闲线程。此时<code>(c &amp; ADD_WORKER) != 0L</code>即TC符号位是1，TC是个负数，表示<code>worker</code>还可以增加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADD_WORKER是一个第48位为1，其余为0的64数，可以区分TC的符号位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign</span></span><br></pre></td></tr></table></figure>

<p>下面看<code>tryAddWorker(c)</code>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	<span class="comment">// new ctl</span></span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先需要使用ctl来记录我们增加的线程, ctl编号-1的16位和编号-2的16位均需要加1,表示active的worker(AC)加一，总的worker(TC)加一。成功后我们将调用<code>createWorker</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跑到这里来要注销线程</span></span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看<code>fac.newThread(this)</code>怎么实例化一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread(pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看<code>pool.registerWorker(this);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>ForkJoinWorkerThreadFactory</code>来产生一个<code>ForkJoinWorkerThread</code>类型的线程，该线程将会把自己注册到Pool上,怎么注册的呢？实现在方法<code>registerWorker</code>,前文我们已经提及,拥有线程的WorkQueue只能出现在数组的奇数下标处。所以线程首先,创建一个新的WorkQueue，其次在数组WorkQueue[]寻找奇数下标尚未初始化的位置,如果循环的次数大于数组长度,还可能需要对数组进行扩容，然后，设置这个WorkQueue的 config 为 index | mode (下标和模式),<code>scanState</code>为 index (下标&gt;0)。最后启动这个线程。线程的处理我们接下来的章节介绍。</p>
<p>回到<code>signalWork</code>方法,如果<code>(sp = (int)c) == 0</code>不成立，表示又空闲线程，那么不用新增<code>worker</code>，直接唤醒工作队列的<code>owner</code></p>
<p>我们上文说过SP的高16位SS,标记inactive和版本控制,我们将SS设置为激活状态并且版本加一。ID的16位我们之前也说过,放置了挂起线程栈的index所以我们可以根据这个index拿到WorkQueue——意味着就是这个WorkQueue的Owner线程被挂起了。</p>
<blockquote>
<p>worker什么时候挂起？</p>
</blockquote>
<p>我们将要把栈顶挂起线程唤醒,意味着我们要讲下一个挂起的线程的信息记录到ctl上。前文也说在上一个挂起的线程的index信息在这个挂起的线程的stackPred。利用cas进行更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line"><span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line"><span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">    v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">    <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">        U.unpark(p);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工作线程的运行">7.3. 工作线程的运行</h2><p>Thread添加完成之后，执行<code>wt.start();</code>，这个方法会使得<code>run()</code>方法开始运行。</p>
<p>看<code>ForkJoinWorkerThread</code>的<code>run()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            <span class="comment">// 看节里</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Top-level runloop for workers, called by ForkJoinWorkerThread.run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)</span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift 随机数算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作线程先尝试<code>scan</code>窃取任务并执行，否则执行<code>awaitWork()</code>，如果<code>awaitWork()</code>返回<code>false</code>，<code>break</code>结束死循环。</p>
<h3 id="scan">7.3.1. scan</h3><p>又是一个长长的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的WorkQueue是有owner线程的队列，我们可以知道以下信息:</p>
<ul>
<li>config = index | mode</li>
<li>scanState = index &gt; 0<br>我们首先通过随机数<code>r</code>来寻找窃取队列。</li>
</ul>
<p>如果我们准备偷取的队列刚好有任务(也有可能是owner自己的那个队列)；</p>
<ul>
<li>从队列的队尾即base位置取到任务返回<ul>
<li>base + 1</li>
</ul>
</li>
<li>如果我们遍历了一圈<code>(((k = (k + 1) &amp; m) == origin))</code>都没有偷到,我们就认为当前的active线程过剩了,我们准备将当前的线程(即owner)挂起,我们首先 <code>index | INACTIVE</code> 形成 ctl的后32位;并行将AC减一。其次，将原来的挂起的栈顶的index记录到stackPred中。</li>
<li>继续遍历如果仍然一无所获,将跳出循环；如果偷到了一个任务,我们将使用tryRelease激活。</li>
</ul>
<h3 id="runTask">7.3.2. runTask</h3><p>获取到任务之后，执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        <span class="comment">// 执行窃取来的任务</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        <span class="comment">// 这里执行自己的线程的任务</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先scanState &amp;= ~SCANNING;标识该线程处于繁忙状态。</p>
<ul>
<li>执行偷取的Task。</li>
<li>调用execLocalTasks对线程所属的WorkQueue内的任务进行执行,按config设置的mode进行FIFO或者LIFO执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject</span><br><span class="line">                     (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="awaitWork">7.3.3. awaitWork</h3><p>scan不到任务的时候，就执行挂起，如果挂起返回false，表示线程池终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="keyword">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果ac还没到达阈值,但是<code>TC&gt;2</code>说明现在仍然运行中的线程和挂起的线程加一起处于过剩状态,我们将放弃该线程的挂起,直接让它执行结束，不再循环执行任务。</li>
<li>否则，我们计算一个挂起的时间，等到了时间之后(或者被外部唤醒),线程醒了之后,如果发现自己状态是active状态(<code>w.scanState &gt;= 0</code>),则线程继续回去scan任务，如果挂起时间结束，自己还是inactive状态,。线程也会执行结束，不再循环执行任务。</li>
</ul>
<h2 id="任务执行">7.4. 任务执行</h2><p>任务的执行是调用了<code>task.doExec()</code>方法，可以在<code>runTask(task)</code>方法看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>RecursiveTask</code>为例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     result = compute();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用了我们重写的<code>compute()</code>方法。</p>
<h3 id="fork">7.4.1. fork</h3><p>fork()像叉子把新任务提交，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前线程是工作线程,直接push到自己所拥有的队列的top位置。</li>
<li>如果是非工作线程,就是一个提交到通用pool的过程。</li>
</ul>
<h3 id="join">7.4.2. join</h3><p>join是等待任务完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果得到的结果异常，则抛出异常；</li>
<li>如果得到的正常，则获取返回值。</li>
</ul>
<p>看<code>doJoin()</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) </span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helps and/or blocks until the given task is done or timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w caller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deadline for timed waits, if nonzero</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task status on exit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        <span class="comment">// 这里好像是jdk8什么不得了的东西，晚点再看</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">            (CountedCompleter&lt;?&gt;)task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)</span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))</span><br><span class="line">                helpStealer(w, task);</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;</span><br><span class="line">                task.internalWait(ms);</span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是status&lt;0,表示完成，直接返回</li>
<li>如果是工作线程，尝试把task从<code>top</code>位置弹出，成功则执行task</li>
<li>如果该任务不在top位置,则调用awaitJoin方法：<ul>
<li>设置<code>currentJoin</code>表明自己正在等待该任务；</li>
<li>如果发现 <code>w.base == w.top</code>(没任务) 或者  <code>tryRemoveAndExec</code>返回true说明自己所属的队列为空，也说明本线程的任务已经被别的线程偷走，该线程也不会闲着，将会<code>helpStealer</code>帮助帮助自己执行任务的线程执行任务(互惠互利,你来我往)</li>
<li>如果<code>tryCompensate</code>为 true,则阻塞本线程，等待任务执行结束的唤醒</li>
</ul>
</li>
<li>如果不是工作线程在join，则阻塞直到任务执行完毕。</li>
</ul>
<h4 id="tryRemoveAndExec">7.4.2.1. tryRemoveAndExec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If present, removes from queue and executes the given task,</span></span><br><span class="line"><span class="comment"> * or any other cancelled task. Used only by awaitJoin.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if queue empty and task not known to be done</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;      <span class="comment">// traverse from s to b</span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;     <span class="comment">// shorter than expected</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;      <span class="comment">// pop</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (base == b)      <span class="comment">// replace with proxy</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                            a, j, task, <span class="keyword">new</span> EmptyTask());</span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        task.doExec();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>))</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// was cancelled</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果刚好在top位置，pop出来执行。</li>
<li>如果在队列中间,则使用EmptyTask来占位,将任务取出来执行。</li>
<li>如果执行的任务还没结束。则返回false，外部不进行<code>helpStealer</code>。</li>
</ul>
<h4 id="helpStealer">7.4.2.2. helpStealer</h4><ul>
<li><p>遍历<code>WorkQueue[]</code>的奇数下标，<code>WorkQueue</code>的<code>currentSteal</code>如果是自己在找的任务，说明这个队列A是小偷</p>
</li>
<li><p>如果A有任务，则从队尾<code>(base)</code>取出执行</p>
</li>
<li><p>如果A没有任务，则根据A的owner线程正在join的任务,在拓扑找到相关的队列B去偷取任务执行。（代码好鸡儿复杂）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">    t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">&#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// 小于0表示任务结束</span></span><br><span class="line">         w.top != top &amp;&amp; <span class="comment">// top位置相同表示没fork新的子任务到自己queue上</span></span><br><span class="line">         (t = w.pop()) != <span class="keyword">null</span>); <span class="comment">// top位置不同，把子任务pop出来。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>帮忙执行任务完成后，如果发现自己的队列有任务了(w.base != w.top)，在不再帮助执行任务了。</p>
</li>
<li><p>否则在等待自己的join的那个任务结束之前，可以不断的偷取任务执行。</p>
</li>
</ul>
<h4 id="tryCompensate">7.4.2.3. tryCompensate</h4><p>如果自己等待的任务被偷走执行还没结束,自己的队列还有任务，我们需要做一些补偿</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to decrement active count (sometimes implicitly) and</span></span><br><span class="line"><span class="comment"> * possibly release or create a compensating worker in preparation</span></span><br><span class="line"><span class="comment"> * for blocking. Returns false (retryable by caller), on</span></span><br><span class="line"><span class="comment"> * contention, detected staleness, instability, or termination.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w caller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">long</span> c; <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">        (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">        (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>)(c &gt;&gt; TC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                       (~AC_MASK &amp; c));       <span class="comment">// uncompensated</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                 (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                <span class="string">"Thread limit exceeded replacing blocked worker"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>; <span class="keyword">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 ((sp = (int)(c = ctl)) != 0) 说明还有 idle worker则可以选择唤醒线程替代自己,挂起自己等待任务来唤醒自己。</li>
<li>如果没有idle worker 则额外创建一个新的工作线程替代自己,挂起自己等待任务来唤醒自己。</li>
</ul>
<h1 id="后记">8. 后记</h1><p>很多没细看，了解一下思路就没了 = = </p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://htchz.cc/2843017067.html" title="[Java基础]ForkJoinPool" target="_blank" rel="external">https://htchz.cc/2843017067.html</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/fennecs" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/unnamed.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/fennecs" target="_blank"><span class="text-dark">土川</span><small class="ml-1x">后端码农</small></a></h3>
        <div>请说出Hello World的16种写法。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2747343217.html" title="[Golang基础]Goroutine调度"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/967765342.html" title="[Java基础]ScheduledThreadPoolExecutor"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn" data-toggle="collapse" href="#collapseToc" aria-expanded="true" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/fennecs" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   




   
    
    <script defer>
    var disqus_config = function () {
        
            this.page.url = 'https://htchz.cc/2843017067.html';
        
        this.page.identifier = 'Java基础-ForkJoinPool';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'htchz' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>




  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>